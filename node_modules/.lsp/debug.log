Hello - from /Users/tsimiho/.pulsar/packages/ide-reason/rls/rls-darwin-1.7.8.exe
Previous log location: /var/folders/st/cyh3v8ln22sdswp1s386w5vw0000gn/T/lsp.log
Sending notification {"jsonrpc": "2.0", "method": "client/registerCapability", "params": {"registrations": [{"id": "watching", "method": "workspace/didChangeWatchedFiles", "registerOptions": {"watchers": [{"globPattern": "**/bsconfig.json"}, {"globPattern": "**/.merlin"}]}}]}}
Sending response {"id": 0, "jsonrpc": "2.0", "result": {"capabilities": {"textDocumentSync": 1, "hoverProvider": true, "completionProvider": {"resolveProvider": true, "triggerCharacters": ["."]}, "signatureHelpProvider": {"triggerCharacters": ["("]}, "definitionProvider": true, "typeDefinitionProvider": true, "referencesProvider": true, "documentSymbolProvider": true, "codeActionProvider": true, "executeCommandProvider": {"commands": ["reason-language-server.add_to_interface_inner"]}, "codeLensProvider": {"resolveProvider": true}, "documentHighlightProvider": true, "documentRangeFormattingProvider": true, "documentFormattingProvider": true, "renameProvider": true}}}
Read message 
{"jsonrpc":"2.0","method":"initialized","params":{}}
Read message 
{"jsonrpc":"2.0","method":"workspace/didChangeConfiguration","params":{"settings":{"reason_language_server":{"format_width":80,"autoRebuild":true,"per_value_codelens":false,"dependencies_codelens":false,"opens_codelens":false}}}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///Users/tsimiho/Desktop/NTUA/ECE/Semester8/%CE%9C%CE%B5%CF%84%CE%B1%CE%B3%CE%BB%CF%89%CF%84%CF%84%CE%B9%CF%83%CF%84%CE%AD%CF%82/compiler/Irgen.ml","languageId":"reason","version":1,"text":"open Llvm\nopen Llvm_analysis\nopen Llvm_scalar_opts\nopen Llvm_ipo\nopen Llvm_vectorize\nopen Llvm_target\nopen Llvm.PassManager\n\nlet context = global_context ()\nlet the_module = create_module context \"alan source file\"\nlet builder = builder context\nlet int_type = i64_type context\nlet char_type = i8_type context\nlet void_type = void_type context\nlet bool_type = i1_type context\n\nlet rec to_llvm_type x = match x with\n| TYPE_int -> int_type\n| TYPE_byte -> char_type\n| TYPE_array (t,n) -> array_type (to_llvm_type t) n\n| TYPE_proc -> void_type\n| _ -> internal \"Trying to get an invalid llvm type\"; raise Terminate\n"}}}
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/tsimiho/Desktop/NTUA/ECE/Semester8/%CE%9C%CE%B5%CF%84%CE%B1%CE%B3%CE%BB%CF%89%CF%84%CF%84%CE%B9%CF%83%CF%84%CE%AD%CF%82/compiler/Irgen.ml"},"position":{"line":0,"character":0}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0190734863281ms
Sending response {"id": 1, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///Users/tsimiho/Desktop/NTUA/ECE/Semester8/%CE%9C%CE%B5%CF%84%CE%B1%CE%B3%CE%BB%CF%89%CF%84%CF%84%CE%B9%CF%83%CF%84%CE%AD%CF%82/compiler/Parser.mly","languageId":"reason","version":1,"text":"%{\n  open Symbol\n  open Types\n  open Identifier\n  open Error\n  open Narray\n\n  initSymbolTable 1000;\n\n  type param = { \n    id: Identifier.id list; \n    mode: pass_mode; \n    param_type: typ \n  }\n\n  and param_mode = PASS_BY_VALUE | PASS_BY_REFERENCE\n\n  let registerHeader id params return_type = \n    let fun_entry = newFunction id true in\n    (* openScope(); *)\n    List.iter ( fun p -> \n                  List.iter ( fun single_id -> \n                                ignore (newParameter single_id p.param_type p.mode fun_entry true) \n                            ) p.id\n              ) params;\n    match fun_entry.entry_info with\n    | ENTRY_function func_info ->\n        func_info.function_result <- return_type;\n    | _ -> error \"Expected a function entry %a\" pretty_id id;\n    endFunctionHeader fun_entry return_type\n\n  let callFunction id args =\n    let func_entry = lookupEntry id LOOKUP_ALL_SCOPES true in\n    match func_entry.entry_info with\n    | ENTRY_function inf -> if inf.function_isForward then\n                              let rec linkParams func_params func_args = \n                                match func_params, func_args with\n                                | fp::fps, fa::fas -> if fp.\n                                | [], [] -> inf.function_body () \n                                | _, _ -> error \"Function %a is called with the worng number of parameters\" pretty_id id; None\n                            else error \"%a has not been implemented\" pretty_id id; None\n    | _ -> error \"%a is not a function\" pretty_id id; None\n\n\n  let print_variable_value value =\n    match value with\n    | IntValue i -> Printf.printf \"IntValue: %d\\n\" i\n    | CharValue c -> Printf.printf \"CharValue: '%c'\\n\" c\n    | BoolValue b -> Printf.printf \"BoolValue: %b\\n\" b\n    | MultiArray arr -> Printf.printf \"MultiArray\"\n    | Unit -> Printf.printf \"Unit\\n\"\n\n  let print_grace_type t =\n    match t with\n    | TYPE_int | TYPE_char -> Printf.printf \"Not an array\\n\"\n    | _  -> Printf.printf \"array\\n\"\n        \n%}\n\n%token T_eof \n%token T_and\n%token T_char\n%token T_div\n%token T_do\n%token T_else\n%token T_fun\n%token T_if\n%token T_int \n%token T_mod\n%token T_not\n%token T_nothing\n%token T_or\n%token T_ref\n%token T_return\n%token T_then\n%token T_var\n%token T_while\n%token<string> T_id\n%token<int> T_int_const\n%token<char> T_char_const\n%token<string> T_string_literal\n%token T_eq\n%token T_lparen\n%token T_rparen\n%token T_plus\n%token T_minus\n%token T_times\n%token T_less\n%token T_more\n%token T_lbrack\n%token T_rbrack\n%token T_lbrace\n%token T_rbrace\n%token T_hash\n%token T_comma\n%token T_semicolon\n%token T_colon\n%token T_leq\n%token T_geq\n%token T_prod\n\n%left T_or\n%left T_and\n%nonassoc T_not\n%nonassoc T_eq T_hash T_less T_more T_geq T_leq\n%left T_plus T_minus\n%left T_times T_div T_mod\n\n%start program\n%type <unit -> unit> program\n%type <unit -> Identifier.id option> func_def\n%type <unit -> unit> local_def_list\n%type <unit -> Identifier.id option> header\n%type <unit -> param list> semi_fpar_def_list\n%type <unit -> param> fpar_def\n%type <unit -> Identifier.id list> comma_id_list\n%type <unit -> typ> data_type\n%type <unit -> int list> bracket_int_const_list\n%type <unit -> typ> ret_type\n%type <unit -> typ> fpar_type\n%type <unit -> typ> grace_type\n%type <unit -> Identifier.id option> local_def\n%type <unit -> Identifier.id option> func_decl\n%type <unit -> Identifier.id option> var_def\n%type <unit -> variable_value option> stmt\n%type <unit -> variable_value option> block\n%type <unit -> variable_value option> stmt_list\n%type <unit -> variable_value option> func_call\n%type <unit -> variable_value list> comma_expr_list\n%type <unit -> (string * int list)> l_value\n%type <unit -> variable_value> expr\n%type <unit -> bool> cond\n\n\n%%\n\nprogram: func_def T_eof { fun _ -> match $1 () with\n                                   | Some id -> ignore(callFunction id [])\n                                   | _ -> error \"not a function\"\n                        }\n\nfunc_def: header local_def_list block { fun _ -> begin \n                                          match $1 () with\n                                          | Some func_name -> \n                                              $2 ();\n                                              let func_body = $3 in\n                                              let func_entry = lookupEntry func_name LOOKUP_ALL_SCOPES true in\n                                              (match func_entry.entry_info with\n                                              | ENTRY_function func_info -> func_info.function_body <- func_body; Some func_name\n                                              | _ -> Some func_name)\n                                          | None -> error \"not a function\"; None\n                                        end\n                                      }\n\nlocal_def_list: /* nothing */            { fun _ -> () }\n              | local_def local_def_list { fun _ -> begin ignore($1 ()); $2 () end }\n\nheader: T_fun T_id T_lparen fpar_def semi_fpar_def_list T_rparen T_colon ret_type { fun _ -> let id = (id_make $2) in\n                                                                                             let params = $4 () :: $5 () in\n                                                                                             let return_type = $8 () in \n                                                                                             registerHeader id params return_type;\n                                                                                             Some id\n                                                                                  }\n      | T_fun T_id T_lparen T_rparen T_colon ret_type                             { fun _ -> let id = (id_make $2) in\n                                                                                             let params = [] in\n                                                                                             let return_type = $6 () in \n                                                                                             registerHeader id params return_type;\n                                                                                             Some id\n                                                                                  } \n\nsemi_fpar_def_list: /* nothing */                           { fun _ -> [] }\n                  | T_semicolon fpar_def semi_fpar_def_list { fun _ -> $2 () :: $3 () }\n\nfpar_def: T_ref T_id comma_id_list T_colon fpar_type { fun _ -> let params = (id_make $2) :: $3 () in\n                                                                let param_type = $5 () in\n                                                                { id = params; mode = PASS_BY_REFERENCE ; param_type = param_type }\n                                                     }\n        | T_id comma_id_list T_colon fpar_type       { fun _ -> let params = (id_make $1) :: $2 () in\n                                                                let param_type = $4 () in\n                                                                { id = params; mode = PASS_BY_VALUE ; param_type = param_type }\n                                                     }\n\ncomma_id_list: /* nothing */              { fun _ -> [] }\n             | T_comma T_id comma_id_list { fun _ -> (id_make $2) :: $3 () }\n\ndata_type: T_int  { fun _ -> TYPE_int }\n         | T_char { fun _ -> TYPE_char }\n\nbracket_int_const_list: /* nothing */                                        { fun _ -> [] }\n                      | T_lbrack T_int_const T_rbrack bracket_int_const_list { fun _ -> $2 :: $4 () }\n\nret_type: data_type { fun _ -> $1 () }\n        | T_nothing { fun _ -> TYPE_proc }\n\nfpar_type: data_type T_lbrack T_rbrack bracket_int_const_list { fun _ -> let base_type = $1 () in\n                                                                         let dimensions = max_int :: $4 () in\n                                                                         match dimensions with\n                                                                         | [] -> base_type\n                                                                         | _ -> TYPE_array (base_type, dimensions)\n                                                              } \n         | data_type bracket_int_const_list                   { fun _ -> let base_type = $1 () in\n                                                                         let dimensions = $2 () in\n                                                                         match dimensions with\n                                                                         | [] -> base_type\n                                                                         | _ -> TYPE_array (base_type, dimensions)\n                                                              }\n\ngrace_type: data_type bracket_int_const_list { fun _ -> let base_type = $1 () in\n                                                        let dimensions = $2 () in\n                                                        match dimensions with\n                                                        | [] -> base_type\n                                                        | _ -> TYPE_array (base_type, dimensions)\n                                             }\n\nlocal_def: func_def  { $1 }\n         | func_decl { $1 }\n         | var_def   { $1 }\n\nfunc_decl: header T_semicolon { $1 }\n\nvar_def: T_var T_id comma_id_list T_colon grace_type T_semicolon { fun _ -> let vars = (id_make $2) :: $3 () in\n                                                                            let var_type = $5 () in\n                                                                            print_grace_type var_type;\n                                                                            List.iter ( fun var -> ignore(newVariable var var_type true) ) vars; None\n                                                                 }\n\nstmt: T_semicolon                       { fun _ -> None }\n    | l_value T_prod expr T_semicolon   { fun _ -> let (id,l) = $1 () in\n                                                   let value = $3 () in\n                                                   assignToVariable (id_make id) value;\n                                                   None\n                                        }\n    | block                             { $1 }\n    | func_call T_semicolon             { $1 }\n    | T_if cond T_then stmt             { fun _ -> if $2 () then $4 () else None }\n    | T_if cond T_then stmt T_else stmt { fun _ -> if $2 () then $4 () else $6 () }\n    | T_while cond T_do stmt            { fun _ -> while $2 () do ignore($4 ()) done; None }\n    | T_return T_semicolon              { fun _ -> None }\n    | T_return expr T_semicolon         { fun _ -> Some($2 ()) }\n\n\nblock: T_lbrace stmt_list T_rbrace { $2 }\n\nstmt_list: /* nothing */  { fun _ -> None }\n         | stmt stmt_list { fun _ -> let result = $1 () in\n                                     match result with\n                                     | Some _ as returnValue -> returnValue\n                                     | None -> $2 ()\n      }\n\nfunc_call: T_id T_lparen T_rparen                      { fun _ -> let func_name = $1 in\n                                                                  match func_name with \n                                                                  | \"writeInteger\" -> print_string \"WriteInteger\"; None\n                                                                  | \"writeChar\"    -> print_string \"WriteChar\"; None\n                                                                  | \"writeString\"  -> print_string \"WriteString\"; None\n                                                                  | \"readInteger\"  -> print_string \"ReadInteger\"; None\n                                                                  | \"readChar\"     -> print_string \"ReadChar\"; None\n                                                                  | \"readString\"   -> print_string \"ReadString\"; None\n                                                                  | _ -> let func_entry = lookupEntry (id_make func_name) LOOKUP_ALL_SCOPES true in\n                                                                         (match func_entry.entry_info with\n                                                                         | ENTRY_function func_info ->\n                                                                           if List.length func_info.function_paramlist = 0 then\n                                                                             callFunction (id_make func_name) []\n                                                                           else (error \"Incorrect number of arguments for function %a\" pretty_id (id_make func_name); None)\n                                                                         | _ -> (error \"%a is not a function\" pretty_id (id_make func_name); None))\n                                                       }\n         | T_id T_lparen expr comma_expr_list T_rparen { fun _ -> let func_name = $1 in\n                                                                  let args = $3 () :: $4 () in\n                                                                  match func_name with \n                                                                  | \"writeInteger\" -> print_string \"WriteInteger\"; None\n                                                                  | \"writeChar\"    -> print_string \"WriteChar\"; None\n                                                                  | \"writeString\"  -> print_string \"WriteString\"; None\n                                                                  | \"readInteger\"  -> print_string \"ReadInteger\"; None\n                                                                  | \"readChar\"     -> print_string \"ReadChar\"; None\n                                                                  | \"readString\"   -> print_string \"ReadString\"; None\n                                                                  | _ -> let func_entry = lookupEntry (id_make func_name) LOOKUP_ALL_SCOPES true in\n                                                                         (match func_entry.entry_info with\n                                                                         | ENTRY_function func_info ->\n                                                                           if List.length func_info.function_paramlist = List.length args then\n                                                                           callFunction (id_make func_name) args\n                                                                         else\n                                                                           (error \"Incorrect number of arguments for function %a\" pretty_id (id_make func_name); None)\n                                                                         | _ -> (error \"%a is not a function\" pretty_id (id_make func_name); None))\n                                                       }\n\n\ncomma_expr_list: /* nothing */                { fun _ -> [] }\n               | T_comma expr comma_expr_list { fun _ -> $2 () :: $3 () }\n\nl_value: T_id                           { fun _ -> ($1,[]) }\n       | T_string_literal               { fun _ -> ($1,[]) }\n       | l_value T_lbrack expr T_rbrack { fun _ -> let (value, l) = $1 () in\n                                                   match $3 () with \n                                                   | IntValue exp -> (value, exp :: l)\n                                                   | _ -> error \"not an integer\"; (value, [])\n                                        }\n\n\nexpr: T_int_const            { fun _ -> IntValue $1 }\n    | T_char_const           { fun _ -> CharValue $1 }\n    | l_value                { fun _ -> let (value , l) = $1 () in\n                                        MultiArray (createArray l)\n                             }\n    | T_lparen expr T_rparen { $2 }\n    | func_call              { fun _ -> match $1 () with\n                                        | Some value -> value\n                                        | None -> Unit\n                             }\n    | T_plus expr            { fun _ -> match $2 () with \n                                        | IntValue num -> IntValue num\n                                        | _ -> error \"not an integer; +\"; Unit\n                             }\n    | T_minus expr           { fun _ -> match $2 () with \n                                        | IntValue num -> IntValue (- num)\n                                        | _ -> error \"not an integer; -\"; Unit\n                             }    \n    | expr T_plus expr       { fun _ -> match ($1 (), $3 ()) with\n                                        | (IntValue a, IntValue b) -> IntValue (a + b)\n                                        | _ -> error \"not an integer; plus\"; Unit\n                             }\n    | expr T_minus expr      { fun _ -> let val1 = $1 () in\n                                        let val2 = $3 () in\n                                        print_variable_value val1;\n                                        print_variable_value val2;\n                                        match (val1, val2) with\n                                        | (IntValue a, IntValue b) -> IntValue (a - b)\n                                        | (c, d) -> error \"not an integer; minus\"; Unit\n                             }\n    | expr T_times expr      { fun _ -> match ($1 (), $3 ()) with\n                                        | (IntValue a, IntValue b) -> IntValue (a * b)\n                                        | _ -> error \"not an integer; times\"; Unit\n                             }\n    | expr T_div expr        { fun _ -> match ($1 (), $3 ()) with\n                                        | (IntValue a, IntValue b) -> IntValue (a / b)\n                                        | _ -> error \"not an integer; div\"; Unit\n                             }\n    | expr T_mod expr        { fun _ -> match ($1 (), $3 ()) with\n                                        | (IntValue a, IntValue b) -> IntValue (a mod b)\n                                        | _ -> error \"not an integer; mod\"; Unit\n                             }\n \ncond: T_lparen cond T_rparen { $2 }\n    | T_not cond             { fun _ -> not ($2 ()) }\n    | cond T_and cond        { fun _ -> $1 () && $3 () }\n    | cond T_or cond         { fun _ -> $1 () || $3 () }\n    | expr T_eq expr         { fun _ -> $1 () = $3 () }\n    | expr T_hash expr       { fun _ -> $1 () <> $3 () }\n    | expr T_less expr       { fun _ -> $1 () < $3 () }\n    | expr T_more expr       { fun _ -> $1 () > $3 () }\n    | expr T_leq expr        { fun _ -> $1 () <= $3 () }\n    | expr T_geq expr        { fun _ -> $1 () >= $3 () }\n"}}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/tsimiho/Desktop/NTUA/ECE/Semester8/%CE%9C%CE%B5%CF%84%CE%B1%CE%B3%CE%BB%CF%89%CF%84%CF%84%CE%B9%CF%83%CF%84%CE%AD%CF%82/compiler/Parser.mly","version":2},"contentChanges":[{"text":"%{\n  open Symbol\n  open Types\n  open Identifier\n  open Error\n  open Narray\n\n  initSymbolTable 1000;\n\n  type param = { \n    id: Identifier.id list; \n    mode: pass_mode; \n    param_type: typ \n  }\n\n  and param_mode = PASS_BY_VALUE | PASS_BY_REFERENCE\n\n  let registerHeader id params return_type = \n    let fun_entry = newFunction id true in\n    (* openScope(); *)\n    List.iter ( fun p -> \n                  List.iter ( fun single_id -> \n                                ignore (newParameter single_id p.param_type p.mode fun_entry true) \n                            ) p.id\n              ) params;\n    match fun_entry.entry_info with\n    | ENTRY_function func_info ->\n        func_info.function_result <- return_type;\n    | _ -> error \"Expected a function entry %a\" pretty_id id;\n    endFunctionHeader fun_entry return_type\n\n  let callFunction id args =\n    let func_entry = lookupEntry id LOOKUP_ALL_SCOPES true in\n    match func_entry.entry_info with\n    | ENTRY_function inf -> if inf.function_isForward then\n                              let rec linkParams func_params func_args = \n                                match func_params, func_args with\n                                | fp::fps, fa::fas -> if fp.\n                                | [], [] -> inf.function_body () \n                                | _, _ -> error \"Function %a is called with the worng number of parameters\" pretty_id id; None\n                            else error \"%a has not been implemented\" pretty_id id; None\n    | _ -> error \"%a is not a function\" pretty_id id; None\n\n\n  let print_variable_value value =\n    match value with\n    | IntValue i -> Printf.printf \"IntValue: %d\\n\" i\n    | CharValue c -> Printf.printf \"CharValue: '%c'\\n\" c\n    | BoolValue b -> Printf.printf \"BoolValue: %b\\n\" b\n    | MultiArray arr -> Printf.printf \"MultiArray\"\n    | Unit -> Printf.printf \"Unit\\n\"\n\n  let print_grace_type t =\n    match t with\n    | TYPE_int | TYPE_char -> Printf.printf \"Not an array\\n\"\n    | _  -> Printf.printf \"array\\n\"\n        \n%}\n\n%token T_eof \n%token T_and\n%token T_char\n%token T_div\n%token T_do\n%token T_else\n%token T_fun\n%token T_if\n%token T_int \n%token T_mod\n%token T_not\n%token T_nothing\n%token T_or\n%token T_ref\n%token T_return\n%token T_then\n%token T_var\n%token T_while\n%token<string> T_id\n%token<int> T_int_const\n%token<char> T_char_const\n%token<string> T_string_literal\n%token T_eq\n%token T_lparen\n%token T_rparen\n%token T_plus\n%token T_minus\n%token T_times\n%token T_less\n%token T_more\n%token T_lbrack\n%token T_rbrack\n%token T_lbrace\n%token T_rbrace\n%token T_hash\n%token T_comma\n%token T_semicolon\n%token T_colon\n%token T_leq\n%token T_geq\n%token T_prod\n\n%left T_or\n%left T_and\n%nonassoc T_not\n%nonassoc T_eq T_hash T_less T_more T_geq T_leq\n%left T_plus T_minus\n%left T_times T_div T_mod\n\n%start program\n%type <unit -> unit> program\n%type <unit -> Identifier.id option> func_def\n%type <unit -> unit> local_def_list\n%type <unit -> Identifier.id option> header\n%type <unit -> param list> semi_fpar_def_list\n%type <unit -> param> fpar_def\n%type <unit -> Identifier.id list> comma_id_list\n%type <unit -> typ> data_type\n%type <unit -> int list> bracket_int_const_list\n%type <unit -> typ> ret_type\n%type <unit -> typ> fpar_type\n%type <unit -> typ> grace_type\n%type <unit -> Identifier.id option> local_def\n%type <unit -> Identifier.id option> func_decl\n%type <unit -> Identifier.id option> var_def\n%type <unit -> variable_value option> stmt\n%type <unit -> variable_value option> block\n%type <unit -> variable_value option> stmt_list\n%type <unit -> variable_value option> func_call\n%type <unit -> variable_value list> comma_expr_list\n%type <unit -> (string * int list)> l_value\n%type <unit -> variable_value> expr\n%type <unit -> bool> cond\n\n\n%%\n\nprogram: func_def T_eof { fun _ -> match $1 () with\n                                   | Some id -> ignore(callFunction id [])\n                                   | _ -> error \"not a function\"\n                        }\n\nfunc_def: header local_def_list block { fun _ -> begin \n                                          match $1 () with\n                                          | Some func_name -> \n                                              $2 ();\n                                              let func_body = $3 in\n                                              let func_entry = lookupEntry func_name LOOKUP_ALL_SCOPES true in\n                                              (match func_entry.entry_info with\n                                              | ENTRY_function func_info -> func_info.function_body <- func_body; Some func_name\n                                              | _ -> Some func_name)\n                                          | None -> error \"not a function\"; None\n                                        end\n                                      }\n\nlocal_def_list: /* nothing */            { fun _ -> () }\n              | local_def local_def_list { fun _ -> begin ignore($1 ()); $2 () end }\n\nheader: T_fun T_id T_lparen fpar_def semi_fpar_def_list T_rparen T_colon ret_type { fun _ -> let id = (id_make $2) in\n                                                                                             let params = $4 () :: $5 () in\n                                                                                             let return_type = $8 () in \n                                                                                             registerHeader id params return_type;\n                                                                                             Some id\n                                                                                  }\n      | T_fun T_id T_lparen T_rparen T_colon ret_type                             { fun _ -> let id = (id_make $2) in\n                                                                                             let params = [] in\n                                                                                             let return_type = $6 () in \n                                                                                             registerHeader id params return_type;\n                                                                                             Some id\n                                                                                  } \n\nsemi_fpar_def_list: /* nothing */                           { fun _ -> [] }\n                  | T_semicolon fpar_def semi_fpar_def_list { fun _ -> $2 () :: $3 () }\n\nfpar_def: T_ref T_id comma_id_list T_colon fpar_type { fun _ -> let params = (id_make $2) :: $3 () in\n                                                                let param_type = $5 () in\n                                                                { id = params; mode = PASS_BY_REFERENCE ; param_type = param_type }\n                                                     }\n        | T_id comma_id_list T_colon fpar_type       { fun _ -> let params = (id_make $1) :: $2 () in\n                                                                let param_type = $4 () in\n                                                                { id = params; mode = PASS_BY_VALUE ; param_type = param_type }\n                                                     }\n\ncomma_id_list: /* nothing */              { fun _ -> [] }\n             | T_comma T_id comma_id_list { fun _ -> (id_make $2) :: $3 () }\n\ndata_type: T_int  { fun _ -> TYPE_int }\n         | T_char { fun _ -> TYPE_char }\n\nbracket_int_const_list: /* nothing */                                        { fun _ -> [] }\n                      | T_lbrack T_int_const T_rbrack bracket_int_const_list { fun _ -> $2 :: $4 () }\n\nret_type: data_type { fun _ -> $1 () }\n        | T_nothing { fun _ -> TYPE_proc }\n\nfpar_type: data_type T_lbrack T_rbrack bracket_int_const_list { fun _ -> let base_type = $1 () in\n                                                                         let dimensions = max_int :: $4 () in\n                                                                         match dimensions with\n                                                                         | [] -> base_type\n                                                                         | _ -> TYPE_array (base_type, dimensions)\n                                                              } \n         | data_type bracket_int_const_list                   { fun _ -> let base_type = $1 () in\n                                                                         let dimensions = $2 () in\n                                                                         match dimensions with\n                                                                         | [] -> base_type\n                                                                         | _ -> TYPE_array (base_type, dimensions)\n                                                              }\n\ngrace_type: data_type bracket_int_const_list { fun _ -> let base_type = $1 () in\n                                                        let dimensions = $2 () in\n                                                        match dimensions with\n                                                        | [] -> base_type\n                                                        | _ -> TYPE_array (base_type, dimensions)\n                                             }\n\nlocal_def: func_def  { $1 }\n         | func_decl { $1 }\n         | var_def   { $1 }\n\nfunc_decl: header T_semicolon { $1 }\n\nvar_def: T_var T_id comma_id_list T_colon grace_type T_semicolon { fun _ -> let vars = (id_make $2) :: $3 () in\n                                                                            let var_type = $5 () in\n                                                                            print_grace_type var_type;\n                                                                            List.iter ( fun var -> ignore(newVariable var var_type true) ) vars; None\n                                                                 }\n\nstmt: T_semicolon                       { fun _ -> None }\n    | l_value T_prod expr T_semicolon   { fun _ -> let (id,l) = $1 () in\n                                                   let value = $3 () in\n                                                   assignToVariable (id_make id) value;\n                                                   None\n                                        }\n    | block                             { $1 }\n    | func_call T_semicolon             { $1 }\n    | T_if cond T_then stmt             { fun _ -> if $2 () then $4 () else None }\n    | T_if cond T_then stmt T_else stmt { fun _ -> if $2 () then $4 () else $6 () }\n    | T_while cond T_do stmt            { fun _ -> while $2 () do ignore($4 ()) done; None }\n    | T_return T_semicolon              { fun _ -> None }\n    | T_return expr T_semicolon         { fun _ -> Some($2 ()) }\n\n\nblock: T_lbrace stmt_list T_rbrace { $2 }\n\nstmt_list: /* nothing */  { fun _ -> None }\n         | stmt stmt_list { fun _ -> let result = $1 () in\n                                     match result with\n                                     | Some _ as returnValue -> returnValue\n                                     | None -> $2 ()\n      }\n\nfunc_call: T_id T_lparen T_rparen                      { fun _ -> let func_name = $1 in\n                                                                  match func_name with \n                                                                  | \"writeInteger\" -> print_string \"WriteInteger\"; None\n                                                                  | \"writeChar\"    -> print_string \"WriteChar\"; None\n                                                                  | \"writeString\"  -> print_string \"WriteString\"; None\n                                                                  | \"readInteger\"  -> print_string \"ReadInteger\"; None\n                                                                  | \"readChar\"     -> print_string \"ReadChar\"; None\n                                                                  | \"readString\"   -> print_string \"ReadString\"; None\n                                                                  | _ -> let func_entry = lookupEntry (id_make func_name) LOOKUP_ALL_SCOPES true in\n                                                                         (match func_entry.entry_info with\n                                                                         | ENTRY_function func_info ->\n                                                                           if List.length func_info.function_paramlist = 0 then\n                                                                             callFunction (id_make func_name) []\n                                                                           else (error \"Incorrect number of arguments for function %a\" pretty_id (id_make func_name); None)\n                                                                         | _ -> (error \"%a is not a function\" pretty_id (id_make func_name); None))\n                                                       }\n         | T_id T_lparen expr comma_expr_list T_rparen { fun _ -> let func_name = $1 in\n                                                                  let args = $3 () :: $4 () in\n                                                                  match func_name with \n                                                                  | \"writeInteger\" -> print_string \"WriteInteger\"; None\n                                                                  | \"writeChar\"    -> print_string \"WriteChar\"; None\n                                                                  | \"writeString\"  -> print_string \"WriteString\"; None\n                                                                  | \"readInteger\"  -> print_string \"ReadInteger\"; None\n                                                                  | \"readChar\"     -> print_string \"ReadChar\"; None\n                                                                  | \"readString\"   -> print_string \"ReadString\"; None\n                                                                  | _ -> let func_entry = lookupEntry (id_make func_name) LOOKUP_ALL_SCOPES true in\n                                                                         (match func_entry.entry_info with\n                                                                         | ENTRY_function func_info ->\n                                                                           if List.length func_info.function_paramlist = List.length args then\n                                                                           callFunction (id_make func_name) args\n                                                                         else\n                                                                           (error \"Incorrect number of arguments for function %a\" pretty_id (id_make func_name); None)\n                                                                         | _ -> (error \"%a is not a function\" pretty_id (id_make func_name); None))\n                                                       }\n\n\ncomma_expr_list: /* nothing */                { fun _ -> [] }\n               | T_comma expr comma_expr_list { fun _ -> $2 () :: $3 () }\n\nl_value: T_id                           { fun _ -> ($1,[]) }\n       | T_string_literal               { fun _ -> ($1,[]) }\n       | l_value T_lbrack expr T_rbrack { fun _ -> let (value, l) = $1 () in\n                                                   match $3 () with \n                                                   | IntValue exp -> (value, exp :: l)\n                                                   | _ -> error \"not an integer\"; (value, [])\n                                        }\n\n\nexpr: T_int_const            { fun _ -> IntValue $1 }\n    | T_char_const           { fun _ -> CharValue $1 }\n    | l_value                { fun _ -> let (value , l) = $1 () in\n                                        MultiArray (createArray l)\n                             }\n    | T_lparen expr T_rparen { $2 }\n    | func_call              { fun _ -> match $1 () with\n                                        | Some value -> value\n                                        | None -> Unit\n                             }\n    | T_plus expr            { fun _ -> match $2 () with \n                                        | IntValue num -> IntValue num\n                                        | _ -> error \"not an integer; +\"; Unit\n                             }\n    | T_minus expr           { fun _ -> match $2 () with \n                                        | IntValue num -> IntValue (- num)\n                                        | _ -> error \"not an integer; -\"; Unit\n                             }    \n    | expr T_plus expr       { fun _ -> match ($1 (), $3 ()) with\n                                        | (IntValue a, IntValue b) -> IntValue (a + b)\n                                        | _ -> error \"not an integer; plus\"; Unit\n                             }\n    | expr T_minus expr      { fun _ -> let val1 = $1 () in\n                                        let val2 = $3 () in\n                                        print_variable_value val1;\n                                        print_variable_value val2;\n                                        match (val1, val2) with\n                                        | (IntValue a, IntValue b) -> IntValue (a - b)\n                                        | (c, d) -> error \"not an integer; minus\"; Unit\n                             }\n    | expr T_times expr      { fun _ -> match ($1 (), $3 ()) with\n                                        | (IntValue a, IntValue b) -> IntValue (a * b)\n                                        | _ -> error \"not an integer; times\"; Unit\n                             }\n    | expr T_div expr        { fun _ -> match ($1 (), $3 ()) with\n                                        | (IntValue a, IntValue b) -> IntValue (a / b)\n                                        | _ -> error \"not an integer; div\"; Unit\n                             }\n    | expr T_mod expr        { fun _ -> match ($1 (), $3 ()) with\n                                        | (IntValue a, IntValue b) -> IntValue (a mod b)\n                                        | _ -> error \"not an integer; mod\"; Unit\n                             }\n \ncond: T_lparen cond T_rparen { $2 }\n    | T_not cond             { fun _ -> not ($2 ()) }\n    | cond T_and cond        { fun _ -> $1 () && $3 () }\n    | cond T_or cond         { fun _ -> $1 () || $3 () }\n    | expr T_eq expr         { fun _ -> $1 () = $3 () }\n    | expr T_hash expr       { fun _ -> $1 () <> $3 () }\n    | expr T_less expr       { fun _ -> $1 () < $3 () }\n    | expr T_more expr       { fun _ -> $1 () > $3 () }\n    | expr T_leq expr        { fun _ -> $1 () <= $3 () }\n    | expr T_geq expr        { fun _ -> $1 () >= $3 () }\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/tsimiho/Desktop/NTUA/ECE/Semester8/%CE%9C%CE%B5%CF%84%CE%B1%CE%B3%CE%BB%CF%89%CF%84%CF%84%CE%B9%CF%83%CF%84%CE%AD%CF%82/compiler/Parser.mly","version":3},"contentChanges":[{"text":"%{\n  open Symbol\n  open Types\n  open Identifier\n  open Error\n  open Narray\n\n  initSymbolTable 1000;\n\n  type param = { \n    id: Identifier.id list; \n    mode: pass_mode; \n    param_type: typ \n  }\n\n  and param_mode = PASS_BY_VALUE | PASS_BY_REFERENCE\n\n  let registerHeader id params return_type = \n    let fun_entry = newFunction id true in\n    (* openScope(); *)\n    List.iter ( fun p -> \n                  List.iter ( fun single_id -> \n                                ignore (newParameter single_id p.param_type p.mode fun_entry true) \n                            ) p.id\n              ) params;\n    match fun_entry.entry_info with\n    | ENTRY_function func_info ->\n        func_info.function_result <- return_type;\n    | _ -> error \"Expected a function entry %a\" pretty_id id;\n    endFunctionHeader fun_entry return_type\n\n  let callFunction id args =\n    let func_entry = lookupEntry id LOOKUP_ALL_SCOPES true in\n    match func_entry.entry_info with\n    | ENTRY_function inf -> if inf.function_isForward then\n                              let rec linkParams func_params func_args = \n                                match func_params, func_args with\n                                | fp::fps, fa::fas -> if fp.\n                                | [], [] -> inf.function_body () \n                                | _, _ -> error \"Function %a is called with the worng number of parameters\" pretty_id id; None\n                            else error \"%a has not been implemented\" pretty_id id; None\n    | _ -> error \"%a is not a function\" pretty_id id; None\n\n\n  let print_variable_value value =\n    match value with\n    | IntValue i -> Printf.printf \"IntValue: %d\\n\" i\n    | CharValue c -> Printf.printf \"CharValue: '%c'\\n\" c\n    | BoolValue b -> Printf.printf \"BoolValue: %b\\n\" b\n    | MultiArray arr -> Printf.printf \"MultiArray\"\n    | Unit -> Printf.printf \"Unit\\n\"\n\n  let print_grace_type t =\n    match t with\n    | TYPE_int | TYPE_char -> Printf.printf \"Not an array\\n\"\n    | _  -> Printf.printf \"array\\n\"\n        \n%}\n\n%token T_eof \n%token T_and\n%token T_char\n%token T_div\n%token T_do\n%token T_else\n%token T_fun\n%token T_if\n%token T_int \n%token T_mod\n%token T_not\n%token T_nothing\n%token T_or\n%token T_ref\n%token T_return\n%token T_then\n%token T_var\n%token T_while\n%token<string> T_id\n%token<int> T_int_const\n%token<char> T_char_const\n%token<string> T_string_literal\n%token T_eq\n%token T_lparen\n%token T_rparen\n%token T_plus\n%token T_minus\n%token T_times\n%token T_less\n%token T_more\n%token T_lbrack\n%token T_rbrack\n%token T_lbrace\n%token T_rbrace\n%token T_hash\n%token T_comma\n%token T_semicolon\n%token T_colon\n%token T_leq\n%token T_geq\n%token T_prod\n\n%left T_or\n%left T_and\n%nonassoc T_not\n%nonassoc T_eq T_hash T_less T_more T_geq T_leq\n%left T_plus T_minus\n%left T_times T_div T_mod\n\n%start program\n%type <unit -> unit> program\n%type <unit -> Identifier.id option> func_def\n%type <unit -> unit> local_def_list\n%type <unit -> Identifier.id option> header\n%type <unit -> param list> semi_fpar_def_list\n%type <unit -> param> fpar_def\n%type <unit -> Identifier.id list> comma_id_list\n%type <unit -> typ> data_type\n%type <unit -> int list> bracket_int_const_list\n%type <unit -> typ> ret_type\n%type <unit -> typ> fpar_type\n%type <unit -> typ> grace_type\n%type <unit -> Identifier.id option> local_def\n%type <unit -> Identifier.id option> func_decl\n%type <unit -> Identifier.id option> var_def\n%type <unit -> variable_value option> stmt\n%type <unit -> variable_value option> block\n%type <unit -> variable_value option> stmt_list\n%type <unit -> variable_value option> func_call\n%type <unit -> variable_value list> comma_expr_list\n%type <unit -> (string * int list)> l_value\n%type <unit -> variable_value> expr\n%type <unit -> bool> cond\n\n\n%%\n\nprogram: func_def T_eof { fun _ -> match $1 () with\n                                   | Some id -> ignore(callFunction id [])\n                                   | _ -> error \"not a function\"\n                        }\n\nfunc_def: header local_def_list block { fun _ -> begin \n                                          match $1 () with\n                                          | Some func_name -> \n                                              $2 ();\n                                              let func_body = $3 in\n                                              let func_entry = lookupEntry func_name LOOKUP_ALL_SCOPES true in\n                                              (match func_entry.entry_info with\n                                              | ENTRY_function func_info -> func_info.function_body <- func_body; Some func_name\n                                              | _ -> Some func_name)\n                                          | None -> error \"not a function\"; None\n                                        end\n                                      }\n\nlocal_def_list: /* nothing */            { fun _ -> () }\n              | local_def local_def_list { fun _ -> begin ignore($1 ()); $2 () end }\n\nheader: T_fun T_id T_lparen fpar_def semi_fpar_def_list T_rparen T_colon ret_type { fun _ -> let id = (id_make $2) in\n                                                                                             let params = $4 () :: $5 () in\n                                                                                             let return_type = $8 () in \n                                                                                             registerHeader id params return_type;\n                                                                                             Some id\n                                                                                  }\n      | T_fun T_id T_lparen T_rparen T_colon ret_type                             { fun _ -> let id = (id_make $2) in\n                                                                                             let params = [] in\n                                                                                             let return_type = $6 () in \n                                                                                             registerHeader id params return_type;\n                                                                                             Some id\n                                                                                  } \n\nsemi_fpar_def_list: /* nothing */                           { fun _ -> [] }\n                  | T_semicolon fpar_def semi_fpar_def_list { fun _ -> $2 () :: $3 () }\n\nfpar_def: T_ref T_id comma_id_list T_colon fpar_type { fun _ -> let params = (id_make $2) :: $3 () in\n                                                                let param_type = $5 () in\n                                                                { id = params; mode = PASS_BY_REFERENCE ; param_type = param_type }\n                                                     }\n        | T_id comma_id_list T_colon fpar_type       { fun _ -> let params = (id_make $1) :: $2 () in\n                                                                let param_type = $4 () in\n                                                                { id = params; mode = PASS_BY_VALUE ; param_type = param_type }\n                                                     }\n\ncomma_id_list: /* nothing */              { fun _ -> [] }\n             | T_comma T_id comma_id_list { fun _ -> (id_make $2) :: $3 () }\n\ndata_type: T_int  { fun _ -> TYPE_int }\n         | T_char { fun _ -> TYPE_char }\n\nbracket_int_const_list: /* nothing */                                        { fun _ -> [] }\n                      | T_lbrack T_int_const T_rbrack bracket_int_const_list { fun _ -> $2 :: $4 () }\n\nret_type: data_type { fun _ -> $1 () }\n        | T_nothing { fun _ -> TYPE_proc }\n\nfpar_type: data_type T_lbrack T_rbrack bracket_int_const_list { fun _ -> let base_type = $1 () in\n                                                                         let dimensions = max_int :: $4 () in\n                                                                         match dimensions with\n                                                                         | [] -> base_type\n                                                                         | _ -> TYPE_array (base_type, dimensions)\n                                                              } \n         | data_type bracket_int_const_list                   { fun _ -> let base_type = $1 () in\n                                                                         let dimensions = $2 () in\n                                                                         match dimensions with\n                                                                         | [] -> base_type\n                                                                         | _ -> TYPE_array (base_type, dimensions)\n                                                              }\n\ngrace_type: data_type bracket_int_const_list { fun _ -> let base_type = $1 () in\n                                                        let dimensions = $2 () in\n                                                        match dimensions with\n                                                        | [] -> base_type\n                                                        | _ -> TYPE_array (base_type, dimensions)\n                                             }\n\nlocal_def: func_def  { $1 }\n         | func_decl { $1 }\n         | var_def   { $1 }\n\nfunc_decl: header T_semicolon { $1 }\n\nvar_def: T_var T_id comma_id_list T_colon grace_type T_semicolon { fun _ -> let vars = (id_make $2) :: $3 () in\n                                                                            let var_type = $5 () in\n                                                                            print_grace_type var_type;\n                                                                            List.iter ( fun var -> ignore(newVariable var var_type true) ) vars; None\n                                                                 }\n\nstmt: T_semicolon                       { fun _ -> None }\n    | l_value T_prod expr T_semicolon   { fun _ -> let (id,l) = $1 () in\n                                                   let value = $3 () in\n                                                   assignToVariable (id_make id) value;\n                                                   None\n                                        }\n    | block                             { $1 }\n    | func_call T_semicolon             { $1 }\n    | T_if cond T_then stmt             { fun _ -> if $2 () then $4 () else None }\n    | T_if cond T_then stmt T_else stmt { fun _ -> if $2 () then $4 () else $6 () }\n    | T_while cond T_do stmt            { fun _ -> while $2 () do ignore($4 ()) done; None }\n    | T_return T_semicolon              { fun _ -> None }\n    | T_return expr T_semicolon         { fun _ -> Some($2 ()) }\n\n\nblock: T_lbrace stmt_list T_rbrace { $2 }\n\nstmt_list: /* nothing */  { fun _ -> None }\n         | stmt stmt_list { fun _ -> let result = $1 () in\n                                     match result with\n                                     | Some _ as returnValue -> returnValue\n                                     | None -> $2 ()\n      }\n\nfunc_call: T_id T_lparen T_rparen                      { fun _ -> let func_name = $1 in\n                                                                  match func_name with \n                                                                  | \"writeInteger\" -> print_string \"WriteInteger\"; None\n                                                                  | \"writeChar\"    -> print_string \"WriteChar\"; None\n                                                                  | \"writeString\"  -> print_string \"WriteString\"; None\n                                                                  | \"readInteger\"  -> print_string \"ReadInteger\"; None\n                                                                  | \"readChar\"     -> print_string \"ReadChar\"; None\n                                                                  | \"readString\"   -> print_string \"ReadString\"; None\n                                                                  | _ -> let func_entry = lookupEntry (id_make func_name) LOOKUP_ALL_SCOPES true in\n                                                                         (match func_entry.entry_info with\n                                                                         | ENTRY_function func_info ->\n                                                                           if List.length func_info.function_paramlist = 0 then\n                                                                             callFunction (id_make func_name) []\n                                                                           else (error \"Incorrect number of arguments for function %a\" pretty_id (id_make func_name); None)\n                                                                         | _ -> (error \"%a is not a function\" pretty_id (id_make func_name); None))\n                                                       }\n         | T_id T_lparen expr comma_expr_list T_rparen { fun _ -> let func_name = $1 in\n                                                                  let args = $3 () :: $4 () in\n                                                                  match func_name with \n                                                                  | \"writeInteger\" -> print_string \"WriteInteger\"; None\n                                                                  | \"writeChar\"    -> print_string \"WriteChar\"; None\n                                                                  | \"writeString\"  -> print_string \"WriteString\"; None\n                                                                  | \"readInteger\"  -> print_string \"ReadInteger\"; None\n                                                                  | \"readChar\"     -> print_string \"ReadChar\"; None\n                                                                  | \"readString\"   -> print_string \"ReadString\"; None\n                                                                  | _ -> let func_entry = lookupEntry (id_make func_name) LOOKUP_ALL_SCOPES true in\n                                                                         (match func_entry.entry_info with\n                                                                         | ENTRY_function func_info ->\n                                                                           if List.length func_info.function_paramlist = List.length args then\n                                                                           callFunction (id_make func_name) args\n                                                                         else\n                                                                           (error \"Incorrect number of arguments for function %a\" pretty_id (id_make func_name); None)\n                                                                         | _ -> (error \"%a is not a function\" pretty_id (id_make func_name); None))\n                                                       }\n\n\ncomma_expr_list: /* nothing */                { fun _ -> [] }\n               | T_comma expr comma_expr_list { fun _ -> $2 () :: $3 () }\n\nl_value: T_id                           { fun _ -> ($1,[]) }\n       | T_string_literal               { fun _ -> ($1,[]) }\n       | l_value T_lbrack expr T_rbrack { fun _ -> let (value, l) = $1 () in\n                                                   match $3 () with \n                                                   | IntValue exp -> (value, exp :: l)\n                                                   | _ -> error \"not an integer\"; (value, [])\n                                        }\n\n\nexpr: T_int_const            { fun _ -> IntValue $1 }\n    | T_char_const           { fun _ -> CharValue $1 }\n    | l_value                { fun _ -> let (value , l) = $1 () in\n                                        MultiArray (createArray l)\n                             }\n    | T_lparen expr T_rparen { $2 }\n    | func_call              { fun _ -> match $1 () with\n                                        | Some value -> value\n                                        | None -> Unit\n                             }\n    | T_plus expr            { fun _ -> match $2 () with \n                                        | IntValue num -> IntValue num\n                                        | _ -> error \"not an integer; +\"; Unit\n                             }\n    | T_minus expr           { fun _ -> match $2 () with \n                                        | IntValue num -> IntValue (- num)\n                                        | _ -> error \"not an integer; -\"; Unit\n                             }    \n    | expr T_plus expr       { fun _ -> match ($1 (), $3 ()) with\n                                        | (IntValue a, IntValue b) -> IntValue (a + b)\n                                        | _ -> error \"not an integer; plus\"; Unit\n                             }\n    | expr T_minus expr      { fun _ -> let val1 = $1 () in\n                                        let val2 = $3 () in\n                                        print_variable_value val1;\n                                        print_variable_value val2;\n                                        match (val1, val2) with\n                                        | (IntValue a, IntValue b) -> IntValue (a - b)\n                                        | (c, d) -> error \"not an integer; minus\"; Unit\n                             }\n    | expr T_times expr      { fun _ -> match ($1 (), $3 ()) with\n                                        | (IntValue a, IntValue b) -> IntValue (a * b)\n                                        | _ -> error \"not an integer; times\"; Unit\n                             }\n    | expr T_div expr        { fun _ -> match ($1 (), $3 ()) with\n                                        | (IntValue a, IntValue b) -> IntValue (a / b)\n                                        | _ -> error \"not an integer; div\"; Unit\n                             }\n    | expr T_mod expr        { fun _ -> match ($1 (), $3 ()) with\n                                        | (IntValue a, IntValue b) -> IntValue (a mod b)\n                                        | _ -> error \"not an integer; mod\"; Unit\n                             }\n \ncond: T_lparen cond T_rparen { $2 }\n    | T_not cond             { fun _ -> not ($2 ()) }\n    | cond T_and cond        { fun _ -> $1 () && $3 () }\n    | cond T_or cond         { fun _ -> $1 () || $3 () }\n    | expr T_eq expr         { fun _ -> $1 () = $3 () }\n    | expr T_hash expr       { fun _ -> $1 () <> $3 () }\n    | expr T_less expr       { fun _ -> $1 () < $3 () }\n    | expr T_more expr       { fun _ -> $1 () > $3 () }\n    | expr T_leq expr        { fun _ -> $1 () <= $3 () }\n    | expr T_geq expr        { fun _ -> $1 () >= $3 () }\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/tsimiho/Desktop/NTUA/ECE/Semester8/%CE%9C%CE%B5%CF%84%CE%B1%CE%B3%CE%BB%CF%89%CF%84%CF%84%CE%B9%CF%83%CF%84%CE%AD%CF%82/compiler/Parser.mly","version":4},"contentChanges":[{"text":"%{\n  open Symbol\n  open Types\n  open Identifier\n  open Error\n  open Narray\n\n  initSymbolTable 1000;\n\n  type param = { \n    id: Identifier.id list; \n    mode: pass_mode; \n    param_type: typ \n  }\n\n  and param_mode = PASS_BY_VALUE | PASS_BY_REFERENCE\n\n  let registerHeader id params return_type = \n    let fun_entry = newFunction id true in\n    (* openScope(); *)\n    List.iter ( fun p -> \n                  List.iter ( fun single_id -> \n                                ignore (newParameter single_id p.param_type p.mode fun_entry true) \n                            ) p.id\n              ) params;\n    match fun_entry.entry_info with\n    | ENTRY_function func_info ->\n        func_info.function_result <- return_type;\n    | _ -> error \"Expected a function entry %a\" pretty_id id;\n    endFunctionHeader fun_entry return_type\n\n  let callFunction id args =\n    let func_entry = lookupEntry id LOOKUP_ALL_SCOPES true in\n    match func_entry.entry_info with\n    | ENTRY_function inf -> if inf.function_isForward then\n                              let rec linkParams func_params func_args = \n                                match func_params, func_args with\n                                | fp::fps, fa::fas -> if fp.\n                                | [], [] -> inf.function_body () \n                                | _, _ -> error \"Function %a is called with the worng number of parameters\" pretty_id id; None\n                            else error \"%a has not been implemented\" pretty_id id; None\n    | _ -> error \"%a is not a function\" pretty_id id; None\n\n\n  let print_variable_value value =\n    match value with\n    | IntValue i -> Printf.printf \"IntValue: %d\\n\" i\n    | CharValue c -> Printf.printf \"CharValue: '%c'\\n\" c\n    | BoolValue b -> Printf.printf \"BoolValue: %b\\n\" b\n    | MultiArray arr -> Printf.printf \"MultiArray\"\n    | Unit -> Printf.printf \"Unit\\n\"\n\n  let print_grace_type t =\n    match t with\n    | TYPE_int | TYPE_char -> Printf.printf \"Not an array\\n\"\n    | _  -> Printf.printf \"array\\n\"\n        \n%}\n\n%token T_eof \n%token T_and\n%token T_char\n%token T_div\n%token T_do\n%token T_else\n%token T_fun\n%token T_if\n%token T_int \n%token T_mod\n%token T_not\n%token T_nothing\n%token T_or\n%token T_ref\n%token T_return\n%token T_then\n%token T_var\n%token T_while\n%token<string> T_id\n%token<int> T_int_const\n%token<char> T_char_const\n%token<string> T_string_literal\n%token T_eq\n%token T_lparen\n%token T_rparen\n%token T_plus\n%token T_minus\n%token T_times\n%token T_less\n%token T_more\n%token T_lbrack\n%token T_rbrack\n%token T_lbrace\n%token T_rbrace\n%token T_hash\n%token T_comma\n%token T_semicolon\n%token T_colon\n%token T_leq\n%token T_geq\n%token T_prod\n\n%left T_or\n%left T_and\n%nonassoc T_not\n%nonassoc T_eq T_hash T_less T_more T_geq T_leq\n%left T_plus T_minus\n%left T_times T_div T_mod\n\n%start program\n%type <unit -> unit> program\n%type <unit -> Identifier.id option> func_def\n%type <unit -> unit> local_def_list\n%type <unit -> Identifier.id option> header\n%type <unit -> param list> semi_fpar_def_list\n%type <unit -> param> fpar_def\n%type <unit -> Identifier.id list> comma_id_list\n%type <unit -> typ> data_type\n%type <unit -> int list> bracket_int_const_list\n%type <unit -> typ> ret_type\n%type <unit -> typ> fpar_type\n%type <unit -> typ> grace_type\n%type <unit -> Identifier.id option> local_def\n%type <unit -> Identifier.id option> func_decl\n%type <unit -> Identifier.id option> var_def\n%type <unit -> variable_value option> stmt\n%type <unit -> variable_value option> block\n%type <unit -> variable_value option> stmt_list\n%type <unit -> variable_value option> func_call\n%type <unit -> variable_value list> comma_expr_list\n%type <unit -> (string * int list)> l_value\n%type <unit -> variable_value> expr\n%type <unit -> bool> cond\n\n\n%%\n\nprogram: func_def T_eof { fun _ -> match $1 () with\n                                   | Some id -> ignore(callFunction id [])\n                                   | _ -> error \"not a function\"\n                        }\n\nfunc_def: header local_def_list block { fun _ -> begin \n                                          match $1 () with\n                                          | Some func_name -> \n                                              $2 ();\n                                              let func_body = $3 in\n                                              let func_entry = lookupEntry func_name LOOKUP_ALL_SCOPES true in\n                                              (match func_entry.entry_info with\n                                              | ENTRY_function func_info -> func_info.function_body <- func_body; Some func_name\n                                              | _ -> Some func_name)\n                                          | None -> error \"not a function\"; None\n                                        end\n                                      }\n\nlocal_def_list: /* nothing */            { fun _ -> () }\n              | local_def local_def_list { fun _ -> begin ignore($1 ()); $2 () end }\n\nheader: T_fun T_id T_lparen fpar_def semi_fpar_def_list T_rparen T_colon ret_type { fun _ -> let id = (id_make $2) in\n                                                                                             let params = $4 () :: $5 () in\n                                                                                             let return_type = $8 () in \n                                                                                             registerHeader id params return_type;\n                                                                                             Some id\n                                                                                  }\n      | T_fun T_id T_lparen T_rparen T_colon ret_type                             { fun _ -> let id = (id_make $2) in\n                                                                                             let params = [] in\n                                                                                             let return_type = $6 () in \n                                                                                             registerHeader id params return_type;\n                                                                                             Some id\n                                                                                  } \n\nsemi_fpar_def_list: /* nothing */                           { fun _ -> [] }\n                  | T_semicolon fpar_def semi_fpar_def_list { fun _ -> $2 () :: $3 () }\n\nfpar_def: T_ref T_id comma_id_list T_colon fpar_type { fun _ -> let params = (id_make $2) :: $3 () in\n                                                                let param_type = $5 () in\n                                                                { id = params; mode = PASS_BY_REFERENCE ; param_type = param_type }\n                                                     }\n        | T_id comma_id_list T_colon fpar_type       { fun _ -> let params = (id_make $1) :: $2 () in\n                                                                let param_type = $4 () in\n                                                                { id = params; mode = PASS_BY_VALUE ; param_type = param_type }\n                                                     }\n\ncomma_id_list: /* nothing */              { fun _ -> [] }\n             | T_comma T_id comma_id_list { fun _ -> (id_make $2) :: $3 () }\n\ndata_type: T_int  { fun _ -> TYPE_int }\n         | T_char { fun _ -> TYPE_char }\n\nbracket_int_const_list: /* nothing */                                        { fun _ -> [] }\n                      | T_lbrack T_int_const T_rbrack bracket_int_const_list { fun _ -> $2 :: $4 () }\n\nret_type: data_type { fun _ -> $1 () }\n        | T_nothing { fun _ -> TYPE_proc }\n\nfpar_type: data_type T_lbrack T_rbrack bracket_int_const_list { fun _ -> let base_type = $1 () in\n                                                                         let dimensions = max_int :: $4 () in\n                                                                         match dimensions with\n                                                                         | [] -> base_type\n                                                                         | _ -> TYPE_array (base_type, dimensions)\n                                                              } \n         | data_type bracket_int_const_list                   { fun _ -> let base_type = $1 () in\n                                                                         let dimensions = $2 () in\n                                                                         match dimensions with\n                                                                         | [] -> base_type\n                                                                         | _ -> TYPE_array (base_type, dimensions)\n                                                              }\n\ngrace_type: data_type bracket_int_const_list { fun _ -> let base_type = $1 () in\n                                                        let dimensions = $2 () in\n                                                        match dimensions with\n                                                        | [] -> base_type\n                                                        | _ -> TYPE_array (base_type, dimensions)\n                                             }\n\nlocal_def: func_def  { $1 }\n         | func_decl { $1 }\n         | var_def   { $1 }\n\nfunc_decl: header T_semicolon { $1 }\n\nvar_def: T_var T_id comma_id_list T_colon grace_type T_semicolon { fun _ -> let vars = (id_make $2) :: $3 () in\n                                                                            let var_type = $5 () in\n                                                                            print_grace_type var_type;\n                                                                            List.iter ( fun var -> ignore(newVariable var var_type true) ) vars; None\n                                                                 }\n\nstmt: T_semicolon                       { fun _ -> None }\n    | l_value T_prod expr T_semicolon   { fun _ -> let (id,l) = $1 () in\n                                                   let value = $3 () in\n                                                   assignToVariable (id_make id) value;\n                                                   None\n                                        }\n    | block                             { $1 }\n    | func_call T_semicolon             { $1 }\n    | T_if cond T_then stmt             { fun _ -> if $2 () then $4 () else None }\n    | T_if cond T_then stmt T_else stmt { fun _ -> if $2 () then $4 () else $6 () }\n    | T_while cond T_do stmt            { fun _ -> while $2 () do ignore($4 ()) done; None }\n    | T_return T_semicolon              { fun _ -> None }\n    | T_return expr T_semicolon         { fun _ -> Some($2 ()) }\n\n\nblock: T_lbrace stmt_list T_rbrace { $2 }\n\nstmt_list: /* nothing */  { fun _ -> None }\n         | stmt stmt_list { fun _ -> let result = $1 () in\n                                     match result with\n                                     | Some _ as returnValue -> returnValue\n                                     | None -> $2 ()\n      }\n\nfunc_call: T_id T_lparen T_rparen                      { fun _ -> let func_name = $1 in\n                                                                  match func_name with \n                                                                  | \"writeInteger\" -> print_string \"WriteInteger\"; None\n                                                                  | \"writeChar\"    -> print_string \"WriteChar\"; None\n                                                                  | \"writeString\"  -> print_string \"WriteString\"; None\n                                                                  | \"readInteger\"  -> print_string \"ReadInteger\"; None\n                                                                  | \"readChar\"     -> print_string \"ReadChar\"; None\n                                                                  | \"readString\"   -> print_string \"ReadString\"; None\n                                                                  | _ -> let func_entry = lookupEntry (id_make func_name) LOOKUP_ALL_SCOPES true in\n                                                                         (match func_entry.entry_info with\n                                                                         | ENTRY_function func_info ->\n                                                                           if List.length func_info.function_paramlist = 0 then\n                                                                             callFunction (id_make func_name) []\n                                                                           else (error \"Incorrect number of arguments for function %a\" pretty_id (id_make func_name); None)\n                                                                         | _ -> (error \"%a is not a function\" pretty_id (id_make func_name); None))\n                                                       }\n         | T_id T_lparen expr comma_expr_list T_rparen { fun _ -> let func_name = $1 in\n                                                                  let args = $3 () :: $4 () in\n                                                                  match func_name with \n                                                                  | \"writeInteger\" -> print_string \"WriteInteger\"; None\n                                                                  | \"writeChar\"    -> print_string \"WriteChar\"; None\n                                                                  | \"writeString\"  -> print_string \"WriteString\"; None\n                                                                  | \"readInteger\"  -> print_string \"ReadInteger\"; None\n                                                                  | \"readChar\"     -> print_string \"ReadChar\"; None\n                                                                  | \"readString\"   -> print_string \"ReadString\"; None\n                                                                  | _ -> let func_entry = lookupEntry (id_make func_name) LOOKUP_ALL_SCOPES true in\n                                                                         (match func_entry.entry_info with\n                                                                         | ENTRY_function func_info ->\n                                                                           if List.length func_info.function_paramlist = List.length args then\n                                                                           callFunction (id_make func_name) args\n                                                                         else\n                                                                           (error \"Incorrect number of arguments for function %a\" pretty_id (id_make func_name); None)\n                                                                         | _ -> (error \"%a is not a function\" pretty_id (id_make func_name); None))\n                                                       }\n\n\ncomma_expr_list: /* nothing */                { fun _ -> [] }\n               | T_comma expr comma_expr_list { fun _ -> $2 () :: $3 () }\n\nl_value: T_id                           { fun _ -> ($1,[]) }\n       | T_string_literal               { fun _ -> ($1,[]) }\n       | l_value T_lbrack expr T_rbrack { fun _ -> let (value, l) = $1 () in\n                                                   match $3 () with \n                                                   | IntValue exp -> (value, exp :: l)\n                                                   | _ -> error \"not an integer\"; (value, [])\n                                        }\n\n\nexpr: T_int_const            { fun _ -> IntValue $1 }\n    | T_char_const           { fun _ -> CharValue $1 }\n    | l_value                { fun _ -> let (value , l) = $1 () in\n                                        MultiArray (createArray l)\n                             }\n    | T_lparen expr T_rparen { $2 }\n    | func_call              { fun _ -> match $1 () with\n                                        | Some value -> value\n                                        | None -> Unit\n                             }\n    | T_plus expr            { fun _ -> match $2 () with \n                                        | IntValue num -> IntValue num\n                                        | _ -> error \"not an integer; +\"; Unit\n                             }\n    | T_minus expr           { fun _ -> match $2 () with \n                                        | IntValue num -> IntValue (- num)\n                                        | _ -> error \"not an integer; -\"; Unit\n                             }    \n    | expr T_plus expr       { fun _ -> match ($1 (), $3 ()) with\n                                        | (IntValue a, IntValue b) -> IntValue (a + b)\n                                        | _ -> error \"not an integer; plus\"; Unit\n                             }\n    | expr T_minus expr      { fun _ -> let val1 = $1 () in\n                                        let val2 = $3 () in\n                                        print_variable_value val1;\n                                        print_variable_value val2;\n                                        match (val1, val2) with\n                                        | (IntValue a, IntValue b) -> IntValue (a - b)\n                                        | (c, d) -> error \"not an integer; minus\"; Unit\n                             }\n    | expr T_times expr      { fun _ -> match ($1 (), $3 ()) with\n                                        | (IntValue a, IntValue b) -> IntValue (a * b)\n                                        | _ -> error \"not an integer; times\"; Unit\n                             }\n    | expr T_div expr        { fun _ -> match ($1 (), $3 ()) with\n                                        | (IntValue a, IntValue b) -> IntValue (a / b)\n                                        | _ -> error \"not an integer; div\"; Unit\n                             }\n    | expr T_mod expr        { fun _ -> match ($1 (), $3 ()) with\n                                        | (IntValue a, IntValue b) -> IntValue (a mod b)\n                                        | _ -> error \"not an integer; mod\"; Unit\n                             }\n \ncond: T_lparen cond T_rparen { $2 }\n    | T_not cond             { fun _ -> not ($2 ()) }\n    | cond T_and cond        { fun _ -> $1 () && $3 () }\n    | cond T_or cond         { fun _ -> $1 () || $3 () }\n    | expr T_eq expr         { fun _ -> $1 () = $3 () }\n    | expr T_hash expr       { fun _ -> $1 () <> $3 () }\n    | expr T_less expr       { fun _ -> $1 () < $3 () }\n    | expr T_more expr       { fun _ -> $1 () > $3 () }\n    | expr T_leq expr        { fun _ -> $1 () <= $3 () }\n    | expr T_geq expr        { fun _ -> $1 () >= $3 () }\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/tsimiho/Desktop/NTUA/ECE/Semester8/%CE%9C%CE%B5%CF%84%CE%B1%CE%B3%CE%BB%CF%89%CF%84%CF%84%CE%B9%CF%83%CF%84%CE%AD%CF%82/compiler/Parser.mly","version":5},"contentChanges":[{"text":"%{\n  open Symbol\n  open Types\n  open Identifier\n  open Error\n  open Narray\n\n  initSymbolTable 1000;\n\n  type param = { \n    id: Identifier.id list; \n    mode: pass_mode; \n    param_type: typ \n  }\n\n  and param_mode = PASS_BY_VALUE | PASS_BY_REFERENCE\n\n  let registerHeader id params return_type = \n    let fun_entry = newFunction id true in\n    (* openScope(); *)\n    List.iter ( fun p -> \n                  List.iter ( fun single_id -> \n                                ignore (newParameter single_id p.param_type p.mode fun_entry true) \n                            ) p.id\n              ) params;\n    match fun_entry.entry_info with\n    | ENTRY_function func_info ->\n        func_info.function_result <- return_type;\n    | _ -> error \"Expected a function entry %a\" pretty_id id;\n    endFunctionHeader fun_entry return_type\n\n  let callFunction id args =\n    let func_entry = lookupEntry id LOOKUP_ALL_SCOPES true in\n    match func_entry.entry_info with\n    | ENTRY_function inf -> if inf.function_isForward then\n                              let rec linkParams func_params func_args = \n                                match func_params, func_args with\n                                | fp::fps, fa::fas -> if fp.\n                                | [], [] -> inf.function_body () \n                                | _, _ -> error \"Function %a is called with the worng number of parameters\" pretty_id id; None\n                            else error \"%a has not been implemented\" pretty_id id; None\n    | _ -> error \"%a is not a function\" pretty_id id; None\n\n\n  let print_variable_value value =\n    match value with\n    | IntValue i -> Printf.printf \"IntValue: %d\\n\" i\n    | CharValue c -> Printf.printf \"CharValue: '%c'\\n\" c\n    | BoolValue b -> Printf.printf \"BoolValue: %b\\n\" b\n    | MultiArray arr -> Printf.printf \"MultiArray\"\n    | Unit -> Printf.printf \"Unit\\n\"\n\n  let print_grace_type t =\n    match t with\n    | TYPE_int | TYPE_char -> Printf.printf \"Not an array\\n\"\n    | _  -> Printf.printf \"array\\n\"\n        \n%}\n\n%token T_eof \n%token T_and\n%token T_char\n%token T_div\n%token T_do\n%token T_else\n%token T_fun\n%token T_if\n%token T_int \n%token T_mod\n%token T_not\n%token T_nothing\n%token T_or\n%token T_ref\n%token T_return\n%token T_then\n%token T_var\n%token T_while\n%token<string> T_id\n%token<int> T_int_const\n%token<char> T_char_const\n%token<string> T_string_literal\n%token T_eq\n%token T_lparen\n%token T_rparen\n%token T_plus\n%token T_minus\n%token T_times\n%token T_less\n%token T_more\n%token T_lbrack\n%token T_rbrack\n%token T_lbrace\n%token T_rbrace\n%token T_hash\n%token T_comma\n%token T_semicolon\n%token T_colon\n%token T_leq\n%token T_geq\n%token T_prod\n\n%left T_or\n%left T_and\n%nonassoc T_not\n%nonassoc T_eq T_hash T_less T_more T_geq T_leq\n%left T_plus T_minus\n%left T_times T_div T_mod\n\n%start program\n%type <unit -> unit> program\n%type <unit -> Identifier.id option> func_def\n%type <unit -> unit> local_def_list\n%type <unit -> Identifier.id option> header\n%type <unit -> param list> semi_fpar_def_list\n%type <unit -> param> fpar_def\n%type <unit -> Identifier.id list> comma_id_list\n%type <unit -> typ> data_type\n%type <unit -> int list> bracket_int_const_list\n%type <unit -> typ> ret_type\n%type <unit -> typ> fpar_type\n%type <unit -> typ> grace_type\n%type <unit -> Identifier.id option> local_def\n%type <unit -> Identifier.id option> func_decl\n%type <unit -> Identifier.id option> var_def\n%type <unit -> variable_value option> stmt\n%type <unit -> variable_value option> block\n%type <unit -> variable_value option> stmt_list\n%type <unit -> variable_value option> func_call\n%type <unit -> variable_value list> comma_expr_list\n%type <unit -> (string * int list)> l_value\n%type <unit -> variable_value> expr\n%type <unit -> bool> cond\n\n\n%%\n\nprogram: func_def T_eof { fun _ -> match $1 () with\n                                   | Some id -> ignore(callFunction id [])\n                                   | _ -> error \"not a function\"\n                        }\n\nfunc_def: header local_def_list block { fun _ -> begin \n                                          match $1 () with\n                                          | Some func_name -> \n                                              $2 ();\n                                              let func_body = $3 in\n                                              let func_entry = lookupEntry func_name LOOKUP_ALL_SCOPES true in\n                                              (match func_entry.entry_info with\n                                              | ENTRY_function func_info -> func_info.function_body <- func_body; Some func_name\n                                              | _ -> Some func_name)\n                                          | None -> error \"not a function\"; None\n                                        end\n                                      }\n\nlocal_def_list: /* nothing */            { fun _ -> () }\n              | local_def local_def_list { fun _ -> begin ignore($1 ()); $2 () end }\n\nheader: T_fun T_id T_lparen fpar_def semi_fpar_def_list T_rparen T_colon ret_type { fun _ -> let id = (id_make $2) in\n                                                                                             let params = $4 () :: $5 () in\n                                                                                             let return_type = $8 () in \n                                                                                             registerHeader id params return_type;\n                                                                                             Some id\n                                                                                  }\n      | T_fun T_id T_lparen T_rparen T_colon ret_type                             { fun _ -> let id = (id_make $2) in\n                                                                                             let params = [] in\n                                                                                             let return_type = $6 () in \n                                                                                             registerHeader id params return_type;\n                                                                                             Some id\n                                                                                  } \n\nsemi_fpar_def_list: /* nothing */                           { fun _ -> [] }\n                  | T_semicolon fpar_def semi_fpar_def_list { fun _ -> $2 () :: $3 () }\n\nfpar_def: T_ref T_id comma_id_list T_colon fpar_type { fun _ -> let params = (id_make $2) :: $3 () in\n                                                                let param_type = $5 () in\n                                                                { id = params; mode = PASS_BY_REFERENCE ; param_type = param_type }\n                                                     }\n        | T_id comma_id_list T_colon fpar_type       { fun _ -> let params = (id_make $1) :: $2 () in\n                                                                let param_type = $4 () in\n                                                                { id = params; mode = PASS_BY_VALUE ; param_type = param_type }\n                                                     }\n\ncomma_id_list: /* nothing */              { fun _ -> [] }\n             | T_comma T_id comma_id_list { fun _ -> (id_make $2) :: $3 () }\n\ndata_type: T_int  { fun _ -> TYPE_int }\n         | T_char { fun _ -> TYPE_char }\n\nbracket_int_const_list: /* nothing */                                        { fun _ -> [] }\n                      | T_lbrack T_int_const T_rbrack bracket_int_const_list { fun _ -> $2 :: $4 () }\n\nret_type: data_type { fun _ -> $1 () }\n        | T_nothing { fun _ -> TYPE_proc }\n\nfpar_type: data_type T_lbrack T_rbrack bracket_int_const_list { fun _ -> let base_type = $1 () in\n                                                                         let dimensions = max_int :: $4 () in\n                                                                         match dimensions with\n                                                                         | [] -> base_type\n                                                                         | _ -> TYPE_array (base_type, dimensions)\n                                                              } \n         | data_type bracket_int_const_list                   { fun _ -> let base_type = $1 () in\n                                                                         let dimensions = $2 () in\n                                                                         match dimensions with\n                                                                         | [] -> base_type\n                                                                         | _ -> TYPE_array (base_type, dimensions)\n                                                              }\n\ngrace_type: data_type bracket_int_const_list { fun _ -> let base_type = $1 () in\n                                                        let dimensions = $2 () in\n                                                        match dimensions with\n                                                        | [] -> base_type\n                                                        | _ -> TYPE_array (base_type, dimensions)\n                                             }\n\nlocal_def: func_def  { $1 }\n         | func_decl { $1 }\n         | var_def   { $1 }\n\nfunc_decl: header T_semicolon { $1 }\n\nvar_def: T_var T_id comma_id_list T_colon grace_type T_semicolon { fun _ -> let vars = (id_make $2) :: $3 () in\n                                                                            let var_type = $5 () in\n                                                                            print_grace_type var_type;\n                                                                            List.iter ( fun var -> ignore(newVariable var var_type true) ) vars; None\n                                                                 }\n\nstmt: T_semicolon                       { fun _ -> None }\n    | l_value T_prod expr T_semicolon   { fun _ -> let (id,l) = $1 () in\n                                                   let value = $3 () in\n                                                   assignToVariable (id_make id) value;\n                                                   None\n                                        }\n    | block                             { $1 }\n    | func_call T_semicolon             { $1 }\n    | T_if cond T_then stmt             { fun _ -> if $2 () then $4 () else None }\n    | T_if cond T_then stmt T_else stmt { fun _ -> if $2 () then $4 () else $6 () }\n    | T_while cond T_do stmt            { fun _ -> while $2 () do ignore($4 ()) done; None }\n    | T_return T_semicolon              { fun _ -> None }\n    | T_return expr T_semicolon         { fun _ -> Some($2 ()) }\n\n\nblock: T_lbrace stmt_list T_rbrace { $2 }\n\nstmt_list: /* nothing */  { fun _ -> None }\n         | stmt stmt_list { fun _ -> let result = $1 () in\n                                     match result with\n                                     | Some _ as returnValue -> returnValue\n                                     | None -> $2 ()\n      }\n\nfunc_call: T_id T_lparen T_rparen                      { fun _ -> let func_name = $1 in\n                                                                  match func_name with \n                                                                  | \"writeInteger\" -> print_string \"WriteInteger\"; None\n                                                                  | \"writeChar\"    -> print_string \"WriteChar\"; None\n                                                                  | \"writeString\"  -> print_string \"WriteString\"; None\n                                                                  | \"readInteger\"  -> print_string \"ReadInteger\"; None\n                                                                  | \"readChar\"     -> print_string \"ReadChar\"; None\n                                                                  | \"readString\"   -> print_string \"ReadString\"; None\n                                                                  | _ -> let func_entry = lookupEntry (id_make func_name) LOOKUP_ALL_SCOPES true in\n                                                                         (match func_entry.entry_info with\n                                                                         | ENTRY_function func_info ->\n                                                                           if List.length func_info.function_paramlist = 0 then\n                                                                             callFunction (id_make func_name) []\n                                                                           else (error \"Incorrect number of arguments for function %a\" pretty_id (id_make func_name); None)\n                                                                         | _ -> (error \"%a is not a function\" pretty_id (id_make func_name); None))\n                                                       }\n         | T_id T_lparen expr comma_expr_list T_rparen { fun _ -> let func_name = $1 in\n                                                                  let args = $3 () :: $4 () in\n                                                                  match func_name with \n                                                                  | \"writeInteger\" -> print_string \"WriteInteger\"; None\n                                                                  | \"writeChar\"    -> print_string \"WriteChar\"; None\n                                                                  | \"writeString\"  -> print_string \"WriteString\"; None\n                                                                  | \"readInteger\"  -> print_string \"ReadInteger\"; None\n                                                                  | \"readChar\"     -> print_string \"ReadChar\"; None\n                                                                  | \"readString\"   -> print_string \"ReadString\"; None\n                                                                  | _ -> let func_entry = lookupEntry (id_make func_name) LOOKUP_ALL_SCOPES true in\n                                                                         (match func_entry.entry_info with\n                                                                         | ENTRY_function func_info ->\n                                                                           if List.length func_info.function_paramlist = List.length args then\n                                                                           callFunction (id_make func_name) args\n                                                                         else\n                                                                           (error \"Incorrect number of arguments for function %a\" pretty_id (id_make func_name); None)\n                                                                         | _ -> (error \"%a is not a function\" pretty_id (id_make func_name); None))\n                                                       }\n\n\ncomma_expr_list: /* nothing */                { fun _ -> [] }\n               | T_comma expr comma_expr_list { fun _ -> $2 () :: $3 () }\n\nl_value: T_id                           { fun _ -> ($1,[]) }\n       | T_string_literal               { fun _ -> ($1,[]) }\n       | l_value T_lbrack expr T_rbrack { fun _ -> let (value, l) = $1 () in\n                                                   match $3 () with \n                                                   | IntValue exp -> (value, exp :: l)\n                                                   | _ -> error \"not an integer\"; (value, [])\n                                        }\n\n\nexpr: T_int_const            { fun _ -> IntValue $1 }\n    | T_char_const           { fun _ -> CharValue $1 }\n    | l_value                { fun _ -> let (value , l) = $1 () in\n                                        MultiArray (createArray l)\n                             }\n    | T_lparen expr T_rparen { $2 }\n    | func_call              { fun _ -> match $1 () with\n                                        | Some value -> value\n                                        | None -> Unit\n                             }\n    | T_plus expr            { fun _ -> match $2 () with \n                                        | IntValue num -> IntValue num\n                                        | _ -> error \"not an integer; +\"; Unit\n                             }\n    | T_minus expr           { fun _ -> match $2 () with \n                                        | IntValue num -> IntValue (- num)\n                                        | _ -> error \"not an integer; -\"; Unit\n                             }    \n    | expr T_plus expr       { fun _ -> match ($1 (), $3 ()) with\n                                        | (IntValue a, IntValue b) -> IntValue (a + b)\n                                        | _ -> error \"not an integer; plus\"; Unit\n                             }\n    | expr T_minus expr      { fun _ -> let val1 = $1 () in\n                                        let val2 = $3 () in\n                                        print_variable_value val1;\n                                        print_variable_value val2;\n                                        match (val1, val2) with\n                                        | (IntValue a, IntValue b) -> IntValue (a - b)\n                                        | (c, d) -> error \"not an integer; minus\"; Unit\n                             }\n    | expr T_times expr      { fun _ -> match ($1 (), $3 ()) with\n                                        | (IntValue a, IntValue b) -> IntValue (a * b)\n                                        | _ -> error \"not an integer; times\"; Unit\n                             }\n    | expr T_div expr        { fun _ -> match ($1 (), $3 ()) with\n                                        | (IntValue a, IntValue b) -> IntValue (a / b)\n                                        | _ -> error \"not an integer; div\"; Unit\n                             }\n    | expr T_mod expr        { fun _ -> match ($1 (), $3 ()) with\n                                        | (IntValue a, IntValue b) -> IntValue (a mod b)\n                                        | _ -> error \"not an integer; mod\"; Unit\n                             }\n \ncond: T_lparen cond T_rparen { $2 }\n    | T_not cond             { fun _ -> not ($2 ()) }\n    | cond T_and cond        { fun _ -> $1 () && $3 () }\n    | cond T_or cond         { fun _ -> $1 () || $3 () }\n    | expr T_eq expr         { fun _ -> $1 () = $3 () }\n    | expr T_hash expr       { fun _ -> $1 () <> $3 () }\n    | expr T_less expr       { fun _ -> $1 () < $3 () }\n    | expr T_more expr       { fun _ -> $1 () > $3 () }\n    | expr T_leq expr        { fun _ -> $1 () <= $3 () }\n    | expr T_geq expr        { fun _ -> $1 () >= $3 () }\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/tsimiho/Desktop/NTUA/ECE/Semester8/%CE%9C%CE%B5%CF%84%CE%B1%CE%B3%CE%BB%CF%89%CF%84%CF%84%CE%B9%CF%83%CF%84%CE%AD%CF%82/compiler/Parser.mly","version":6},"contentChanges":[{"text":"%{\n  open Symbol\n  open Types\n  open Identifier\n  open Error\n  open Narray\n\n  initSymbolTable 1000;\n\n  type param = { \n    id: Identifier.id list; \n    mode: pass_mode; \n    param_type: typ \n  }\n\n  and param_mode = PASS_BY_VALUE | PASS_BY_REFERENCE\n\n  let registerHeader id params return_type = \n    let fun_entry = newFunction id true in\n    (* openScope(); *)\n    List.iter ( fun p -> \n                  List.iter ( fun single_id -> \n                                ignore (newParameter single_id p.param_type p.mode fun_entry true) \n                            ) p.id\n              ) params;\n    match fun_entry.entry_info with\n    | ENTRY_function func_info ->\n        func_info.function_result <- return_type;\n    | _ -> error \"Expected a function entry %a\" pretty_id id;\n    endFunctionHeader fun_entry return_type\n\n  let callFunction id args =\n    let func_entry = lookupEntry id LOOKUP_ALL_SCOPES true in\n    match func_entry.entry_info with\n    | ENTRY_function inf -> if inf.function_isForward then\n                              let rec linkParams func_params func_args = \n                                match func_params, func_args with\n                                | fp::fps, fa::fas -> if fp.\n                                | [], [] -> inf.function_body () \n                                | _, _ -> error \"Function %a is called with the worng number of parameters\" pretty_id id; None\n                            else error \"%a has not been implemented\" pretty_id id; None\n    | _ -> error \"%a is not a function\" pretty_id id; None\n\n\n  let print_variable_value value =\n    match value with\n    | IntValue i -> Printf.printf \"IntValue: %d\\n\" i\n    | CharValue c -> Printf.printf \"CharValue: '%c'\\n\" c\n    | BoolValue b -> Printf.printf \"BoolValue: %b\\n\" b\n    | MultiArray arr -> Printf.printf \"MultiArray\"\n    | Unit -> Printf.printf \"Unit\\n\"\n\n  let print_grace_type t =\n    match t with\n    | TYPE_int | TYPE_char -> Printf.printf \"Not an array\\n\"\n    | _  -> Printf.printf \"array\\n\"\n        \n%}\n\n%token T_eof \n%token T_and\n%token T_char\n%token T_div\n%token T_do\n%token T_else\n%token T_fun\n%token T_if\n%token T_int \n%token T_mod\n%token T_not\n%token T_nothing\n%token T_or\n%token T_ref\n%token T_return\n%token T_then\n%token T_var\n%token T_while\n%token<string> T_id\n%token<int> T_int_const\n%token<char> T_char_const\n%token<string> T_string_literal\n%token T_eq\n%token T_lparen\n%token T_rparen\n%token T_plus\n%token T_minus\n%token T_times\n%token T_less\n%token T_more\n%token T_lbrack\n%token T_rbrack\n%token T_lbrace\n%token T_rbrace\n%token T_hash\n%token T_comma\n%token T_semicolon\n%token T_colon\n%token T_leq\n%token T_geq\n%token T_prod\n\n%left T_or\n%left T_and\n%nonassoc T_not\n%nonassoc T_eq T_hash T_less T_more T_geq T_leq\n%left T_plus T_minus\n%left T_times T_div T_mod\n\n%start program\n%type <unit -> unit> program\n%type <unit -> Identifier.id option> func_def\n%type <unit -> unit> local_def_list\n%type <unit -> Identifier.id option> header\n%type <unit -> param list> semi_fpar_def_list\n%type <unit -> param> fpar_def\n%type <unit -> Identifier.id list> comma_id_list\n%type <unit -> typ> data_type\n%type <unit -> int list> bracket_int_const_list\n%type <unit -> typ> ret_type\n%type <unit -> typ> fpar_type\n%type <unit -> typ> grace_type\n%type <unit -> Identifier.id option> local_def\n%type <unit -> Identifier.id option> func_decl\n%type <unit -> Identifier.id option> var_def\n%type <unit -> variable_value option> stmt\n%type <unit -> variable_value option> block\n%type <unit -> variable_value option> stmt_list\n%type <unit -> variable_value option> func_call\n%type <unit -> variable_value list> comma_expr_list\n%type <unit -> (string * int list)> l_value\n%type <unit -> variable_value> expr\n%type <unit -> bool> cond\n\n\n%%\n\nprogram: func_def T_eof { fun _ -> match $1 () with\n                                   | Some id -> ignore(callFunction id [])\n                                   | _ -> error \"not a function\"\n                        }\n\nfunc_def: header local_def_list block { fun _ -> begin \n                                          match $1 () with\n                                          | Some func_name -> \n                                              $2 ();\n                                              let func_body = $3 in\n                                              let func_entry = lookupEntry func_name LOOKUP_ALL_SCOPES true in\n                                              (match func_entry.entry_info with\n                                              | ENTRY_function func_info -> func_info.function_body <- func_body; Some func_name\n                                              | _ -> Some func_name)\n                                          | None -> error \"not a function\"; None\n                                        end\n                                      }\n\nlocal_def_list: /* nothing */            { fun _ -> () }\n              | local_def local_def_list { fun _ -> begin ignore($1 ()); $2 () end }\n\nheader: T_fun T_id T_lparen fpar_def semi_fpar_def_list T_rparen T_colon ret_type { fun _ -> let id = (id_make $2) in\n                                                                                             let params = $4 () :: $5 () in\n                                                                                             let return_type = $8 () in \n                                                                                             registerHeader id params return_type;\n                                                                                             Some id\n                                                                                  }\n      | T_fun T_id T_lparen T_rparen T_colon ret_type                             { fun _ -> let id = (id_make $2) in\n                                                                                             let params = [] in\n                                                                                             let return_type = $6 () in \n                                                                                             registerHeader id params return_type;\n                                                                                             Some id\n                                                                                  } \n\nsemi_fpar_def_list: /* nothing */                           { fun _ -> [] }\n                  | T_semicolon fpar_def semi_fpar_def_list { fun _ -> $2 () :: $3 () }\n\nfpar_def: T_ref T_id comma_id_list T_colon fpar_type { fun _ -> let params = (id_make $2) :: $3 () in\n                                                                let param_type = $5 () in\n                                                                { id = params; mode = PASS_BY_REFERENCE ; param_type = param_type }\n                                                     }\n        | T_id comma_id_list T_colon fpar_type       { fun _ -> let params = (id_make $1) :: $2 () in\n                                                                let param_type = $4 () in\n                                                                { id = params; mode = PASS_BY_VALUE ; param_type = param_type }\n                                                     }\n\ncomma_id_list: /* nothing */              { fun _ -> [] }\n             | T_comma T_id comma_id_list { fun _ -> (id_make $2) :: $3 () }\n\ndata_type: T_int  { fun _ -> TYPE_int }\n         | T_char { fun _ -> TYPE_char }\n\nbracket_int_const_list: /* nothing */                                        { fun _ -> [] }\n                      | T_lbrack T_int_const T_rbrack bracket_int_const_list { fun _ -> $2 :: $4 () }\n\nret_type: data_type { fun _ -> $1 () }\n        | T_nothing { fun _ -> TYPE_proc }\n\nfpar_type: data_type T_lbrack T_rbrack bracket_int_const_list { fun _ -> let base_type = $1 () in\n                                                                         let dimensions = max_int :: $4 () in\n                                                                         match dimensions with\n                                                                         | [] -> base_type\n                                                                         | _ -> TYPE_array (base_type, dimensions)\n                                                              } \n         | data_type bracket_int_const_list                   { fun _ -> let base_type = $1 () in\n                                                                         let dimensions = $2 () in\n                                                                         match dimensions with\n                                                                         | [] -> base_type\n                                                                         | _ -> TYPE_array (base_type, dimensions)\n                                                              }\n\ngrace_type: data_type bracket_int_const_list { fun _ -> let base_type = $1 () in\n                                                        let dimensions = $2 () in\n                                                        match dimensions with\n                                                        | [] -> base_type\n                                                        | _ -> TYPE_array (base_type, dimensions)\n                                             }\n\nlocal_def: func_def  { $1 }\n         | func_decl { $1 }\n         | var_def   { $1 }\n\nfunc_decl: header T_semicolon { $1 }\n\nvar_def: T_var T_id comma_id_list T_colon grace_type T_semicolon { fun _ -> let vars = (id_make $2) :: $3 () in\n                                                                            let var_type = $5 () in\n                                                                            print_grace_type var_type;\n                                                                            List.iter ( fun var -> ignore(newVariable var var_type true) ) vars; None\n                                                                 }\n\nstmt: T_semicolon                       { fun _ -> None }\n    | l_value T_prod expr T_semicolon   { fun _ -> let (id,l) = $1 () in\n                                                   let value = $3 () in\n                                                   assignToVariable (id_make id) value;\n                                                   None\n                                        }\n    | block                             { $1 }\n    | func_call T_semicolon             { $1 }\n    | T_if cond T_then stmt             { fun _ -> if $2 () then $4 () else None }\n    | T_if cond T_then stmt T_else stmt { fun _ -> if $2 () then $4 () else $6 () }\n    | T_while cond T_do stmt            { fun _ -> while $2 () do ignore($4 ()) done; None }\n    | T_return T_semicolon              { fun _ -> None }\n    | T_return expr T_semicolon         { fun _ -> Some($2 ()) }\n\n\nblock: T_lbrace stmt_list T_rbrace { $2 }\n\nstmt_list: /* nothing */  { fun _ -> None }\n         | stmt stmt_list { fun _ -> let result = $1 () in\n                                     match result with\n                                     | Some _ as returnValue -> returnValue\n                                     | None -> $2 ()\n      }\n\nfunc_call: T_id T_lparen T_rparen                      { fun _ -> let func_name = $1 in\n                                                                  match func_name with \n                                                                  | \"writeInteger\" -> print_string \"WriteInteger\"; None\n                                                                  | \"writeChar\"    -> print_string \"WriteChar\"; None\n                                                                  | \"writeString\"  -> print_string \"WriteString\"; None\n                                                                  | \"readInteger\"  -> print_string \"ReadInteger\"; None\n                                                                  | \"readChar\"     -> print_string \"ReadChar\"; None\n                                                                  | \"readString\"   -> print_string \"ReadString\"; None\n                                                                  | _ -> let func_entry = lookupEntry (id_make func_name) LOOKUP_ALL_SCOPES true in\n                                                                         (match func_entry.entry_info with\n                                                                         | ENTRY_function func_info ->\n                                                                           if List.length func_info.function_paramlist = 0 then\n                                                                             callFunction (id_make func_name) []\n                                                                           else (error \"Incorrect number of arguments for function %a\" pretty_id (id_make func_name); None)\n                                                                         | _ -> (error \"%a is not a function\" pretty_id (id_make func_name); None))\n                                                       }\n         | T_id T_lparen expr comma_expr_list T_rparen { fun _ -> let func_name = $1 in\n                                                                  let args = $3 () :: $4 () in\n                                                                  match func_name with \n                                                                  | \"writeInteger\" -> print_string \"WriteInteger\"; None\n                                                                  | \"writeChar\"    -> print_string \"WriteChar\"; None\n                                                                  | \"writeString\"  -> print_string \"WriteString\"; None\n                                                                  | \"readInteger\"  -> print_string \"ReadInteger\"; None\n                                                                  | \"readChar\"     -> print_string \"ReadChar\"; None\n                                                                  | \"readString\"   -> print_string \"ReadString\"; None\n                                                                  | _ -> let func_entry = lookupEntry (id_make func_name) LOOKUP_ALL_SCOPES true in\n                                                                         (match func_entry.entry_info with\n                                                                         | ENTRY_function func_info ->\n                                                                           if List.length func_info.function_paramlist = List.length args then\n                                                                           callFunction (id_make func_name) args\n                                                                         else\n                                                                           (error \"Incorrect number of arguments for function %a\" pretty_id (id_make func_name); None)\n                                                                         | _ -> (error \"%a is not a function\" pretty_id (id_make func_name); None))\n                                                       }\n\n\ncomma_expr_list: /* nothing */                { fun _ -> [] }\n               | T_comma expr comma_expr_list { fun _ -> $2 () :: $3 () }\n\nl_value: T_id                           { fun _ -> ($1,[]) }\n       | T_string_literal               { fun _ -> ($1,[]) }\n       | l_value T_lbrack expr T_rbrack { fun _ -> let (value, l) = $1 () in\n                                                   match $3 () with \n                                                   | IntValue exp -> (value, exp :: l)\n                                                   | _ -> error \"not an integer\"; (value, [])\n                                        }\n\n\nexpr: T_int_const            { fun _ -> IntValue $1 }\n    | T_char_const           { fun _ -> CharValue $1 }\n    | l_value                { fun _ -> let (value , l) = $1 () in\n                                        MultiArray (createArray l)\n                             }\n    | T_lparen expr T_rparen { $2 }\n    | func_call              { fun _ -> match $1 () with\n                                        | Some value -> value\n                                        | None -> Unit\n                             }\n    | T_plus expr            { fun _ -> match $2 () with \n                                        | IntValue num -> IntValue num\n                                        | _ -> error \"not an integer; +\"; Unit\n                             }\n    | T_minus expr           { fun _ -> match $2 () with \n                                        | IntValue num -> IntValue (- num)\n                                        | _ -> error \"not an integer; -\"; Unit\n                             }    \n    | expr T_plus expr       { fun _ -> match ($1 (), $3 ()) with\n                                        | (IntValue a, IntValue b) -> IntValue (a + b)\n                                        | _ -> error \"not an integer; plus\"; Unit\n                             }\n    | expr T_minus expr      { fun _ -> let val1 = $1 () in\n                                        let val2 = $3 () in\n                                        print_variable_value val1;\n                                        print_variable_value val2;\n                                        match (val1, val2) with\n                                        | (IntValue a, IntValue b) -> IntValue (a - b)\n                                        | (c, d) -> error \"not an integer; minus\"; Unit\n                             }\n    | expr T_times expr      { fun _ -> match ($1 (), $3 ()) with\n                                        | (IntValue a, IntValue b) -> IntValue (a * b)\n                                        | _ -> error \"not an integer; times\"; Unit\n                             }\n    | expr T_div expr        { fun _ -> match ($1 (), $3 ()) with\n                                        | (IntValue a, IntValue b) -> IntValue (a / b)\n                                        | _ -> error \"not an integer; div\"; Unit\n                             }\n    | expr T_mod expr        { fun _ -> match ($1 (), $3 ()) with\n                                        | (IntValue a, IntValue b) -> IntValue (a mod b)\n                                        | _ -> error \"not an integer; mod\"; Unit\n                             }\n \ncond: T_lparen cond T_rparen { $2 }\n    | T_not cond             { fun _ -> not ($2 ()) }\n    | cond T_and cond        { fun _ -> $1 () && $3 () }\n    | cond T_or cond         { fun _ -> $1 () || $3 () }\n    | expr T_eq expr         { fun _ -> $1 () = $3 () }\n    | expr T_hash expr       { fun _ -> $1 () <> $3 () }\n    | expr T_less expr       { fun _ -> $1 () < $3 () }\n    | expr T_more expr       { fun _ -> $1 () > $3 () }\n    | expr T_leq expr        { fun _ -> $1 () <= $3 () }\n    | expr T_geq expr        { fun _ -> $1 () >= $3 () }\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/tsimiho/Desktop/NTUA/ECE/Semester8/%CE%9C%CE%B5%CF%84%CE%B1%CE%B3%CE%BB%CF%89%CF%84%CF%84%CE%B9%CF%83%CF%84%CE%AD%CF%82/compiler/Parser.mly","version":7},"contentChanges":[{"text":"%{\n  open Symbol\n  open Types\n  open Identifier\n  open Error\n  open Narray\n\n  initSymbolTable 1000;\n\n  type param = { \n    id: Identifier.id list; \n    mode: pass_mode; \n    param_type: typ \n  }\n\n  and param_mode = PASS_BY_VALUE | PASS_BY_REFERENCE\n\n  let registerHeader id params return_type = \n    let fun_entry = newFunction id true in\n    (* openScope(); *)\n    List.iter ( fun p -> \n                  List.iter ( fun single_id -> \n                                ignore (newParameter single_id p.param_type p.mode fun_entry true) \n                            ) p.id\n              ) params;\n    match fun_entry.entry_info with\n    | ENTRY_function func_info ->\n        func_info.function_result <- return_type;\n    | _ -> error \"Expected a function entry %a\" pretty_id id;\n    endFunctionHeader fun_entry return_type\n\n  let callFunction id args =\n    let func_entry = lookupEntry id LOOKUP_ALL_SCOPES true in\n    match func_entry.entry_info with\n    | ENTRY_function inf -> if inf.function_isForward then\n                              let rec linkParams func_params func_args = \n                                match func_params, func_args with\n                                | fp::fps, fa::fas -> if fp.\n                                | [], [] -> inf.function_body () \n                                | _, _ -> error \"Function %a is called with the worng number of parameters\" pretty_id id; None\n                            else error \"%a has not been implemented\" pretty_id id; None\n    | _ -> error \"%a is not a function\" pretty_id id; None\n\n\n  let print_variable_value value =\n    match value with\n    | IntValue i -> Printf.printf \"IntValue: %d\\n\" i\n    | CharValue c -> Printf.printf \"CharValue: '%c'\\n\" c\n    | BoolValue b -> Printf.printf \"BoolValue: %b\\n\" b\n    | MultiArray arr -> Printf.printf \"MultiArray\"\n    | Unit -> Printf.printf \"Unit\\n\"\n\n  let print_grace_type t =\n    match t with\n    | TYPE_int | TYPE_char -> Printf.printf \"Not an array\\n\"\n    | _  -> Printf.printf \"array\\n\"\n        \n%}\n\n%token T_eof \n%token T_and\n%token T_char\n%token T_div\n%token T_do\n%token T_else\n%token T_fun\n%token T_if\n%token T_int \n%token T_mod\n%token T_not\n%token T_nothing\n%token T_or\n%token T_ref\n%token T_return\n%token T_then\n%token T_var\n%token T_while\n%token<string> T_id\n%token<int> T_int_const\n%token<char> T_char_const\n%token<string> T_string_literal\n%token T_eq\n%token T_lparen\n%token T_rparen\n%token T_plus\n%token T_minus\n%token T_times\n%token T_less\n%token T_more\n%token T_lbrack\n%token T_rbrack\n%token T_lbrace\n%token T_rbrace\n%token T_hash\n%token T_comma\n%token T_semicolon\n%token T_colon\n%token T_leq\n%token T_geq\n%token T_prod\n\n%left T_or\n%left T_and\n%nonassoc T_not\n%nonassoc T_eq T_hash T_less T_more T_geq T_leq\n%left T_plus T_minus\n%left T_times T_div T_mod\n\n%start program\n%type <unit -> unit> program\n%type <unit -> Identifier.id option> func_def\n%type <unit -> unit> local_def_list\n%type <unit -> Identifier.id option> header\n%type <unit -> param list> semi_fpar_def_list\n%type <unit -> param> fpar_def\n%type <unit -> Identifier.id list> comma_id_list\n%type <unit -> typ> data_type\n%type <unit -> int list> bracket_int_const_list\n%type <unit -> typ> ret_type\n%type <unit -> typ> fpar_type\n%type <unit -> typ> grace_type\n%type <unit -> Identifier.id option> local_def\n%type <unit -> Identifier.id option> func_decl\n%type <unit -> Identifier.id option> var_def\n%type <unit -> variable_value option> stmt\n%type <unit -> variable_value option> block\n%type <unit -> variable_value option> stmt_list\n%type <unit -> variable_value option> func_call\n%type <unit -> variable_value list> comma_expr_list\n%type <unit -> (string * int list)> l_value\n%type <unit -> variable_value> expr\n%type <unit -> bool> cond\n\n\n%%\n\nprogram: func_def T_eof { fun _ -> match $1 () with\n                                   | Some id -> ignore(callFunction id [])\n                                   | _ -> error \"not a function\"\n                        }\n\nfunc_def: header local_def_list block { fun _ -> begin \n                                          match $1 () with\n                                          | Some func_name -> \n                                              $2 ();\n                                              let func_body = $3 in\n                                              let func_entry = lookupEntry func_name LOOKUP_ALL_SCOPES true in\n                                              (match func_entry.entry_info with\n                                              | ENTRY_function func_info -> func_info.function_body <- func_body; Some func_name\n                                              | _ -> Some func_name)\n                                          | None -> error \"not a function\"; None\n                                        end\n                                      }\n\nlocal_def_list: /* nothing */            { fun _ -> () }\n              | local_def local_def_list { fun _ -> begin ignore($1 ()); $2 () end }\n\nheader: T_fun T_id T_lparen fpar_def semi_fpar_def_list T_rparen T_colon ret_type { fun _ -> let id = (id_make $2) in\n                                                                                             let params = $4 () :: $5 () in\n                                                                                             let return_type = $8 () in \n                                                                                             registerHeader id params return_type;\n                                                                                             Some id\n                                                                                  }\n      | T_fun T_id T_lparen T_rparen T_colon ret_type                             { fun _ -> let id = (id_make $2) in\n                                                                                             let params = [] in\n                                                                                             let return_type = $6 () in \n                                                                                             registerHeader id params return_type;\n                                                                                             Some id\n                                                                                  } \n\nsemi_fpar_def_list: /* nothing */                           { fun _ -> [] }\n                  | T_semicolon fpar_def semi_fpar_def_list { fun _ -> $2 () :: $3 () }\n\nfpar_def: T_ref T_id comma_id_list T_colon fpar_type { fun _ -> let params = (id_make $2) :: $3 () in\n                                                                let param_type = $5 () in\n                                                                { id = params; mode = PASS_BY_REFERENCE ; param_type = param_type }\n                                                     }\n        | T_id comma_id_list T_colon fpar_type       { fun _ -> let params = (id_make $1) :: $2 () in\n                                                                let param_type = $4 () in\n                                                                { id = params; mode = PASS_BY_VALUE ; param_type = param_type }\n                                                     }\n\ncomma_id_list: /* nothing */              { fun _ -> [] }\n             | T_comma T_id comma_id_list { fun _ -> (id_make $2) :: $3 () }\n\ndata_type: T_int  { fun _ -> TYPE_int }\n         | T_char { fun _ -> TYPE_char }\n\nbracket_int_const_list: /* nothing */                                        { fun _ -> [] }\n                      | T_lbrack T_int_const T_rbrack bracket_int_const_list { fun _ -> $2 :: $4 () }\n\nret_type: data_type { fun _ -> $1 () }\n        | T_nothing { fun _ -> TYPE_proc }\n\nfpar_type: data_type T_lbrack T_rbrack bracket_int_const_list { fun _ -> let base_type = $1 () in\n                                                                         let dimensions = max_int :: $4 () in\n                                                                         match dimensions with\n                                                                         | [] -> base_type\n                                                                         | _ -> TYPE_array (base_type, dimensions)\n                                                              } \n         | data_type bracket_int_const_list                   { fun _ -> let base_type = $1 () in\n                                                                         let dimensions = $2 () in\n                                                                         match dimensions with\n                                                                         | [] -> base_type\n                                                                         | _ -> TYPE_array (base_type, dimensions)\n                                                              }\n\ngrace_type: data_type bracket_int_const_list { fun _ -> let base_type = $1 () in\n                                                        let dimensions = $2 () in\n                                                        match dimensions with\n                                                        | [] -> base_type\n                                                        | _ -> TYPE_array (base_type, dimensions)\n                                             }\n\nlocal_def: func_def  { $1 }\n         | func_decl { $1 }\n         | var_def   { $1 }\n\nfunc_decl: header T_semicolon { $1 }\n\nvar_def: T_var T_id comma_id_list T_colon grace_type T_semicolon { fun _ -> let vars = (id_make $2) :: $3 () in\n                                                                            let var_type = $5 () in\n                                                                            print_grace_type var_type;\n                                                                            List.iter ( fun var -> ignore(newVariable var var_type true) ) vars; None\n                                                                 }\n\nstmt: T_semicolon                       { fun _ -> None }\n    | l_value T_prod expr T_semicolon   { fun _ -> let (id,l) = $1 () in\n                                                   let value = $3 () in\n                                                   assignToVariable (id_make id) value;\n                                                   None\n                                        }\n    | block                             { $1 }\n    | func_call T_semicolon             { $1 }\n    | T_if cond T_then stmt             { fun _ -> if $2 () then $4 () else None }\n    | T_if cond T_then stmt T_else stmt { fun _ -> if $2 () then $4 () else $6 () }\n    | T_while cond T_do stmt            { fun _ -> while $2 () do ignore($4 ()) done; None }\n    | T_return T_semicolon              { fun _ -> None }\n    | T_return expr T_semicolon         { fun _ -> Some($2 ()) }\n\n\nblock: T_lbrace stmt_list T_rbrace { $2 }\n\nstmt_list: /* nothing */  { fun _ -> None }\n         | stmt stmt_list { fun _ -> let result = $1 () in\n                                     match result with\n                                     | Some _ as returnValue -> returnValue\n                                     | None -> $2 ()\n      }\n\nfunc_call: T_id T_lparen T_rparen                      { fun _ -> let func_name = $1 in\n                                                                  match func_name with \n                                                                  | \"writeInteger\" -> print_string \"WriteInteger\"; None\n                                                                  | \"writeChar\"    -> print_string \"WriteChar\"; None\n                                                                  | \"writeString\"  -> print_string \"WriteString\"; None\n                                                                  | \"readInteger\"  -> print_string \"ReadInteger\"; None\n                                                                  | \"readChar\"     -> print_string \"ReadChar\"; None\n                                                                  | \"readString\"   -> print_string \"ReadString\"; None\n                                                                  | _ -> let func_entry = lookupEntry (id_make func_name) LOOKUP_ALL_SCOPES true in\n                                                                         (match func_entry.entry_info with\n                                                                         | ENTRY_function func_info ->\n                                                                           if List.length func_info.function_paramlist = 0 then\n                                                                             callFunction (id_make func_name) []\n                                                                           else (error \"Incorrect number of arguments for function %a\" pretty_id (id_make func_name); None)\n                                                                         | _ -> (error \"%a is not a function\" pretty_id (id_make func_name); None))\n                                                       }\n         | T_id T_lparen expr comma_expr_list T_rparen { fun _ -> let func_name = $1 in\n                                                                  let args = $3 () :: $4 () in\n                                                                  match func_name with \n                                                                  | \"writeInteger\" -> print_string \"WriteInteger\"; None\n                                                                  | \"writeChar\"    -> print_string \"WriteChar\"; None\n                                                                  | \"writeString\"  -> print_string \"WriteString\"; None\n                                                                  | \"readInteger\"  -> print_string \"ReadInteger\"; None\n                                                                  | \"readChar\"     -> print_string \"ReadChar\"; None\n                                                                  | \"readString\"   -> print_string \"ReadString\"; None\n                                                                  | _ -> let func_entry = lookupEntry (id_make func_name) LOOKUP_ALL_SCOPES true in\n                                                                         (match func_entry.entry_info with\n                                                                         | ENTRY_function func_info ->\n                                                                           if List.length func_info.function_paramlist = List.length args then\n                                                                           callFunction (id_make func_name) args\n                                                                         else\n                                                                           (error \"Incorrect number of arguments for function %a\" pretty_id (id_make func_name); None)\n                                                                         | _ -> (error \"%a is not a function\" pretty_id (id_make func_name); None))\n                                                       }\n\n\ncomma_expr_list: /* nothing */                { fun _ -> [] }\n               | T_comma expr comma_expr_list { fun _ -> $2 () :: $3 () }\n\nl_value: T_id                           { fun _ -> ($1,[]) }\n       | T_string_literal               { fun _ -> ($1,[]) }\n       | l_value T_lbrack expr T_rbrack { fun _ -> let (value, l) = $1 () in\n                                                   match $3 () with \n                                                   | IntValue exp -> (value, exp :: l)\n                                                   | _ -> error \"not an integer\"; (value, [])\n                                        }\n\n\nexpr: T_int_const            { fun _ -> IntValue $1 }\n    | T_char_const           { fun _ -> CharValue $1 }\n    | l_value                { fun _ -> let (value , l) = $1 () in\n                                        MultiArray (createArray l)\n                             }\n    | T_lparen expr T_rparen { $2 }\n    | func_call              { fun _ -> match $1 () with\n                                        | Some value -> value\n                                        | None -> Unit\n                             }\n    | T_plus expr            { fun _ -> match $2 () with \n                                        | IntValue num -> IntValue num\n                                        | _ -> error \"not an integer; +\"; Unit\n                             }\n    | T_minus expr           { fun _ -> match $2 () with \n                                        | IntValue num -> IntValue (- num)\n                                        | _ -> error \"not an integer; -\"; Unit\n                             }    \n    | expr T_plus expr       { fun _ -> match ($1 (), $3 ()) with\n                                        | (IntValue a, IntValue b) -> IntValue (a + b)\n                                        | _ -> error \"not an integer; plus\"; Unit\n                             }\n    | expr T_minus expr      { fun _ -> let val1 = $1 () in\n                                        let val2 = $3 () in\n                                        print_variable_value val1;\n                                        print_variable_value val2;\n                                        match (val1, val2) with\n                                        | (IntValue a, IntValue b) -> IntValue (a - b)\n                                        | (c, d) -> error \"not an integer; minus\"; Unit\n                             }\n    | expr T_times expr      { fun _ -> match ($1 (), $3 ()) with\n                                        | (IntValue a, IntValue b) -> IntValue (a * b)\n                                        | _ -> error \"not an integer; times\"; Unit\n                             }\n    | expr T_div expr        { fun _ -> match ($1 (), $3 ()) with\n                                        | (IntValue a, IntValue b) -> IntValue (a / b)\n                                        | _ -> error \"not an integer; div\"; Unit\n                             }\n    | expr T_mod expr        { fun _ -> match ($1 (), $3 ()) with\n                                        | (IntValue a, IntValue b) -> IntValue (a mod b)\n                                        | _ -> error \"not an integer; mod\"; Unit\n                             }\n \ncond: T_lparen cond T_rparen { $2 }\n    | T_not cond             { fun _ -> not ($2 ()) }\n    | cond T_and cond        { fun _ -> $1 () && $3 () }\n    | cond T_or cond         { fun _ -> $1 () || $3 () }\n    | expr T_eq expr         { fun _ -> $1 () = $3 () }\n    | expr T_hash expr       { fun _ -> $1 () <> $3 () }\n    | expr T_less expr       { fun _ -> $1 () < $3 () }\n    | expr T_more expr       { fun _ -> $1 () > $3 () }\n    | expr T_leq expr        { fun _ -> $1 () <= $3 () }\n    | expr T_geq expr        { fun _ -> $1 () >= $3 () }\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/tsimiho/Desktop/NTUA/ECE/Semester8/%CE%9C%CE%B5%CF%84%CE%B1%CE%B3%CE%BB%CF%89%CF%84%CF%84%CE%B9%CF%83%CF%84%CE%AD%CF%82/compiler/Parser.mly","version":8},"contentChanges":[{"text":"%{\n  open Symbol\n  open Types\n  open Identifier\n  open Error\n  open Narray\n\n  initSymbolTable 1000;\n\n  type param = { \n    id: Identifier.id list; \n    mode: pass_mode; \n    param_type: typ \n  }\n\n  and param_mode = PASS_BY_VALUE | PASS_BY_REFERENCE\n\n  let registerHeader id params return_type = \n    let fun_entry = newFunction id true in\n    (* openScope(); *)\n    List.iter ( fun p -> \n                  List.iter ( fun single_id -> \n                                ignore (newParameter single_id p.param_type p.mode fun_entry true) \n                            ) p.id\n              ) params;\n    match fun_entry.entry_info with\n    | ENTRY_function func_info ->\n        func_info.function_result <- return_type;\n    | _ -> error \"Expected a function entry %a\" pretty_id id;\n    endFunctionHeader fun_entry return_type\n\n  let callFunction id args =\n    let func_entry = lookupEntry id LOOKUP_ALL_SCOPES true in\n    match func_entry.entry_info with\n    | ENTRY_function inf -> if inf.function_isForward then\n                              let rec linkParams func_params func_args = \n                                match func_params, func_args with\n                                | fp::fps, fa::fas -> if fp.\n                                | [], [] -> inf.function_body () \n                                | _, _ -> error \"Function %a is called with the worng number of parameters\" pretty_id id; None\n                            else error \"%a has not been implemented\" pretty_id id; None\n    | _ -> error \"%a is not a function\" pretty_id id; None\n\n\n  let print_variable_value value =\n    match value with\n    | IntValue i -> Printf.printf \"IntValue: %d\\n\" i\n    | CharValue c -> Printf.printf \"CharValue: '%c'\\n\" c\n    | BoolValue b -> Printf.printf \"BoolValue: %b\\n\" b\n    | MultiArray arr -> Printf.printf \"MultiArray\"\n    | Unit -> Printf.printf \"Unit\\n\"\n\n  let print_grace_type t =\n    match t with\n    | TYPE_int | TYPE_char -> Printf.printf \"Not an array\\n\"\n    | _  -> Printf.printf \"array\\n\"\n        \n%}\n\n%token T_eof \n%token T_and\n%token T_char\n%token T_div\n%token T_do\n%token T_else\n%token T_fun\n%token T_if\n%token T_int \n%token T_mod\n%token T_not\n%token T_nothing\n%token T_or\n%token T_ref\n%token T_return\n%token T_then\n%token T_var\n%token T_while\n%token<string> T_id\n%token<int> T_int_const\n%token<char> T_char_const\n%token<string> T_string_literal\n%token T_eq\n%token T_lparen\n%token T_rparen\n%token T_plus\n%token T_minus\n%token T_times\n%token T_less\n%token T_more\n%token T_lbrack\n%token T_rbrack\n%token T_lbrace\n%token T_rbrace\n%token T_hash\n%token T_comma\n%token T_semicolon\n%token T_colon\n%token T_leq\n%token T_geq\n%token T_prod\n\n%left T_or\n%left T_and\n%nonassoc T_not\n%nonassoc T_eq T_hash T_less T_more T_geq T_leq\n%left T_plus T_minus\n%left T_times T_div T_mod\n\n%start program\n%type <unit -> unit> program\n%type <unit -> Identifier.id option> func_def\n%type <unit -> unit> local_def_list\n%type <unit -> Identifier.id option> header\n%type <unit -> param list> semi_fpar_def_list\n%type <unit -> param> fpar_def\n%type <unit -> Identifier.id list> comma_id_list\n%type <unit -> typ> data_type\n%type <unit -> int list> bracket_int_const_list\n%type <unit -> typ> ret_type\n%type <unit -> typ> fpar_type\n%type <unit -> typ> grace_type\n%type <unit -> Identifier.id option> local_def\n%type <unit -> Identifier.id option> func_decl\n%type <unit -> Identifier.id option> var_def\n%type <unit -> variable_value option> stmt\n%type <unit -> variable_value option> block\n%type <unit -> variable_value option> stmt_list\n%type <unit -> variable_value option> func_call\n%type <unit -> variable_value list> comma_expr_list\n%type <unit -> (string * int list)> l_value\n%type <unit -> variable_value> expr\n%type <unit -> bool> cond\n\n\n%%\n\nprogram: func_def T_eof { fun _ -> match $1 () with\n                                   | Some id -> ignore(callFunction id [])\n                                   | _ -> error \"not a function\"\n                        }\n\nfunc_def: header local_def_list block { fun _ -> begin \n                                          match $1 () with\n                                          | Some func_name -> \n                                              $2 ();\n                                              let func_body = $3 in\n                                              let func_entry = lookupEntry func_name LOOKUP_ALL_SCOPES true in\n                                              (match func_entry.entry_info with\n                                              | ENTRY_function func_info -> func_info.function_body <- func_body; Some func_name\n                                              | _ -> Some func_name)\n                                          | None -> error \"not a function\"; None\n                                        end\n                                      }\n\nlocal_def_list: /* nothing */            { fun _ -> () }\n              | local_def local_def_list { fun _ -> begin ignore($1 ()); $2 () end }\n\nheader: T_fun T_id T_lparen fpar_def semi_fpar_def_list T_rparen T_colon ret_type { fun _ -> let id = (id_make $2) in\n                                                                                             let params = $4 () :: $5 () in\n                                                                                             let return_type = $8 () in \n                                                                                             registerHeader id params return_type;\n                                                                                             Some id\n                                                                                  }\n      | T_fun T_id T_lparen T_rparen T_colon ret_type                             { fun _ -> let id = (id_make $2) in\n                                                                                             let params = [] in\n                                                                                             let return_type = $6 () in \n                                                                                             registerHeader id params return_type;\n                                                                                             Some id\n                                                                                  } \n\nsemi_fpar_def_list: /* nothing */                           { fun _ -> [] }\n                  | T_semicolon fpar_def semi_fpar_def_list { fun _ -> $2 () :: $3 () }\n\nfpar_def: T_ref T_id comma_id_list T_colon fpar_type { fun _ -> let params = (id_make $2) :: $3 () in\n                                                                let param_type = $5 () in\n                                                                { id = params; mode = PASS_BY_REFERENCE ; param_type = param_type }\n                                                     }\n        | T_id comma_id_list T_colon fpar_type       { fun _ -> let params = (id_make $1) :: $2 () in\n                                                                let param_type = $4 () in\n                                                                { id = params; mode = PASS_BY_VALUE ; param_type = param_type }\n                                                     }\n\ncomma_id_list: /* nothing */              { fun _ -> [] }\n             | T_comma T_id comma_id_list { fun _ -> (id_make $2) :: $3 () }\n\ndata_type: T_int  { fun _ -> TYPE_int }\n         | T_char { fun _ -> TYPE_char }\n\nbracket_int_const_list: /* nothing */                                        { fun _ -> [] }\n                      | T_lbrack T_int_const T_rbrack bracket_int_const_list { fun _ -> $2 :: $4 () }\n\nret_type: data_type { fun _ -> $1 () }\n        | T_nothing { fun _ -> TYPE_proc }\n\nfpar_type: data_type T_lbrack T_rbrack bracket_int_const_list { fun _ -> let base_type = $1 () in\n                                                                         let dimensions = max_int :: $4 () in\n                                                                         match dimensions with\n                                                                         | [] -> base_type\n                                                                         | _ -> TYPE_array (base_type, dimensions)\n                                                              } \n         | data_type bracket_int_const_list                   { fun _ -> let base_type = $1 () in\n                                                                         let dimensions = $2 () in\n                                                                         match dimensions with\n                                                                         | [] -> base_type\n                                                                         | _ -> TYPE_array (base_type, dimensions)\n                                                              }\n\ngrace_type: data_type bracket_int_const_list { fun _ -> let base_type = $1 () in\n                                                        let dimensions = $2 () in\n                                                        match dimensions with\n                                                        | [] -> base_type\n                                                        | _ -> TYPE_array (base_type, dimensions)\n                                             }\n\nlocal_def: func_def  { $1 }\n         | func_decl { $1 }\n         | var_def   { $1 }\n\nfunc_decl: header T_semicolon { $1 }\n\nvar_def: T_var T_id comma_id_list T_colon grace_type T_semicolon { fun _ -> let vars = (id_make $2) :: $3 () in\n                                                                            let var_type = $5 () in\n                                                                            print_grace_type var_type;\n                                                                            List.iter ( fun var -> ignore(newVariable var var_type true) ) vars; None\n                                                                 }\n\nstmt: T_semicolon                       { fun _ -> None }\n    | l_value T_prod expr T_semicolon   { fun _ -> let (id,l) = $1 () in\n                                                   let value = $3 () in\n                                                   assignToVariable (id_make id) value;\n                                                   None\n                                        }\n    | block                             { $1 }\n    | func_call T_semicolon             { $1 }\n    | T_if cond T_then stmt             { fun _ -> if $2 () then $4 () else None }\n    | T_if cond T_then stmt T_else stmt { fun _ -> if $2 () then $4 () else $6 () }\n    | T_while cond T_do stmt            { fun _ -> while $2 () do ignore($4 ()) done; None }\n    | T_return T_semicolon              { fun _ -> None }\n    | T_return expr T_semicolon         { fun _ -> Some($2 ()) }\n\n\nblock: T_lbrace stmt_list T_rbrace { $2 }\n\nstmt_list: /* nothing */  { fun _ -> None }\n         | stmt stmt_list { fun _ -> let result = $1 () in\n                                     match result with\n                                     | Some _ as returnValue -> returnValue\n                                     | None -> $2 ()\n      }\n\nfunc_call: T_id T_lparen T_rparen                      { fun _ -> let func_name = $1 in\n                                                                  match func_name with \n                                                                  | \"writeInteger\" -> print_string \"WriteInteger\"; None\n                                                                  | \"writeChar\"    -> print_string \"WriteChar\"; None\n                                                                  | \"writeString\"  -> print_string \"WriteString\"; None\n                                                                  | \"readInteger\"  -> print_string \"ReadInteger\"; None\n                                                                  | \"readChar\"     -> print_string \"ReadChar\"; None\n                                                                  | \"readString\"   -> print_string \"ReadString\"; None\n                                                                  | _ -> let func_entry = lookupEntry (id_make func_name) LOOKUP_ALL_SCOPES true in\n                                                                         (match func_entry.entry_info with\n                                                                         | ENTRY_function func_info ->\n                                                                           if List.length func_info.function_paramlist = 0 then\n                                                                             callFunction (id_make func_name) []\n                                                                           else (error \"Incorrect number of arguments for function %a\" pretty_id (id_make func_name); None)\n                                                                         | _ -> (error \"%a is not a function\" pretty_id (id_make func_name); None))\n                                                       }\n         | T_id T_lparen expr comma_expr_list T_rparen { fun _ -> let func_name = $1 in\n                                                                  let args = $3 () :: $4 () in\n                                                                  match func_name with \n                                                                  | \"writeInteger\" -> print_string \"WriteInteger\"; None\n                                                                  | \"writeChar\"    -> print_string \"WriteChar\"; None\n                                                                  | \"writeString\"  -> print_string \"WriteString\"; None\n                                                                  | \"readInteger\"  -> print_string \"ReadInteger\"; None\n                                                                  | \"readChar\"     -> print_string \"ReadChar\"; None\n                                                                  | \"readString\"   -> print_string \"ReadString\"; None\n                                                                  | _ -> let func_entry = lookupEntry (id_make func_name) LOOKUP_ALL_SCOPES true in\n                                                                         (match func_entry.entry_info with\n                                                                         | ENTRY_function func_info ->\n                                                                           if List.length func_info.function_paramlist = List.length args then\n                                                                           callFunction (id_make func_name) args\n                                                                         else\n                                                                           (error \"Incorrect number of arguments for function %a\" pretty_id (id_make func_name); None)\n                                                                         | _ -> (error \"%a is not a function\" pretty_id (id_make func_name); None))\n                                                       }\n\n\ncomma_expr_list: /* nothing */                { fun _ -> [] }\n               | T_comma expr comma_expr_list { fun _ -> $2 () :: $3 () }\n\nl_value: T_id                           { fun _ -> ($1,[]) }\n       | T_string_literal               { fun _ -> ($1,[]) }\n       | l_value T_lbrack expr T_rbrack { fun _ -> let (value, l) = $1 () in\n                                                   match $3 () with \n                                                   | IntValue exp -> (value, exp :: l)\n                                                   | _ -> error \"not an integer\"; (value, [])\n                                        }\n\n\nexpr: T_int_const            { fun _ -> IntValue $1 }\n    | T_char_const           { fun _ -> CharValue $1 }\n    | l_value                { fun _ -> let (value , l) = $1 () in\n                                        MultiArray (createArray l)\n                             }\n    | T_lparen expr T_rparen { $2 }\n    | func_call              { fun _ -> match $1 () with\n                                        | Some value -> value\n                                        | None -> Unit\n                             }\n    | T_plus expr            { fun _ -> match $2 () with \n                                        | IntValue num -> IntValue num\n                                        | _ -> error \"not an integer; +\"; Unit\n                             }\n    | T_minus expr           { fun _ -> match $2 () with \n                                        | IntValue num -> IntValue (- num)\n                                        | _ -> error \"not an integer; -\"; Unit\n                             }    \n    | expr T_plus expr       { fun _ -> match ($1 (), $3 ()) with\n                                        | (IntValue a, IntValue b) -> IntValue (a + b)\n                                        | _ -> error \"not an integer; plus\"; Unit\n                             }\n    | expr T_minus expr      { fun _ -> let val1 = $1 () in\n                                        let val2 = $3 () in\n                                        print_variable_value val1;\n                                        print_variable_value val2;\n                                        match (val1, val2) with\n                                        | (IntValue a, IntValue b) -> IntValue (a - b)\n                                        | (c, d) -> error \"not an integer; minus\"; Unit\n                             }\n    | expr T_times expr      { fun _ -> match ($1 (), $3 ()) with\n                                        | (IntValue a, IntValue b) -> IntValue (a * b)\n                                        | _ -> error \"not an integer; times\"; Unit\n                             }\n    | expr T_div expr        { fun _ -> match ($1 (), $3 ()) with\n                                        | (IntValue a, IntValue b) -> IntValue (a / b)\n                                        | _ -> error \"not an integer; div\"; Unit\n                             }\n    | expr T_mod expr        { fun _ -> match ($1 (), $3 ()) with\n                                        | (IntValue a, IntValue b) -> IntValue (a mod b)\n                                        | _ -> error \"not an integer; mod\"; Unit\n                             }\n \ncond: T_lparen cond T_rparen { $2 }\n    | T_not cond             { fun _ -> not ($2 ()) }\n    | cond T_and cond        { fun _ -> $1 () && $3 () }\n    | cond T_or cond         { fun _ -> $1 () || $3 () }\n    | expr T_eq expr         { fun _ -> $1 () = $3 () }\n    | expr T_hash expr       { fun _ -> $1 () <> $3 () }\n    | expr T_less expr       { fun _ -> $1 () < $3 () }\n    | expr T_more expr       { fun _ -> $1 () > $3 () }\n    | expr T_leq expr        { fun _ -> $1 () <= $3 () }\n    | expr T_geq expr        { fun _ -> $1 () >= $3 () }\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/tsimiho/Desktop/NTUA/ECE/Semester8/%CE%9C%CE%B5%CF%84%CE%B1%CE%B3%CE%BB%CF%89%CF%84%CF%84%CE%B9%CF%83%CF%84%CE%AD%CF%82/compiler/Parser.mly","version":9},"contentChanges":[{"text":"%{\n  open Symbol\n  open Types\n  open Identifier\n  open Error\n  open Narray\n\n  initSymbolTable 1000;\n\n  type param = { \n    id: Identifier.id list; \n    mode: pass_mode; \n    param_type: typ \n  }\n\n  and param_mode = PASS_BY_VALUE | PASS_BY_REFERENCE\n\n  let registerHeader id params return_type = \n    let fun_entry = newFunction id true in\n    (* openScope(); *)\n    List.iter ( fun p -> \n                  List.iter ( fun single_id -> \n                                ignore (newParameter single_id p.param_type p.mode fun_entry true) \n                            ) p.id\n              ) params;\n    match fun_entry.entry_info with\n    | ENTRY_function func_info ->\n        func_info.function_result <- return_type;\n    | _ -> error \"Expected a function entry %a\" pretty_id id;\n    endFunctionHeader fun_entry return_type\n\n  let callFunction id args =\n    let func_entry = lookupEntry id LOOKUP_ALL_SCOPES true in\n    match func_entry.entry_info with\n    | ENTRY_function inf -> if inf.function_isForward then\n                              let rec linkParams func_params func_args = \n                                match func_params, func_args with\n                                | fp::fps, fa::fas -> if fp.\n                                | [], [] -> inf.function_body () \n                                | _, _ -> error \"Function %a is called with the worng number of parameters\" pretty_id id; None\n                            else error \"%a has not been implemented\" pretty_id id; None\n    | _ -> error \"%a is not a function\" pretty_id id; None\n\n\n  let print_variable_value value =\n    match value with\n    | IntValue i -> Printf.printf \"IntValue: %d\\n\" i\n    | CharValue c -> Printf.printf \"CharValue: '%c'\\n\" c\n    | BoolValue b -> Printf.printf \"BoolValue: %b\\n\" b\n    | MultiArray arr -> Printf.printf \"MultiArray\"\n    | Unit -> Printf.printf \"Unit\\n\"\n\n  let print_grace_type t =\n    match t with\n    | TYPE_int | TYPE_char -> Printf.printf \"Not an array\\n\"\n    | _  -> Printf.printf \"array\\n\"\n        \n%}\n\n%token T_eof \n%token T_and\n%token T_char\n%token T_div\n%token T_do\n%token T_else\n%token T_fun\n%token T_if\n%token T_int \n%token T_mod\n%token T_not\n%token T_nothing\n%token T_or\n%token T_ref\n%token T_return\n%token T_then\n%token T_var\n%token T_while\n%token<string> T_id\n%token<int> T_int_const\n%token<char> T_char_const\n%token<string> T_string_literal\n%token T_eq\n%token T_lparen\n%token T_rparen\n%token T_plus\n%token T_minus\n%token T_times\n%token T_less\n%token T_more\n%token T_lbrack\n%token T_rbrack\n%token T_lbrace\n%token T_rbrace\n%token T_hash\n%token T_comma\n%token T_semicolon\n%token T_colon\n%token T_leq\n%token T_geq\n%token T_prod\n\n%left T_or\n%left T_and\n%nonassoc T_not\n%nonassoc T_eq T_hash T_less T_more T_geq T_leq\n%left T_plus T_minus\n%left T_times T_div T_mod\n\n%start program\n%type <unit -> unit> program\n%type <unit -> Identifier.id option> func_def\n%type <unit -> unit> local_def_list\n%type <unit -> Identifier.id option> header\n%type <unit -> param list> semi_fpar_def_list\n%type <unit -> param> fpar_def\n%type <unit -> Identifier.id list> comma_id_list\n%type <unit -> typ> data_type\n%type <unit -> int list> bracket_int_const_list\n%type <unit -> typ> ret_type\n%type <unit -> typ> fpar_type\n%type <unit -> typ> grace_type\n%type <unit -> Identifier.id option> local_def\n%type <unit -> Identifier.id option> func_decl\n%type <unit -> Identifier.id option> var_def\n%type <unit -> variable_value option> stmt\n%type <unit -> variable_value option> block\n%type <unit -> variable_value option> stmt_list\n%type <unit -> variable_value option> func_call\n%type <unit -> variable_value list> comma_expr_list\n%type <unit -> (string * int list)> l_value\n%type <unit -> variable_value> expr\n%type <unit -> bool> cond\n\n\n%%\n\nprogram: func_def T_eof { fun _ -> match $1 () with\n                                   | Some id -> ignore(callFunction id [])\n                                   | _ -> error \"not a function\"\n                        }\n\nfunc_def: header local_def_list block { fun _ -> begin \n                                          match $1 () with\n                                          | Some func_name -> \n                                              $2 ();\n                                              let func_body = $3 in\n                                              let func_entry = lookupEntry func_name LOOKUP_ALL_SCOPES true in\n                                              (match func_entry.entry_info with\n                                              | ENTRY_function func_info -> func_info.function_body <- func_body; Some func_name\n                                              | _ -> Some func_name)\n                                          | None -> error \"not a function\"; None\n                                        end\n                                      }\n\nlocal_def_list: /* nothing */            { fun _ -> () }\n              | local_def local_def_list { fun _ -> begin ignore($1 ()); $2 () end }\n\nheader: T_fun T_id T_lparen fpar_def semi_fpar_def_list T_rparen T_colon ret_type { fun _ -> let id = (id_make $2) in\n                                                                                             let params = $4 () :: $5 () in\n                                                                                             let return_type = $8 () in \n                                                                                             registerHeader id params return_type;\n                                                                                             Some id\n                                                                                  }\n      | T_fun T_id T_lparen T_rparen T_colon ret_type                             { fun _ -> let id = (id_make $2) in\n                                                                                             let params = [] in\n                                                                                             let return_type = $6 () in \n                                                                                             registerHeader id params return_type;\n                                                                                             Some id\n                                                                                  } \n\nsemi_fpar_def_list: /* nothing */                           { fun _ -> [] }\n                  | T_semicolon fpar_def semi_fpar_def_list { fun _ -> $2 () :: $3 () }\n\nfpar_def: T_ref T_id comma_id_list T_colon fpar_type { fun _ -> let params = (id_make $2) :: $3 () in\n                                                                let param_type = $5 () in\n                                                                { id = params; mode = PASS_BY_REFERENCE ; param_type = param_type }\n                                                     }\n        | T_id comma_id_list T_colon fpar_type       { fun _ -> let params = (id_make $1) :: $2 () in\n                                                                let param_type = $4 () in\n                                                                { id = params; mode = PASS_BY_VALUE ; param_type = param_type }\n                                                     }\n\ncomma_id_list: /* nothing */              { fun _ -> [] }\n             | T_comma T_id comma_id_list { fun _ -> (id_make $2) :: $3 () }\n\ndata_type: T_int  { fun _ -> TYPE_int }\n         | T_char { fun _ -> TYPE_char }\n\nbracket_int_const_list: /* nothing */                                        { fun _ -> [] }\n                      | T_lbrack T_int_const T_rbrack bracket_int_const_list { fun _ -> $2 :: $4 () }\n\nret_type: data_type { fun _ -> $1 () }\n        | T_nothing { fun _ -> TYPE_proc }\n\nfpar_type: data_type T_lbrack T_rbrack bracket_int_const_list { fun _ -> let base_type = $1 () in\n                                                                         let dimensions = max_int :: $4 () in\n                                                                         match dimensions with\n                                                                         | [] -> base_type\n                                                                         | _ -> TYPE_array (base_type, dimensions)\n                                                              } \n         | data_type bracket_int_const_list                   { fun _ -> let base_type = $1 () in\n                                                                         let dimensions = $2 () in\n                                                                         match dimensions with\n                                                                         | [] -> base_type\n                                                                         | _ -> TYPE_array (base_type, dimensions)\n                                                              }\n\ngrace_type: data_type bracket_int_const_list { fun _ -> let base_type = $1 () in\n                                                        let dimensions = $2 () in\n                                                        match dimensions with\n                                                        | [] -> base_type\n                                                        | _ -> TYPE_array (base_type, dimensions)\n                                             }\n\nlocal_def: func_def  { $1 }\n         | func_decl { $1 }\n         | var_def   { $1 }\n\nfunc_decl: header T_semicolon { $1 }\n\nvar_def: T_var T_id comma_id_list T_colon grace_type T_semicolon { fun _ -> let vars = (id_make $2) :: $3 () in\n                                                                            let var_type = $5 () in\n                                                                            print_grace_type var_type;\n                                                                            List.iter ( fun var -> ignore(newVariable var var_type true) ) vars; None\n                                                                 }\n\nstmt: T_semicolon                       { fun _ -> None }\n    | l_value T_prod expr T_semicolon   { fun _ -> let (id,l) = $1 () in\n                                                   let value = $3 () in\n                                                   assignToVariable (id_make id) value;\n                                                   None\n                                        }\n    | block                             { $1 }\n    | func_call T_semicolon             { $1 }\n    | T_if cond T_then stmt             { fun _ -> if $2 () then $4 () else None }\n    | T_if cond T_then stmt T_else stmt { fun _ -> if $2 () then $4 () else $6 () }\n    | T_while cond T_do stmt            { fun _ -> while $2 () do ignore($4 ()) done; None }\n    | T_return T_semicolon              { fun _ -> None }\n    | T_return expr T_semicolon         { fun _ -> Some($2 ()) }\n\n\nblock: T_lbrace stmt_list T_rbrace { $2 }\n\nstmt_list: /* nothing */  { fun _ -> None }\n         | stmt stmt_list { fun _ -> let result = $1 () in\n                                     match result with\n                                     | Some _ as returnValue -> returnValue\n                                     | None -> $2 ()\n      }\n\nfunc_call: T_id T_lparen T_rparen                      { fun _ -> let func_name = $1 in\n                                                                  match func_name with \n                                                                  | \"writeInteger\" -> print_string \"WriteInteger\"; None\n                                                                  | \"writeChar\"    -> print_string \"WriteChar\"; None\n                                                                  | \"writeString\"  -> print_string \"WriteString\"; None\n                                                                  | \"readInteger\"  -> print_string \"ReadInteger\"; None\n                                                                  | \"readChar\"     -> print_string \"ReadChar\"; None\n                                                                  | \"readString\"   -> print_string \"ReadString\"; None\n                                                                  | _ -> let func_entry = lookupEntry (id_make func_name) LOOKUP_ALL_SCOPES true in\n                                                                         (match func_entry.entry_info with\n                                                                         | ENTRY_function func_info ->\n                                                                           if List.length func_info.function_paramlist = 0 then\n                                                                             callFunction (id_make func_name) []\n                                                                           else (error \"Incorrect number of arguments for function %a\" pretty_id (id_make func_name); None)\n                                                                         | _ -> (error \"%a is not a function\" pretty_id (id_make func_name); None))\n                                                       }\n         | T_id T_lparen expr comma_expr_list T_rparen { fun _ -> let func_name = $1 in\n                                                                  let args = $3 () :: $4 () in\n                                                                  match func_name with \n                                                                  | \"writeInteger\" -> print_string \"WriteInteger\"; None\n                                                                  | \"writeChar\"    -> print_string \"WriteChar\"; None\n                                                                  | \"writeString\"  -> print_string \"WriteString\"; None\n                                                                  | \"readInteger\"  -> print_string \"ReadInteger\"; None\n                                                                  | \"readChar\"     -> print_string \"ReadChar\"; None\n                                                                  | \"readString\"   -> print_string \"ReadString\"; None\n                                                                  | _ -> let func_entry = lookupEntry (id_make func_name) LOOKUP_ALL_SCOPES true in\n                                                                         (match func_entry.entry_info with\n                                                                         | ENTRY_function func_info ->\n                                                                           if List.length func_info.function_paramlist = List.length args then\n                                                                           callFunction (id_make func_name) args\n                                                                         else\n                                                                           (error \"Incorrect number of arguments for function %a\" pretty_id (id_make func_name); None)\n                                                                         | _ -> (error \"%a is not a function\" pretty_id (id_make func_name); None))\n                                                       }\n\n\ncomma_expr_list: /* nothing */                { fun _ -> [] }\n               | T_comma expr comma_expr_list { fun _ -> $2 () :: $3 () }\n\nl_value: T_id                           { fun _ -> ($1,[]) }\n       | T_string_literal               { fun _ -> ($1,[]) }\n       | l_value T_lbrack expr T_rbrack { fun _ -> let (value, l) = $1 () in\n                                                   match $3 () with \n                                                   | IntValue exp -> (value, exp :: l)\n                                                   | _ -> error \"not an integer\"; (value, [])\n                                        }\n\n\nexpr: T_int_const            { fun _ -> IntValue $1 }\n    | T_char_const           { fun _ -> CharValue $1 }\n    | l_value                { fun _ -> let (value , l) = $1 () in\n                                        MultiArray (createArray l)\n                             }\n    | T_lparen expr T_rparen { $2 }\n    | func_call              { fun _ -> match $1 () with\n                                        | Some value -> value\n                                        | None -> Unit\n                             }\n    | T_plus expr            { fun _ -> match $2 () with \n                                        | IntValue num -> IntValue num\n                                        | _ -> error \"not an integer; +\"; Unit\n                             }\n    | T_minus expr           { fun _ -> match $2 () with \n                                        | IntValue num -> IntValue (- num)\n                                        | _ -> error \"not an integer; -\"; Unit\n                             }    \n    | expr T_plus expr       { fun _ -> match ($1 (), $3 ()) with\n                                        | (IntValue a, IntValue b) -> IntValue (a + b)\n                                        | _ -> error \"not an integer; plus\"; Unit\n                             }\n    | expr T_minus expr      { fun _ -> let val1 = $1 () in\n                                        let val2 = $3 () in\n                                        print_variable_value val1;\n                                        print_variable_value val2;\n                                        match (val1, val2) with\n                                        | (IntValue a, IntValue b) -> IntValue (a - b)\n                                        | (c, d) -> error \"not an integer; minus\"; Unit\n                             }\n    | expr T_times expr      { fun _ -> match ($1 (), $3 ()) with\n                                        | (IntValue a, IntValue b) -> IntValue (a * b)\n                                        | _ -> error \"not an integer; times\"; Unit\n                             }\n    | expr T_div expr        { fun _ -> match ($1 (), $3 ()) with\n                                        | (IntValue a, IntValue b) -> IntValue (a / b)\n                                        | _ -> error \"not an integer; div\"; Unit\n                             }\n    | expr T_mod expr        { fun _ -> match ($1 (), $3 ()) with\n                                        | (IntValue a, IntValue b) -> IntValue (a mod b)\n                                        | _ -> error \"not an integer; mod\"; Unit\n                             }\n \ncond: T_lparen cond T_rparen { $2 }\n    | T_not cond             { fun _ -> not ($2 ()) }\n    | cond T_and cond        { fun _ -> $1 () && $3 () }\n    | cond T_or cond         { fun _ -> $1 () || $3 () }\n    | expr T_eq expr         { fun _ -> $1 () = $3 () }\n    | expr T_hash expr       { fun _ -> $1 () <> $3 () }\n    | expr T_less expr       { fun _ -> $1 () < $3 () }\n    | expr T_more expr       { fun _ -> $1 () > $3 () }\n    | expr T_leq expr        { fun _ -> $1 () <= $3 () }\n    | expr T_geq expr        { fun _ -> $1 () >= $3 () }\n"}]}}
Read message 
{"jsonrpc":"2.0","id":2,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/tsimiho/Desktop/NTUA/ECE/Semester8/%CE%9C%CE%B5%CF%84%CE%B1%CE%B3%CE%BB%CF%89%CF%84%CF%84%CE%B9%CF%83%CF%84%CE%AD%CF%82/compiler/Parser.mly"},"position":{"line":0,"character":0}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0290870666504ms
Sending response {"id": 2, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///Users/tsimiho/Desktop/NTUA/ECE/Semester8/%CE%9C%CE%B5%CF%84%CE%B1%CE%B3%CE%BB%CF%89%CF%84%CF%84%CE%B9%CF%83%CF%84%CE%AD%CF%82/compiler/Symbol.ml","languageId":"reason","version":1,"text":"open Identifier\nopen Error\nopen Types\nopen Narray\n\nmodule H = Hashtbl.Make (\n  struct\n    type t = id\n    let equal = (==)\n    let hash = Hashtbl.hash\n  end\n)\n\ntype pass_mode = PASS_BY_VALUE | PASS_BY_REFERENCE\n\ntype param_status =\n  | PARDEF_COMPLETE\n  | PARDEF_DEFINE\n  | PARDEF_CHECK\n\ntype scope = {\n  sco_parent          : scope option;\n  sco_nesting         : int;\n  mutable sco_entries : entry list;\n  mutable sco_negofs  : int\n}\n\nand variable_value =\n  | IntValue of int\n  | CharValue of char\n  | BoolValue of bool\n  | MultiArray of int multi_array\n  | Unit\n\nand variable_info = {\n  variable_type   : Types.typ;\n  variable_offset : int;\n  (* initialized     : bool; *)\n  mutable value   : variable_value\n}\n\nand function_info = {\n  mutable function_isForward : bool;\n  mutable function_paramlist : entry list;\n  mutable function_redeflist : entry list;\n  mutable function_result    : Types.typ;\n  mutable function_pstatus   : param_status;\n  mutable function_initquad  : int;\n  mutable function_body      : unit -> variable_value option\n}\n\nand parameter_info = {\n  parameter_type           : Types.typ;\n  mutable parameter_offset : int;\n  parameter_mode           : pass_mode\n}\n\nand temporary_info = {\n  temporary_type   : Types.typ;\n  temporary_offset : int\n}\n\nand entry_info = ENTRY_none\n               | ENTRY_variable of variable_info\n               | ENTRY_function of function_info\n               | ENTRY_parameter of parameter_info\n               | ENTRY_temporary of temporary_info\n\nand entry = {\n  entry_id    : Identifier.id;\n  entry_scope : scope\n  entry_info  : entry_info\n}\n\ntype lookup_type = LOOKUP_CURRENT_SCOPE | LOOKUP_ALL_SCOPES\n\nlet start_positive_offset = 8\nlet start_negative_offset = 0\n\nlet the_outer_scope = {\n  sco_parent = None;\n  sco_nesting = 0;\n  sco_entries = [] ;\n  sco_negofs = start_negative_offset\n}\n\nlet no_entry id = {\n  entry_id = id;\n  entry_scope = the_outer_scope;\n  entry_info = ENTRY_none\n}\n\nlet currentScope = ref the_outer_scope\nlet quadNext = ref 1\nlet tempNumber = ref 1\n\nlet tab = ref (H.create 0)\n\nlet initSymbolTable size =\n   tab := H.create size;\n   currentScope := the_outer_scope\n\nlet openScope () =\n  let sco = {\n    sco_parent = Some !currentScope;\n    sco_nesting = !currentScope.sco_nesting + 1;\n    sco_entries = [];\n    sco_negofs = start_negative_offset\n  } in\n  currentScope := sco\n\nlet closeScope () =\n  let sco = !currentScope in\n  let manyentry e = H.remove !tab e.entry_id in\n  List.iter manyentry sco.sco_entries;\n  match sco.sco_parent with\n  | Some scp ->\n      currentScope := scp\n  | None ->\n      internal \"cannot close the outer scope!\"\n\nexception Failure_NewEntry of entry\n\nlet newEntry id inf err =\n  try\n    if err then begin\n      try\n        let e = H.find !tab id in\n        if e.entry_scope.sco_nesting = !currentScope.sco_nesting then\n           raise (Failure_NewEntry e)\n      with Not_found ->\n        ()\n    end;\n    let e = {\n      entry_id = id;\n      entry_scope = !currentScope;\n      entry_info = inf\n    } in\n    H.add !tab id e;\n    !currentScope.sco_entries <- e :: !currentScope.sco_entries;\n    e\n  with Failure_NewEntry e ->\n    error \"duplicate identifier %a\" pretty_id id;\n    e\n\nlet lookupEntry id how err =\n  let scc = !currentScope in\n  let lookup () =\n    match how with\n    | LOOKUP_CURRENT_SCOPE ->\n        let e = H.find !tab id in\n        if e.entry_scope.sco_nesting = scc.sco_nesting then\n          e\n        else\n          raise Not_found\n    | LOOKUP_ALL_SCOPES ->\n        H.find !tab id in\n  if err then\n    try\n      lookup ()\n    with Not_found ->\n      error \"unknown identifier %a (first occurrence)\"\n        pretty_id id;\n      H.add !tab id (no_entry id);\n      raise Exit\n  else\n    lookup ()\n\nlet newVariable id typ err =\n  !currentScope.sco_negofs <- !currentScope.sco_negofs - sizeOfType typ;\n  let size = extractDimensionSizes typ in\n  let inf = {\n    variable_type = typ;\n    variable_offset = !currentScope.sco_negofs;\n    value = match typ with\n            | TYPE_int -> IntValue 0\n            | TYPE_char -> CharValue '0'\n            | _ -> let arr = createArray size in MultiArray arr\n  } in\n  newEntry id (ENTRY_variable inf) err\n\nlet newFunction id err =\n  try\n    let e = lookupEntry id LOOKUP_CURRENT_SCOPE false in\n    match e.entry_info with\n    | ENTRY_function inf when inf.function_isForward ->\n        inf.function_isForward <- false;\n        inf.function_pstatus <- PARDEF_CHECK;\n        inf.function_redeflist <- inf.function_paramlist;\n        e\n    | _ ->\n        if err then\n          error \"duplicate identifier: %a\" pretty_id id;\n          raise Exit\n  with Not_found ->\n    let inf = {\n      function_isForward = false;\n      function_paramlist = [];\n      function_redeflist = [];\n      function_result = TYPE_none;\n      function_pstatus = PARDEF_DEFINE;\n      function_initquad = 0;\n      function_body = fun _ -> None\n    } in\n    newEntry id (ENTRY_function inf) false\n\nlet newParameter id typ mode f err =\n  match f.entry_info with\n  | ENTRY_function inf -> begin\n      match inf.function_pstatus with\n      | PARDEF_DEFINE ->\n          let inf_p = {\n            parameter_type = typ;\n            parameter_offset = 0;\n            parameter_mode = mode\n          } in\n          let e = newEntry id (ENTRY_parameter inf_p) err in\n          inf.function_paramlist <- e :: inf.function_paramlist;\n          e\n      | PARDEF_CHECK -> begin\n          match inf.function_redeflist with\n          | p :: ps -> begin\n              inf.function_redeflist <- ps;\n              match p.entry_info with\n              | ENTRY_parameter inf ->\n                  if not (equalType inf.parameter_type typ) then\n                    error \"Parameter type mismatch in redeclaration \\\n                           of function %a\" pretty_id f.entry_id\n                  else if inf.parameter_mode != mode then\n                    error \"Parameter passing mode mismatch in redeclaration \\\n                           of function %a\" pretty_id f.entry_id\n                  else if p.entry_id != id then\n                    error \"Parameter name mismatch in redeclaration \\\n                           of function %a\" pretty_id f.entry_id\n                  else\n                    H.add !tab id p;\n                  p\n              | _ ->\n                  internal \"I found a parameter that is not a parameter!\";\n                  raise Exit\n            end\n          | [] ->\n              error \"More parameters than expected in redeclaration \\\n                     of function %a\" pretty_id f.entry_id;\n              raise Exit\n        end\n      | PARDEF_COMPLETE ->\n          internal \"Cannot add a parameter to an already defined function\";\n          raise Exit\n    end\n  | _ ->\n      internal \"Cannot add a parameter to a non-function\";\n      raise Exit\n\nlet newTemporary typ =\n  let id = id_make (\"$\" ^ string_of_int !tempNumber) in\n  !currentScope.sco_negofs <- !currentScope.sco_negofs - sizeOfType typ;\n  let inf = {\n    temporary_type = typ;\n    temporary_offset = !currentScope.sco_negofs\n  } in\n  incr tempNumber;\n  newEntry id (ENTRY_temporary inf) false\n\nlet forwardFunction e =\n  match e.entry_info with\n  | ENTRY_function inf ->\n      inf.function_isForward <- true\n  | _ ->\n      internal \"Cannot make a non-function forward\"\n\nlet endFunctionHeader e typ =\n  match e.entry_info with\n  | ENTRY_function inf ->\n      begin\n        match inf.function_pstatus with\n        | PARDEF_COMPLETE ->\n            internal \"Cannot end parameters in an already defined function\"\n        | PARDEF_DEFINE ->\n            inf.function_result <- typ;\n            let offset = ref start_positive_offset in\n            let fix_offset e =\n              match e.entry_info with\n              | ENTRY_parameter inf ->\n                  inf.parameter_offset <- !offset;\n                  let size =\n                    match inf.parameter_mode with\n                    | PASS_BY_VALUE     -> sizeOfType inf.parameter_type\n                    | PASS_BY_REFERENCE -> 2 in\n                  offset := !offset + size\n              | _ ->\n                  internal \"Cannot fix offset to a non parameter\" in\n            List.iter fix_offset inf.function_paramlist;\n            inf.function_paramlist <- List.rev inf.function_paramlist\n        | PARDEF_CHECK ->\n            if inf.function_redeflist <> [] then\n              error \"Fewer parameters than expected in redeclaration \\\n                     of function %a\" pretty_id e.entry_id;\n            if not (equalType inf.function_result typ) then\n              error \"Result type mismatch in redeclaration of function %a\"\n                    pretty_id e.entry_id;\n      end;\n      inf.function_pstatus <- PARDEF_COMPLETE\n  | _ ->\n      internal \"Cannot end parameters in a non-function\"\n\nlet assignToVariable (id: Identifier.id) (expr_val: variable_value) = \n  try\n    let variable_entry = lookupEntry id LOOKUP_CURRENT_SCOPE true in\n    match variable_entry.entry_info with \n    | ENTRY_variable v -> v.value <- expr_val\n    | _ -> error \"not a variable\"\n  with Not_found -> error \"Variable %a not found\" pretty_id id\n"}}}
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/tsimiho/Desktop/NTUA/ECE/Semester8/%CE%9C%CE%B5%CF%84%CE%B1%CE%B3%CE%BB%CF%89%CF%84%CF%84%CE%B9%CF%83%CF%84%CE%AD%CF%82/compiler/Symbol.ml","version":2},"contentChanges":[{"text":"open Identifier\nopen Error\nopen Types\nopen Narray\n\nmodule H = Hashtbl.Make (\n  struct\n    type t = id\n    let equal = (==)\n    let hash = Hashtbl.hash\n  end\n)\n\ntype pass_mode = PASS_BY_VALUE | PASS_BY_REFERENCE\n\ntype param_status =\n  | PARDEF_COMPLETE\n  | PARDEF_DEFINE\n  | PARDEF_CHECK\n\ntype scope = {\n  sco_parent          : scope option;\n  sco_nesting         : int;\n  mutable sco_entries : entry list;\n  mutable sco_negofs  : int\n}\n\nand variable_value =\n  | IntValue of int\n  | CharValue of char\n  | BoolValue of bool\n  | MultiArray of int multi_array\n  | Unit\n\nand variable_info = {\n  variable_type   : Types.typ;\n  variable_offset : int;\n  (* initialized     : bool; *)\n  mutable value   : variable_value\n}\n\nand function_info = {\n  mutable function_isForward : bool;\n  mutable function_paramlist : entry list;\n  mutable function_redeflist : entry list;\n  mutable function_result    : Types.typ;\n  mutable function_pstatus   : param_status;\n  mutable function_initquad  : int;\n  mutable function_body      : unit -> variable_value option\n}\n\nand parameter_info = {\n  parameter_type           : Types.typ;\n  mutable parameter_offset : int;\n  parameter_mode           : pass_mode\n}\n\nand temporary_info = {\n  temporary_type   : Types.typ;\n  temporary_offset : int\n}\n\nand entry_info = ENTRY_none\n               | ENTRY_variable of variable_info\n               | ENTRY_function of function_info\n               | ENTRY_parameter of parameter_info\n               | ENTRY_temporary of temporary_info\n\nand entry = {\n  entry_id    : Identifier.id;\n  entry_scope : scope\n  entry_info  : entry_info\n}\n\ntype lookup_type = LOOKUP_CURRENT_SCOPE | LOOKUP_ALL_SCOPES\n\nlet start_positive_offset = 8\nlet start_negative_offset = 0\n\nlet the_outer_scope = {\n  sco_parent = None;\n  sco_nesting = 0;\n  sco_entries = [] ;\n  sco_negofs = start_negative_offset\n}\n\nlet no_entry id = {\n  entry_id = id;\n  entry_scope = the_outer_scope;\n  entry_info = ENTRY_none\n}\n\nlet currentScope = ref the_outer_scope\nlet quadNext = ref 1\nlet tempNumber = ref 1\n\nlet tab = ref (H.create 0)\n\nlet initSymbolTable size =\n   tab := H.create size;\n   currentScope := the_outer_scope\n\nlet openScope () =\n  let sco = {\n    sco_parent = Some !currentScope;\n    sco_nesting = !currentScope.sco_nesting + 1;\n    sco_entries = [];\n    sco_negofs = start_negative_offset\n  } in\n  currentScope := sco\n\nlet closeScope () =\n  let sco = !currentScope in\n  let manyentry e = H.remove !tab e.entry_id in\n  List.iter manyentry sco.sco_entries;\n  match sco.sco_parent with\n  | Some scp ->\n      currentScope := scp\n  | None ->\n      internal \"cannot close the outer scope!\"\n\nexception Failure_NewEntry of entry\n\nlet newEntry id inf err =\n  try\n    if err then begin\n      try\n        let e = H.find !tab id in\n        if e.entry_scope.sco_nesting = !currentScope.sco_nesting then\n           raise (Failure_NewEntry e)\n      with Not_found ->\n        ()\n    end;\n    let e = {\n      entry_id = id;\n      entry_scope = !currentScope;\n      entry_info = inf\n    } in\n    H.add !tab id e;\n    !currentScope.sco_entries <- e :: !currentScope.sco_entries;\n    e\n  with Failure_NewEntry e ->\n    error \"duplicate identifier %a\" pretty_id id;\n    e\n\nlet lookupEntry id how err =\n  let scc = !currentScope in\n  let lookup () =\n    match how with\n    | LOOKUP_CURRENT_SCOPE ->\n        let e = H.find !tab id in\n        if e.entry_scope.sco_nesting = scc.sco_nesting then\n          e\n        else\n          raise Not_found\n    | LOOKUP_ALL_SCOPES ->\n        H.find !tab id in\n  if err then\n    try\n      lookup ()\n    with Not_found ->\n      error \"unknown identifier %a (first occurrence)\"\n        pretty_id id;\n      H.add !tab id (no_entry id);\n      raise Exit\n  else\n    lookup ()\n\nlet newVariable id typ err =\n  !currentScope.sco_negofs <- !currentScope.sco_negofs - sizeOfType typ;\n  let size = extractDimensionSizes typ in\n  let inf = {\n    variable_type = typ;\n    variable_offset = !currentScope.sco_negofs;\n    value = match typ with\n            | TYPE_int -> IntValue 0\n            | TYPE_char -> CharValue '0'\n            | _ -> let arr = createArray size in MultiArray arr\n  } in\n  newEntry id (ENTRY_variable inf) err\n\nlet newFunction id err =\n  try\n    let e = lookupEntry id LOOKUP_CURRENT_SCOPE false in\n    match e.entry_info with\n    | ENTRY_function inf when inf.function_isForward ->\n        inf.function_isForward <- false;\n        inf.function_pstatus <- PARDEF_CHECK;\n        inf.function_redeflist <- inf.function_paramlist;\n        e\n    | _ ->\n        if err then\n          error \"duplicate identifier: %a\" pretty_id id;\n          raise Exit\n  with Not_found ->\n    let inf = {\n      function_isForward = false;\n      function_paramlist = [];\n      function_redeflist = [];\n      function_result = TYPE_none;\n      function_pstatus = PARDEF_DEFINE;\n      function_initquad = 0;\n      function_body = fun _ -> None\n    } in\n    newEntry id (ENTRY_function inf) false\n\nlet newParameter id typ mode f err =\n  match f.entry_info with\n  | ENTRY_function inf -> begin\n      match inf.function_pstatus with\n      | PARDEF_DEFINE ->\n          let inf_p = {\n            parameter_type = typ;\n            parameter_offset = 0;\n            parameter_mode = mode\n          } in\n          let e = newEntry id (ENTRY_parameter inf_p) err in\n          inf.function_paramlist <- e :: inf.function_paramlist;\n          e\n      | PARDEF_CHECK -> begin\n          match inf.function_redeflist with\n          | p :: ps -> begin\n              inf.function_redeflist <- ps;\n              match p.entry_info with\n              | ENTRY_parameter inf ->\n                  if not (equalType inf.parameter_type typ) then\n                    error \"Parameter type mismatch in redeclaration \\\n                           of function %a\" pretty_id f.entry_id\n                  else if inf.parameter_mode != mode then\n                    error \"Parameter passing mode mismatch in redeclaration \\\n                           of function %a\" pretty_id f.entry_id\n                  else if p.entry_id != id then\n                    error \"Parameter name mismatch in redeclaration \\\n                           of function %a\" pretty_id f.entry_id\n                  else\n                    H.add !tab id p;\n                  p\n              | _ ->\n                  internal \"I found a parameter that is not a parameter!\";\n                  raise Exit\n            end\n          | [] ->\n              error \"More parameters than expected in redeclaration \\\n                     of function %a\" pretty_id f.entry_id;\n              raise Exit\n        end\n      | PARDEF_COMPLETE ->\n          internal \"Cannot add a parameter to an already defined function\";\n          raise Exit\n    end\n  | _ ->\n      internal \"Cannot add a parameter to a non-function\";\n      raise Exit\n\nlet newTemporary typ =\n  let id = id_make (\"$\" ^ string_of_int !tempNumber) in\n  !currentScope.sco_negofs <- !currentScope.sco_negofs - sizeOfType typ;\n  let inf = {\n    temporary_type = typ;\n    temporary_offset = !currentScope.sco_negofs\n  } in\n  incr tempNumber;\n  newEntry id (ENTRY_temporary inf) false\n\nlet forwardFunction e =\n  match e.entry_info with\n  | ENTRY_function inf ->\n      inf.function_isForward <- true\n  | _ ->\n      internal \"Cannot make a non-function forward\"\n\nlet endFunctionHeader e typ =\n  match e.entry_info with\n  | ENTRY_function inf ->\n      begin\n        match inf.function_pstatus with\n        | PARDEF_COMPLETE ->\n            internal \"Cannot end parameters in an already defined function\"\n        | PARDEF_DEFINE ->\n            inf.function_result <- typ;\n            let offset = ref start_positive_offset in\n            let fix_offset e =\n              match e.entry_info with\n              | ENTRY_parameter inf ->\n                  inf.parameter_offset <- !offset;\n                  let size =\n                    match inf.parameter_mode with\n                    | PASS_BY_VALUE     -> sizeOfType inf.parameter_type\n                    | PASS_BY_REFERENCE -> 2 in\n                  offset := !offset + size\n              | _ ->\n                  internal \"Cannot fix offset to a non parameter\" in\n            List.iter fix_offset inf.function_paramlist;\n            inf.function_paramlist <- List.rev inf.function_paramlist\n        | PARDEF_CHECK ->\n            if inf.function_redeflist <> [] then\n              error \"Fewer parameters than expected in redeclaration \\\n                     of function %a\" pretty_id e.entry_id;\n            if not (equalType inf.function_result typ) then\n              error \"Result type mismatch in redeclaration of function %a\"\n                    pretty_id e.entry_id;\n      end;\n      inf.function_pstatus <- PARDEF_COMPLETE\n  | _ ->\n      internal \"Cannot end parameters in a non-function\"\n\nlet assignToVariable (id: Identifier.id) (expr_val: variable_value) = \n  try\n    let variable_entry = lookupEntry id LOOKUP_CURRENT_SCOPE true in\n    match variable_entry.entry_info with \n    | ENTRY_variable v -> v.value <- expr_val\n    | _ -> error \"not a variable\"\n  with Not_found -> error \"Variable %a not found\" pretty_id id\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/tsimiho/Desktop/NTUA/ECE/Semester8/%CE%9C%CE%B5%CF%84%CE%B1%CE%B3%CE%BB%CF%89%CF%84%CF%84%CE%B9%CF%83%CF%84%CE%AD%CF%82/compiler/Symbol.ml","version":3},"contentChanges":[{"text":"open Identifier\nopen Error\nopen Types\nopen Narray\n\nmodule H = Hashtbl.Make (\n  struct\n    type t = id\n    let equal = (==)\n    let hash = Hashtbl.hash\n  end\n)\n\ntype pass_mode = PASS_BY_VALUE | PASS_BY_REFERENCE\n\ntype param_status =\n  | PARDEF_COMPLETE\n  | PARDEF_DEFINE\n  | PARDEF_CHECK\n\ntype scope = {\n  sco_parent          : scope option;\n  sco_nesting         : int;\n  mutable sco_entries : entry list;\n  mutable sco_negofs  : int\n}\n\nand variable_value =\n  | IntValue of int\n  | CharValue of char\n  | BoolValue of bool\n  | MultiArray of int multi_array\n  | Unit\n\nand variable_info = {\n  variable_type   : Types.typ;\n  variable_offset : int;\n  (* initialized     : bool; *)\n  mutable value   : variable_value\n}\n\nand function_info = {\n  mutable function_isForward : bool;\n  mutable function_paramlist : entry list;\n  mutable function_redeflist : entry list;\n  mutable function_result    : Types.typ;\n  mutable function_pstatus   : param_status;\n  mutable function_initquad  : int;\n  mutable function_body      : unit -> variable_value option\n}\n\nand parameter_info = {\n  parameter_type           : Types.typ;\n  mutable parameter_offset : int;\n  parameter_mode           : pass_mode\n}\n\nand temporary_info = {\n  temporary_type   : Types.typ;\n  temporary_offset : int\n}\n\nand entry_info = ENTRY_none\n               | ENTRY_variable of variable_info\n               | ENTRY_function of function_info\n               | ENTRY_parameter of parameter_info\n               | ENTRY_temporary of temporary_info\n\nand entry = {\n  entry_id    : Identifier.id;\n  entry_scope : scope\n  entry_info  : entry_info\n}\n\ntype lookup_type = LOOKUP_CURRENT_SCOPE | LOOKUP_ALL_SCOPES\n\nlet start_positive_offset = 8\nlet start_negative_offset = 0\n\nlet the_outer_scope = {\n  sco_parent = None;\n  sco_nesting = 0;\n  sco_entries = [] ;\n  sco_negofs = start_negative_offset\n}\n\nlet no_entry id = {\n  entry_id = id;\n  entry_scope = the_outer_scope;\n  entry_info = ENTRY_none\n}\n\nlet currentScope = ref the_outer_scope\nlet quadNext = ref 1\nlet tempNumber = ref 1\n\nlet tab = ref (H.create 0)\n\nlet initSymbolTable size =\n   tab := H.create size;\n   currentScope := the_outer_scope\n\nlet openScope () =\n  let sco = {\n    sco_parent = Some !currentScope;\n    sco_nesting = !currentScope.sco_nesting + 1;\n    sco_entries = [];\n    sco_negofs = start_negative_offset\n  } in\n  currentScope := sco\n\nlet closeScope () =\n  let sco = !currentScope in\n  let manyentry e = H.remove !tab e.entry_id in\n  List.iter manyentry sco.sco_entries;\n  match sco.sco_parent with\n  | Some scp ->\n      currentScope := scp\n  | None ->\n      internal \"cannot close the outer scope!\"\n\nexception Failure_NewEntry of entry\n\nlet newEntry id inf err =\n  try\n    if err then begin\n      try\n        let e = H.find !tab id in\n        if e.entry_scope.sco_nesting = !currentScope.sco_nesting then\n           raise (Failure_NewEntry e)\n      with Not_found ->\n        ()\n    end;\n    let e = {\n      entry_id = id;\n      entry_scope = !currentScope;\n      entry_info = inf\n    } in\n    H.add !tab id e;\n    !currentScope.sco_entries <- e :: !currentScope.sco_entries;\n    e\n  with Failure_NewEntry e ->\n    error \"duplicate identifier %a\" pretty_id id;\n    e\n\nlet lookupEntry id how err =\n  let scc = !currentScope in\n  let lookup () =\n    match how with\n    | LOOKUP_CURRENT_SCOPE ->\n        let e = H.find !tab id in\n        if e.entry_scope.sco_nesting = scc.sco_nesting then\n          e\n        else\n          raise Not_found\n    | LOOKUP_ALL_SCOPES ->\n        H.find !tab id in\n  if err then\n    try\n      lookup ()\n    with Not_found ->\n      error \"unknown identifier %a (first occurrence)\"\n        pretty_id id;\n      H.add !tab id (no_entry id);\n      raise Exit\n  else\n    lookup ()\n\nlet newVariable id typ err =\n  !currentScope.sco_negofs <- !currentScope.sco_negofs - sizeOfType typ;\n  let size = extractDimensionSizes typ in\n  let inf = {\n    variable_type = typ;\n    variable_offset = !currentScope.sco_negofs;\n    value = match typ with\n            | TYPE_int -> IntValue 0\n            | TYPE_char -> CharValue '0'\n            | _ -> let arr = createArray size in MultiArray arr\n  } in\n  newEntry id (ENTRY_variable inf) err\n\nlet newFunction id err =\n  try\n    let e = lookupEntry id LOOKUP_CURRENT_SCOPE false in\n    match e.entry_info with\n    | ENTRY_function inf when inf.function_isForward ->\n        inf.function_isForward <- false;\n        inf.function_pstatus <- PARDEF_CHECK;\n        inf.function_redeflist <- inf.function_paramlist;\n        e\n    | _ ->\n        if err then\n          error \"duplicate identifier: %a\" pretty_id id;\n          raise Exit\n  with Not_found ->\n    let inf = {\n      function_isForward = false;\n      function_paramlist = [];\n      function_redeflist = [];\n      function_result = TYPE_none;\n      function_pstatus = PARDEF_DEFINE;\n      function_initquad = 0;\n      function_body = fun _ -> None\n    } in\n    newEntry id (ENTRY_function inf) false\n\nlet newParameter id typ mode f err =\n  match f.entry_info with\n  | ENTRY_function inf -> begin\n      match inf.function_pstatus with\n      | PARDEF_DEFINE ->\n          let inf_p = {\n            parameter_type = typ;\n            parameter_offset = 0;\n            parameter_mode = mode\n          } in\n          let e = newEntry id (ENTRY_parameter inf_p) err in\n          inf.function_paramlist <- e :: inf.function_paramlist;\n          e\n      | PARDEF_CHECK -> begin\n          match inf.function_redeflist with\n          | p :: ps -> begin\n              inf.function_redeflist <- ps;\n              match p.entry_info with\n              | ENTRY_parameter inf ->\n                  if not (equalType inf.parameter_type typ) then\n                    error \"Parameter type mismatch in redeclaration \\\n                           of function %a\" pretty_id f.entry_id\n                  else if inf.parameter_mode != mode then\n                    error \"Parameter passing mode mismatch in redeclaration \\\n                           of function %a\" pretty_id f.entry_id\n                  else if p.entry_id != id then\n                    error \"Parameter name mismatch in redeclaration \\\n                           of function %a\" pretty_id f.entry_id\n                  else\n                    H.add !tab id p;\n                  p\n              | _ ->\n                  internal \"I found a parameter that is not a parameter!\";\n                  raise Exit\n            end\n          | [] ->\n              error \"More parameters than expected in redeclaration \\\n                     of function %a\" pretty_id f.entry_id;\n              raise Exit\n        end\n      | PARDEF_COMPLETE ->\n          internal \"Cannot add a parameter to an already defined function\";\n          raise Exit\n    end\n  | _ ->\n      internal \"Cannot add a parameter to a non-function\";\n      raise Exit\n\nlet newTemporary typ =\n  let id = id_make (\"$\" ^ string_of_int !tempNumber) in\n  !currentScope.sco_negofs <- !currentScope.sco_negofs - sizeOfType typ;\n  let inf = {\n    temporary_type = typ;\n    temporary_offset = !currentScope.sco_negofs\n  } in\n  incr tempNumber;\n  newEntry id (ENTRY_temporary inf) false\n\nlet forwardFunction e =\n  match e.entry_info with\n  | ENTRY_function inf ->\n      inf.function_isForward <- true\n  | _ ->\n      internal \"Cannot make a non-function forward\"\n\nlet endFunctionHeader e typ =\n  match e.entry_info with\n  | ENTRY_function inf ->\n      begin\n        match inf.function_pstatus with\n        | PARDEF_COMPLETE ->\n            internal \"Cannot end parameters in an already defined function\"\n        | PARDEF_DEFINE ->\n            inf.function_result <- typ;\n            let offset = ref start_positive_offset in\n            let fix_offset e =\n              match e.entry_info with\n              | ENTRY_parameter inf ->\n                  inf.parameter_offset <- !offset;\n                  let size =\n                    match inf.parameter_mode with\n                    | PASS_BY_VALUE     -> sizeOfType inf.parameter_type\n                    | PASS_BY_REFERENCE -> 2 in\n                  offset := !offset + size\n              | _ ->\n                  internal \"Cannot fix offset to a non parameter\" in\n            List.iter fix_offset inf.function_paramlist;\n            inf.function_paramlist <- List.rev inf.function_paramlist\n        | PARDEF_CHECK ->\n            if inf.function_redeflist <> [] then\n              error \"Fewer parameters than expected in redeclaration \\\n                     of function %a\" pretty_id e.entry_id;\n            if not (equalType inf.function_result typ) then\n              error \"Result type mismatch in redeclaration of function %a\"\n                    pretty_id e.entry_id;\n      end;\n      inf.function_pstatus <- PARDEF_COMPLETE\n  | _ ->\n      internal \"Cannot end parameters in a non-function\"\n\nlet assignToVariable (id: Identifier.id) (expr_val: variable_value) = \n  try\n    let variable_entry = lookupEntry id LOOKUP_CURRENT_SCOPE true in\n    match variable_entry.entry_info with \n    | ENTRY_variable v -> v.value <- expr_val\n    | _ -> error \"not a variable\"\n  with Not_found -> error \"Variable %a not found\" pretty_id id\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/tsimiho/Desktop/NTUA/ECE/Semester8/%CE%9C%CE%B5%CF%84%CE%B1%CE%B3%CE%BB%CF%89%CF%84%CF%84%CE%B9%CF%83%CF%84%CE%AD%CF%82/compiler/Symbol.ml","version":4},"contentChanges":[{"text":"open Identifier\nopen Error\nopen Types\nopen Narray\n\nmodule H = Hashtbl.Make (\n  struct\n    type t = id\n    let equal = (==)\n    let hash = Hashtbl.hash\n  end\n)\n\ntype pass_mode = PASS_BY_VALUE | PASS_BY_REFERENCE\n\ntype param_status =\n  | PARDEF_COMPLETE\n  | PARDEF_DEFINE\n  | PARDEF_CHECK\n\ntype scope = {\n  sco_parent          : scope option;\n  sco_nesting         : int;\n  mutable sco_entries : entry list;\n  mutable sco_negofs  : int\n}\n\nand variable_value =\n  | IntValue of int\n  | CharValue of char\n  | BoolValue of bool\n  | MultiArray of int multi_array\n  | Unit\n\nand variable_info = {\n  variable_type   : Types.typ;\n  variable_offset : int;\n  (* initialized     : bool; *)\n  mutable value   : variable_value\n}\n\nand function_info = {\n  mutable function_isForward : bool;\n  mutable function_paramlist : entry list;\n  mutable function_redeflist : entry list;\n  mutable function_result    : Types.typ;\n  mutable function_pstatus   : param_status;\n  mutable function_initquad  : int;\n  mutable function_body      : unit -> variable_value option\n}\n\nand parameter_info = {\n  parameter_type           : Types.typ;\n  mutable parameter_offset : int;\n  parameter_mode           : pass_mode\n}\n\nand temporary_info = {\n  temporary_type   : Types.typ;\n  temporary_offset : int\n}\n\nand entry_info = ENTRY_none\n               | ENTRY_variable of variable_info\n               | ENTRY_function of function_info\n               | ENTRY_parameter of parameter_info\n               | ENTRY_temporary of temporary_info\n\nand entry = {\n  entry_id    : Identifier.id;\n  entry_scope : scope\n  entry_info  : entry_info\n}\n\ntype lookup_type = LOOKUP_CURRENT_SCOPE | LOOKUP_ALL_SCOPES\n\nlet start_positive_offset = 8\nlet start_negative_offset = 0\n\nlet the_outer_scope = {\n  sco_parent = None;\n  sco_nesting = 0;\n  sco_entries = [] ;\n  sco_negofs = start_negative_offset\n}\n\nlet no_entry id = {\n  entry_id = id;\n  entry_scope = the_outer_scope;\n  entry_info = ENTRY_none\n}\n\nlet currentScope = ref the_outer_scope\nlet quadNext = ref 1\nlet tempNumber = ref 1\n\nlet tab = ref (H.create 0)\n\nlet initSymbolTable size =\n   tab := H.create size;\n   currentScope := the_outer_scope\n\nlet openScope () =\n  let sco = {\n    sco_parent = Some !currentScope;\n    sco_nesting = !currentScope.sco_nesting + 1;\n    sco_entries = [];\n    sco_negofs = start_negative_offset\n  } in\n  currentScope := sco\n\nlet closeScope () =\n  let sco = !currentScope in\n  let manyentry e = H.remove !tab e.entry_id in\n  List.iter manyentry sco.sco_entries;\n  match sco.sco_parent with\n  | Some scp ->\n      currentScope := scp\n  | None ->\n      internal \"cannot close the outer scope!\"\n\nexception Failure_NewEntry of entry\n\nlet newEntry id inf err =\n  try\n    if err then begin\n      try\n        let e = H.find !tab id in\n        if e.entry_scope.sco_nesting = !currentScope.sco_nesting then\n           raise (Failure_NewEntry e)\n      with Not_found ->\n        ()\n    end;\n    let e = {\n      entry_id = id;\n      entry_scope = !currentScope;\n      entry_info = inf\n    } in\n    H.add !tab id e;\n    !currentScope.sco_entries <- e :: !currentScope.sco_entries;\n    e\n  with Failure_NewEntry e ->\n    error \"duplicate identifier %a\" pretty_id id;\n    e\n\nlet lookupEntry id how err =\n  let scc = !currentScope in\n  let lookup () =\n    match how with\n    | LOOKUP_CURRENT_SCOPE ->\n        let e = H.find !tab id in\n        if e.entry_scope.sco_nesting = scc.sco_nesting then\n          e\n        else\n          raise Not_found\n    | LOOKUP_ALL_SCOPES ->\n        H.find !tab id in\n  if err then\n    try\n      lookup ()\n    with Not_found ->\n      error \"unknown identifier %a (first occurrence)\"\n        pretty_id id;\n      H.add !tab id (no_entry id);\n      raise Exit\n  else\n    lookup ()\n\nlet newVariable id typ err =\n  !currentScope.sco_negofs <- !currentScope.sco_negofs - sizeOfType typ;\n  let size = extractDimensionSizes typ in\n  let inf = {\n    variable_type = typ;\n    variable_offset = !currentScope.sco_negofs;\n    value = match typ with\n            | TYPE_int -> IntValue 0\n            | TYPE_char -> CharValue '0'\n            | _ -> let arr = createArray size in MultiArray arr\n  } in\n  newEntry id (ENTRY_variable inf) err\n\nlet newFunction id err =\n  try\n    let e = lookupEntry id LOOKUP_CURRENT_SCOPE false in\n    match e.entry_info with\n    | ENTRY_function inf when inf.function_isForward ->\n        inf.function_isForward <- false;\n        inf.function_pstatus <- PARDEF_CHECK;\n        inf.function_redeflist <- inf.function_paramlist;\n        e\n    | _ ->\n        if err then\n          error \"duplicate identifier: %a\" pretty_id id;\n          raise Exit\n  with Not_found ->\n    let inf = {\n      function_isForward = false;\n      function_paramlist = [];\n      function_redeflist = [];\n      function_result = TYPE_none;\n      function_pstatus = PARDEF_DEFINE;\n      function_initquad = 0;\n      function_body = fun _ -> None\n    } in\n    newEntry id (ENTRY_function inf) false\n\nlet newParameter id typ mode f err =\n  match f.entry_info with\n  | ENTRY_function inf -> begin\n      match inf.function_pstatus with\n      | PARDEF_DEFINE ->\n          let inf_p = {\n            parameter_type = typ;\n            parameter_offset = 0;\n            parameter_mode = mode\n          } in\n          let e = newEntry id (ENTRY_parameter inf_p) err in\n          inf.function_paramlist <- e :: inf.function_paramlist;\n          e\n      | PARDEF_CHECK -> begin\n          match inf.function_redeflist with\n          | p :: ps -> begin\n              inf.function_redeflist <- ps;\n              match p.entry_info with\n              | ENTRY_parameter inf ->\n                  if not (equalType inf.parameter_type typ) then\n                    error \"Parameter type mismatch in redeclaration \\\n                           of function %a\" pretty_id f.entry_id\n                  else if inf.parameter_mode != mode then\n                    error \"Parameter passing mode mismatch in redeclaration \\\n                           of function %a\" pretty_id f.entry_id\n                  else if p.entry_id != id then\n                    error \"Parameter name mismatch in redeclaration \\\n                           of function %a\" pretty_id f.entry_id\n                  else\n                    H.add !tab id p;\n                  p\n              | _ ->\n                  internal \"I found a parameter that is not a parameter!\";\n                  raise Exit\n            end\n          | [] ->\n              error \"More parameters than expected in redeclaration \\\n                     of function %a\" pretty_id f.entry_id;\n              raise Exit\n        end\n      | PARDEF_COMPLETE ->\n          internal \"Cannot add a parameter to an already defined function\";\n          raise Exit\n    end\n  | _ ->\n      internal \"Cannot add a parameter to a non-function\";\n      raise Exit\n\nlet newTemporary typ =\n  let id = id_make (\"$\" ^ string_of_int !tempNumber) in\n  !currentScope.sco_negofs <- !currentScope.sco_negofs - sizeOfType typ;\n  let inf = {\n    temporary_type = typ;\n    temporary_offset = !currentScope.sco_negofs\n  } in\n  incr tempNumber;\n  newEntry id (ENTRY_temporary inf) false\n\nlet forwardFunction e =\n  match e.entry_info with\n  | ENTRY_function inf ->\n      inf.function_isForward <- true\n  | _ ->\n      internal \"Cannot make a non-function forward\"\n\nlet endFunctionHeader e typ =\n  match e.entry_info with\n  | ENTRY_function inf ->\n      begin\n        match inf.function_pstatus with\n        | PARDEF_COMPLETE ->\n            internal \"Cannot end parameters in an already defined function\"\n        | PARDEF_DEFINE ->\n            inf.function_result <- typ;\n            let offset = ref start_positive_offset in\n            let fix_offset e =\n              match e.entry_info with\n              | ENTRY_parameter inf ->\n                  inf.parameter_offset <- !offset;\n                  let size =\n                    match inf.parameter_mode with\n                    | PASS_BY_VALUE     -> sizeOfType inf.parameter_type\n                    | PASS_BY_REFERENCE -> 2 in\n                  offset := !offset + size\n              | _ ->\n                  internal \"Cannot fix offset to a non parameter\" in\n            List.iter fix_offset inf.function_paramlist;\n            inf.function_paramlist <- List.rev inf.function_paramlist\n        | PARDEF_CHECK ->\n            if inf.function_redeflist <> [] then\n              error \"Fewer parameters than expected in redeclaration \\\n                     of function %a\" pretty_id e.entry_id;\n            if not (equalType inf.function_result typ) then\n              error \"Result type mismatch in redeclaration of function %a\"\n                    pretty_id e.entry_id;\n      end;\n      inf.function_pstatus <- PARDEF_COMPLETE\n  | _ ->\n      internal \"Cannot end parameters in a non-function\"\n\nlet assignToVariable (id: Identifier.id) (expr_val: variable_value) = \n  try\n    let variable_entry = lookupEntry id LOOKUP_CURRENT_SCOPE true in\n    match variable_entry.entry_info with \n    | ENTRY_variable v -> v.value <- expr_val\n    | _ -> error \"not a variable\"\n  with Not_found -> error \"Variable %a not found\" pretty_id id\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/tsimiho/Desktop/NTUA/ECE/Semester8/%CE%9C%CE%B5%CF%84%CE%B1%CE%B3%CE%BB%CF%89%CF%84%CF%84%CE%B9%CF%83%CF%84%CE%AD%CF%82/compiler/Symbol.ml","version":5},"contentChanges":[{"text":"open Identifier\nopen Error\nopen Types\nopen Narray\n\nmodule H = Hashtbl.Make (\n  struct\n    type t = id\n    let equal = (==)\n    let hash = Hashtbl.hash\n  end\n)\n\ntype pass_mode = PASS_BY_VALUE | PASS_BY_REFERENCE\n\ntype param_status =\n  | PARDEF_COMPLETE\n  | PARDEF_DEFINE\n  | PARDEF_CHECK\n\ntype scope = {\n  sco_parent          : scope option;\n  sco_nesting         : int;\n  mutable sco_entries : entry list;\n  mutable sco_negofs  : int\n}\n\nand variable_value =\n  | IntValue of int\n  | CharValue of char\n  | BoolValue of bool\n  | MultiArray of int multi_array\n  | Unit\n\nand variable_info = {\n  variable_type   : Types.typ;\n  variable_offset : int;\n  (* initialized     : bool; *)\n  mutable value   : variable_value\n}\n\nand function_info = {\n  mutable function_isForward : bool;\n  mutable function_paramlist : entry list;\n  mutable function_redeflist : entry list;\n  mutable function_result    : Types.typ;\n  mutable function_pstatus   : param_status;\n  mutable function_initquad  : int;\n  mutable function_body      : unit -> variable_value option\n}\n\nand parameter_info = {\n  parameter_type           : Types.typ;\n  mutable parameter_offset : int;\n  parameter_mode           : pass_mode\n}\n\nand temporary_info = {\n  temporary_type   : Types.typ;\n  temporary_offset : int\n}\n\nand entry_info = ENTRY_none\n               | ENTRY_variable of variable_info\n               | ENTRY_function of function_info\n               | ENTRY_parameter of parameter_info\n               | ENTRY_temporary of temporary_info\n\nand entry = {\n  entry_id    : Identifier.id;\n  entry_scope : scope\n  entry_info  : entry_info\n}\n\ntype lookup_type = LOOKUP_CURRENT_SCOPE | LOOKUP_ALL_SCOPES\n\nlet start_positive_offset = 8\nlet start_negative_offset = 0\n\nlet the_outer_scope = {\n  sco_parent = None;\n  sco_nesting = 0;\n  sco_entries = [] ;\n  sco_negofs = start_negative_offset\n}\n\nlet no_entry id = {\n  entry_id = id;\n  entry_scope = the_outer_scope;\n  entry_info = ENTRY_none\n}\n\nlet currentScope = ref the_outer_scope\nlet quadNext = ref 1\nlet tempNumber = ref 1\n\nlet tab = ref (H.create 0)\n\nlet initSymbolTable size =\n   tab := H.create size;\n   currentScope := the_outer_scope\n\nlet openScope () =\n  let sco = {\n    sco_parent = Some !currentScope;\n    sco_nesting = !currentScope.sco_nesting + 1;\n    sco_entries = [];\n    sco_negofs = start_negative_offset\n  } in\n  currentScope := sco\n\nlet closeScope () =\n  let sco = !currentScope in\n  let manyentry e = H.remove !tab e.entry_id in\n  List.iter manyentry sco.sco_entries;\n  match sco.sco_parent with\n  | Some scp ->\n      currentScope := scp\n  | None ->\n      internal \"cannot close the outer scope!\"\n\nexception Failure_NewEntry of entry\n\nlet newEntry id inf err =\n  try\n    if err then begin\n      try\n        let e = H.find !tab id in\n        if e.entry_scope.sco_nesting = !currentScope.sco_nesting then\n           raise (Failure_NewEntry e)\n      with Not_found ->\n        ()\n    end;\n    let e = {\n      entry_id = id;\n      entry_scope = !currentScope;\n      entry_info = inf\n    } in\n    H.add !tab id e;\n    !currentScope.sco_entries <- e :: !currentScope.sco_entries;\n    e\n  with Failure_NewEntry e ->\n    error \"duplicate identifier %a\" pretty_id id;\n    e\n\nlet lookupEntry id how err =\n  let scc = !currentScope in\n  let lookup () =\n    match how with\n    | LOOKUP_CURRENT_SCOPE ->\n        let e = H.find !tab id in\n        if e.entry_scope.sco_nesting = scc.sco_nesting then\n          e\n        else\n          raise Not_found\n    | LOOKUP_ALL_SCOPES ->\n        H.find !tab id in\n  if err then\n    try\n      lookup ()\n    with Not_found ->\n      error \"unknown identifier %a (first occurrence)\"\n        pretty_id id;\n      H.add !tab id (no_entry id);\n      raise Exit\n  else\n    lookup ()\n\nlet newVariable id typ err =\n  !currentScope.sco_negofs <- !currentScope.sco_negofs - sizeOfType typ;\n  let size = extractDimensionSizes typ in\n  let inf = {\n    variable_type = typ;\n    variable_offset = !currentScope.sco_negofs;\n    value = match typ with\n            | TYPE_int -> IntValue 0\n            | TYPE_char -> CharValue '0'\n            | _ -> let arr = createArray size in MultiArray arr\n  } in\n  newEntry id (ENTRY_variable inf) err\n\nlet newFunction id err =\n  try\n    let e = lookupEntry id LOOKUP_CURRENT_SCOPE false in\n    match e.entry_info with\n    | ENTRY_function inf when inf.function_isForward ->\n        inf.function_isForward <- false;\n        inf.function_pstatus <- PARDEF_CHECK;\n        inf.function_redeflist <- inf.function_paramlist;\n        e\n    | _ ->\n        if err then\n          error \"duplicate identifier: %a\" pretty_id id;\n          raise Exit\n  with Not_found ->\n    let inf = {\n      function_isForward = false;\n      function_paramlist = [];\n      function_redeflist = [];\n      function_result = TYPE_none;\n      function_pstatus = PARDEF_DEFINE;\n      function_initquad = 0;\n      function_body = fun _ -> None\n    } in\n    newEntry id (ENTRY_function inf) false\n\nlet newParameter id typ mode f err =\n  match f.entry_info with\n  | ENTRY_function inf -> begin\n      match inf.function_pstatus with\n      | PARDEF_DEFINE ->\n          let inf_p = {\n            parameter_type = typ;\n            parameter_offset = 0;\n            parameter_mode = mode\n          } in\n          let e = newEntry id (ENTRY_parameter inf_p) err in\n          inf.function_paramlist <- e :: inf.function_paramlist;\n          e\n      | PARDEF_CHECK -> begin\n          match inf.function_redeflist with\n          | p :: ps -> begin\n              inf.function_redeflist <- ps;\n              match p.entry_info with\n              | ENTRY_parameter inf ->\n                  if not (equalType inf.parameter_type typ) then\n                    error \"Parameter type mismatch in redeclaration \\\n                           of function %a\" pretty_id f.entry_id\n                  else if inf.parameter_mode != mode then\n                    error \"Parameter passing mode mismatch in redeclaration \\\n                           of function %a\" pretty_id f.entry_id\n                  else if p.entry_id != id then\n                    error \"Parameter name mismatch in redeclaration \\\n                           of function %a\" pretty_id f.entry_id\n                  else\n                    H.add !tab id p;\n                  p\n              | _ ->\n                  internal \"I found a parameter that is not a parameter!\";\n                  raise Exit\n            end\n          | [] ->\n              error \"More parameters than expected in redeclaration \\\n                     of function %a\" pretty_id f.entry_id;\n              raise Exit\n        end\n      | PARDEF_COMPLETE ->\n          internal \"Cannot add a parameter to an already defined function\";\n          raise Exit\n    end\n  | _ ->\n      internal \"Cannot add a parameter to a non-function\";\n      raise Exit\n\nlet newTemporary typ =\n  let id = id_make (\"$\" ^ string_of_int !tempNumber) in\n  !currentScope.sco_negofs <- !currentScope.sco_negofs - sizeOfType typ;\n  let inf = {\n    temporary_type = typ;\n    temporary_offset = !currentScope.sco_negofs\n  } in\n  incr tempNumber;\n  newEntry id (ENTRY_temporary inf) false\n\nlet forwardFunction e =\n  match e.entry_info with\n  | ENTRY_function inf ->\n      inf.function_isForward <- true\n  | _ ->\n      internal \"Cannot make a non-function forward\"\n\nlet endFunctionHeader e typ =\n  match e.entry_info with\n  | ENTRY_function inf ->\n      begin\n        match inf.function_pstatus with\n        | PARDEF_COMPLETE ->\n            internal \"Cannot end parameters in an already defined function\"\n        | PARDEF_DEFINE ->\n            inf.function_result <- typ;\n            let offset = ref start_positive_offset in\n            let fix_offset e =\n              match e.entry_info with\n              | ENTRY_parameter inf ->\n                  inf.parameter_offset <- !offset;\n                  let size =\n                    match inf.parameter_mode with\n                    | PASS_BY_VALUE     -> sizeOfType inf.parameter_type\n                    | PASS_BY_REFERENCE -> 2 in\n                  offset := !offset + size\n              | _ ->\n                  internal \"Cannot fix offset to a non parameter\" in\n            List.iter fix_offset inf.function_paramlist;\n            inf.function_paramlist <- List.rev inf.function_paramlist\n        | PARDEF_CHECK ->\n            if inf.function_redeflist <> [] then\n              error \"Fewer parameters than expected in redeclaration \\\n                     of function %a\" pretty_id e.entry_id;\n            if not (equalType inf.function_result typ) then\n              error \"Result type mismatch in redeclaration of function %a\"\n                    pretty_id e.entry_id;\n      end;\n      inf.function_pstatus <- PARDEF_COMPLETE\n  | _ ->\n      internal \"Cannot end parameters in a non-function\"\n\nlet assignToVariable (id: Identifier.id) (expr_val: variable_value) = \n  try\n    let variable_entry = lookupEntry id LOOKUP_CURRENT_SCOPE true in\n    match variable_entry.entry_info with \n    | ENTRY_variable v -> v.value <- expr_val\n    | _ -> error \"not a variable\"\n  with Not_found -> error \"Variable %a not found\" pretty_id id\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/tsimiho/Desktop/NTUA/ECE/Semester8/%CE%9C%CE%B5%CF%84%CE%B1%CE%B3%CE%BB%CF%89%CF%84%CF%84%CE%B9%CF%83%CF%84%CE%AD%CF%82/compiler/Symbol.ml","version":6},"contentChanges":[{"text":"open Identifier\nopen Error\nopen Types\nopen Narray\n\nmodule H = Hashtbl.Make (\n  struct\n    type t = id\n    let equal = (==)\n    let hash = Hashtbl.hash\n  end\n)\n\ntype pass_mode = PASS_BY_VALUE | PASS_BY_REFERENCE\n\ntype param_status =\n  | PARDEF_COMPLETE\n  | PARDEF_DEFINE\n  | PARDEF_CHECK\n\ntype scope = {\n  sco_parent          : scope option;\n  sco_nesting         : int;\n  mutable sco_entries : entry list;\n  mutable sco_negofs  : int\n}\n\nand variable_value =\n  | IntValue of int\n  | CharValue of char\n  | BoolValue of bool\n  | MultiArray of int multi_array\n  | Unit\n\nand variable_info = {\n  variable_type   : Types.typ;\n  variable_offset : int;\n  (* initialized     : bool; *)\n  mutable value   : variable_value\n}\n\nand function_info = {\n  mutable function_isForward : bool;\n  mutable function_paramlist : entry list;\n  mutable function_redeflist : entry list;\n  mutable function_result    : Types.typ;\n  mutable function_pstatus   : param_status;\n  mutable function_initquad  : int;\n  mutable function_body      : unit -> variable_value option\n}\n\nand parameter_info = {\n  parameter_type           : Types.typ;\n  mutable parameter_offset : int;\n  parameter_mode           : pass_mode\n}\n\nand temporary_info = {\n  temporary_type   : Types.typ;\n  temporary_offset : int\n}\n\nand entry_info = ENTRY_none\n               | ENTRY_variable of variable_info\n               | ENTRY_function of function_info\n               | ENTRY_parameter of parameter_info\n               | ENTRY_temporary of temporary_info\n\nand entry = {\n  entry_id    : Identifier.id;\n  entry_scope : scope\n  entry_info  : entry_info\n}\n\ntype lookup_type = LOOKUP_CURRENT_SCOPE | LOOKUP_ALL_SCOPES\n\nlet start_positive_offset = 8\nlet start_negative_offset = 0\n\nlet the_outer_scope = {\n  sco_parent = None;\n  sco_nesting = 0;\n  sco_entries = [] ;\n  sco_negofs = start_negative_offset\n}\n\nlet no_entry id = {\n  entry_id = id;\n  entry_scope = the_outer_scope;\n  entry_info = ENTRY_none\n}\n\nlet currentScope = ref the_outer_scope\nlet quadNext = ref 1\nlet tempNumber = ref 1\n\nlet tab = ref (H.create 0)\n\nlet initSymbolTable size =\n   tab := H.create size;\n   currentScope := the_outer_scope\n\nlet openScope () =\n  let sco = {\n    sco_parent = Some !currentScope;\n    sco_nesting = !currentScope.sco_nesting + 1;\n    sco_entries = [];\n    sco_negofs = start_negative_offset\n  } in\n  currentScope := sco\n\nlet closeScope () =\n  let sco = !currentScope in\n  let manyentry e = H.remove !tab e.entry_id in\n  List.iter manyentry sco.sco_entries;\n  match sco.sco_parent with\n  | Some scp ->\n      currentScope := scp\n  | None ->\n      internal \"cannot close the outer scope!\"\n\nexception Failure_NewEntry of entry\n\nlet newEntry id inf err =\n  try\n    if err then begin\n      try\n        let e = H.find !tab id in\n        if e.entry_scope.sco_nesting = !currentScope.sco_nesting then\n           raise (Failure_NewEntry e)\n      with Not_found ->\n        ()\n    end;\n    let e = {\n      entry_id = id;\n      entry_scope = !currentScope;\n      entry_info = inf\n    } in\n    H.add !tab id e;\n    !currentScope.sco_entries <- e :: !currentScope.sco_entries;\n    e\n  with Failure_NewEntry e ->\n    error \"duplicate identifier %a\" pretty_id id;\n    e\n\nlet lookupEntry id how err =\n  let scc = !currentScope in\n  let lookup () =\n    match how with\n    | LOOKUP_CURRENT_SCOPE ->\n        let e = H.find !tab id in\n        if e.entry_scope.sco_nesting = scc.sco_nesting then\n          e\n        else\n          raise Not_found\n    | LOOKUP_ALL_SCOPES ->\n        H.find !tab id in\n  if err then\n    try\n      lookup ()\n    with Not_found ->\n      error \"unknown identifier %a (first occurrence)\"\n        pretty_id id;\n      H.add !tab id (no_entry id);\n      raise Exit\n  else\n    lookup ()\n\nlet newVariable id typ err =\n  !currentScope.sco_negofs <- !currentScope.sco_negofs - sizeOfType typ;\n  let size = extractDimensionSizes typ in\n  let inf = {\n    variable_type = typ;\n    variable_offset = !currentScope.sco_negofs;\n    value = match typ with\n            | TYPE_int -> IntValue 0\n            | TYPE_char -> CharValue '0'\n            | _ -> let arr = createArray size in MultiArray arr\n  } in\n  newEntry id (ENTRY_variable inf) err\n\nlet newFunction id err =\n  try\n    let e = lookupEntry id LOOKUP_CURRENT_SCOPE false in\n    match e.entry_info with\n    | ENTRY_function inf when inf.function_isForward ->\n        inf.function_isForward <- false;\n        inf.function_pstatus <- PARDEF_CHECK;\n        inf.function_redeflist <- inf.function_paramlist;\n        e\n    | _ ->\n        if err then\n          error \"duplicate identifier: %a\" pretty_id id;\n          raise Exit\n  with Not_found ->\n    let inf = {\n      function_isForward = false;\n      function_paramlist = [];\n      function_redeflist = [];\n      function_result = TYPE_none;\n      function_pstatus = PARDEF_DEFINE;\n      function_initquad = 0;\n      function_body = fun _ -> None\n    } in\n    newEntry id (ENTRY_function inf) false\n\nlet newParameter id typ mode f err =\n  match f.entry_info with\n  | ENTRY_function inf -> begin\n      match inf.function_pstatus with\n      | PARDEF_DEFINE ->\n          let inf_p = {\n            parameter_type = typ;\n            parameter_offset = 0;\n            parameter_mode = mode\n          } in\n          let e = newEntry id (ENTRY_parameter inf_p) err in\n          inf.function_paramlist <- e :: inf.function_paramlist;\n          e\n      | PARDEF_CHECK -> begin\n          match inf.function_redeflist with\n          | p :: ps -> begin\n              inf.function_redeflist <- ps;\n              match p.entry_info with\n              | ENTRY_parameter inf ->\n                  if not (equalType inf.parameter_type typ) then\n                    error \"Parameter type mismatch in redeclaration \\\n                           of function %a\" pretty_id f.entry_id\n                  else if inf.parameter_mode != mode then\n                    error \"Parameter passing mode mismatch in redeclaration \\\n                           of function %a\" pretty_id f.entry_id\n                  else if p.entry_id != id then\n                    error \"Parameter name mismatch in redeclaration \\\n                           of function %a\" pretty_id f.entry_id\n                  else\n                    H.add !tab id p;\n                  p\n              | _ ->\n                  internal \"I found a parameter that is not a parameter!\";\n                  raise Exit\n            end\n          | [] ->\n              error \"More parameters than expected in redeclaration \\\n                     of function %a\" pretty_id f.entry_id;\n              raise Exit\n        end\n      | PARDEF_COMPLETE ->\n          internal \"Cannot add a parameter to an already defined function\";\n          raise Exit\n    end\n  | _ ->\n      internal \"Cannot add a parameter to a non-function\";\n      raise Exit\n\nlet newTemporary typ =\n  let id = id_make (\"$\" ^ string_of_int !tempNumber) in\n  !currentScope.sco_negofs <- !currentScope.sco_negofs - sizeOfType typ;\n  let inf = {\n    temporary_type = typ;\n    temporary_offset = !currentScope.sco_negofs\n  } in\n  incr tempNumber;\n  newEntry id (ENTRY_temporary inf) false\n\nlet forwardFunction e =\n  match e.entry_info with\n  | ENTRY_function inf ->\n      inf.function_isForward <- true\n  | _ ->\n      internal \"Cannot make a non-function forward\"\n\nlet endFunctionHeader e typ =\n  match e.entry_info with\n  | ENTRY_function inf ->\n      begin\n        match inf.function_pstatus with\n        | PARDEF_COMPLETE ->\n            internal \"Cannot end parameters in an already defined function\"\n        | PARDEF_DEFINE ->\n            inf.function_result <- typ;\n            let offset = ref start_positive_offset in\n            let fix_offset e =\n              match e.entry_info with\n              | ENTRY_parameter inf ->\n                  inf.parameter_offset <- !offset;\n                  let size =\n                    match inf.parameter_mode with\n                    | PASS_BY_VALUE     -> sizeOfType inf.parameter_type\n                    | PASS_BY_REFERENCE -> 2 in\n                  offset := !offset + size\n              | _ ->\n                  internal \"Cannot fix offset to a non parameter\" in\n            List.iter fix_offset inf.function_paramlist;\n            inf.function_paramlist <- List.rev inf.function_paramlist\n        | PARDEF_CHECK ->\n            if inf.function_redeflist <> [] then\n              error \"Fewer parameters than expected in redeclaration \\\n                     of function %a\" pretty_id e.entry_id;\n            if not (equalType inf.function_result typ) then\n              error \"Result type mismatch in redeclaration of function %a\"\n                    pretty_id e.entry_id;\n      end;\n      inf.function_pstatus <- PARDEF_COMPLETE\n  | _ ->\n      internal \"Cannot end parameters in a non-function\"\n\nlet assignToVariable (id: Identifier.id) (expr_val: variable_value) = \n  try\n    let variable_entry = lookupEntry id LOOKUP_CURRENT_SCOPE true in\n    match variable_entry.entry_info with \n    | ENTRY_variable v -> v.value <- expr_val\n    | _ -> error \"not a variable\"\n  with Not_found -> error \"Variable %a not found\" pretty_id id\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/tsimiho/Desktop/NTUA/ECE/Semester8/%CE%9C%CE%B5%CF%84%CE%B1%CE%B3%CE%BB%CF%89%CF%84%CF%84%CE%B9%CF%83%CF%84%CE%AD%CF%82/compiler/Symbol.ml","version":7},"contentChanges":[{"text":"open Identifier\nopen Error\nopen Types\nopen Narray\n\nmodule H = Hashtbl.Make (\n  struct\n    type t = id\n    let equal = (==)\n    let hash = Hashtbl.hash\n  end\n)\n\ntype pass_mode = PASS_BY_VALUE | PASS_BY_REFERENCE\n\ntype param_status =\n  | PARDEF_COMPLETE\n  | PARDEF_DEFINE\n  | PARDEF_CHECK\n\ntype scope = {\n  sco_parent          : scope option;\n  sco_nesting         : int;\n  mutable sco_entries : entry list;\n  mutable sco_negofs  : int\n}\n\nand variable_value =\n  | IntValue of int\n  | CharValue of char\n  | BoolValue of bool\n  | MultiArray of int multi_array\n  | Unit\n\nand variable_info = {\n  variable_type   : Types.typ;\n  variable_offset : int;\n  (* initialized     : bool; *)\n  mutable value   : variable_value\n}\n\nand function_info = {\n  mutable function_isForward : bool;\n  mutable function_paramlist : entry list;\n  mutable function_redeflist : entry list;\n  mutable function_result    : Types.typ;\n  mutable function_pstatus   : param_status;\n  mutable function_initquad  : int;\n  mutable function_body      : unit -> variable_value option\n}\n\nand parameter_info = {\n  parameter_type           : Types.typ;\n  mutable parameter_offset : int;\n  parameter_mode           : pass_mode\n}\n\nand temporary_info = {\n  temporary_type   : Types.typ;\n  temporary_offset : int\n}\n\nand entry_info = ENTRY_none\n               | ENTRY_variable of variable_info\n               | ENTRY_function of function_info\n               | ENTRY_parameter of parameter_info\n               | ENTRY_temporary of temporary_info\n\nand entry = {\n  entry_id    : Identifier.id;\n  entry_scope : scope\n  entry_info  : entry_info\n}\n\ntype lookup_type = LOOKUP_CURRENT_SCOPE | LOOKUP_ALL_SCOPES\n\nlet start_positive_offset = 8\nlet start_negative_offset = 0\n\nlet the_outer_scope = {\n  sco_parent = None;\n  sco_nesting = 0;\n  sco_entries = [] ;\n  sco_negofs = start_negative_offset\n}\n\nlet no_entry id = {\n  entry_id = id;\n  entry_scope = the_outer_scope;\n  entry_info = ENTRY_none\n}\n\nlet currentScope = ref the_outer_scope\nlet quadNext = ref 1\nlet tempNumber = ref 1\n\nlet tab = ref (H.create 0)\n\nlet initSymbolTable size =\n   tab := H.create size;\n   currentScope := the_outer_scope\n\nlet openScope () =\n  let sco = {\n    sco_parent = Some !currentScope;\n    sco_nesting = !currentScope.sco_nesting + 1;\n    sco_entries = [];\n    sco_negofs = start_negative_offset\n  } in\n  currentScope := sco\n\nlet closeScope () =\n  let sco = !currentScope in\n  let manyentry e = H.remove !tab e.entry_id in\n  List.iter manyentry sco.sco_entries;\n  match sco.sco_parent with\n  | Some scp ->\n      currentScope := scp\n  | None ->\n      internal \"cannot close the outer scope!\"\n\nexception Failure_NewEntry of entry\n\nlet newEntry id inf err =\n  try\n    if err then begin\n      try\n        let e = H.find !tab id in\n        if e.entry_scope.sco_nesting = !currentScope.sco_nesting then\n           raise (Failure_NewEntry e)\n      with Not_found ->\n        ()\n    end;\n    let e = {\n      entry_id = id;\n      entry_scope = !currentScope;\n      entry_info = inf\n    } in\n    H.add !tab id e;\n    !currentScope.sco_entries <- e :: !currentScope.sco_entries;\n    e\n  with Failure_NewEntry e ->\n    error \"duplicate identifier %a\" pretty_id id;\n    e\n\nlet lookupEntry id how err =\n  let scc = !currentScope in\n  let lookup () =\n    match how with\n    | LOOKUP_CURRENT_SCOPE ->\n        let e = H.find !tab id in\n        if e.entry_scope.sco_nesting = scc.sco_nesting then\n          e\n        else\n          raise Not_found\n    | LOOKUP_ALL_SCOPES ->\n        H.find !tab id in\n  if err then\n    try\n      lookup ()\n    with Not_found ->\n      error \"unknown identifier %a (first occurrence)\"\n        pretty_id id;\n      H.add !tab id (no_entry id);\n      raise Exit\n  else\n    lookup ()\n\nlet newVariable id typ err =\n  !currentScope.sco_negofs <- !currentScope.sco_negofs - sizeOfType typ;\n  let size = extractDimensionSizes typ in\n  let inf = {\n    variable_type = typ;\n    variable_offset = !currentScope.sco_negofs;\n    value = match typ with\n            | TYPE_int -> IntValue 0\n            | TYPE_char -> CharValue '0'\n            | _ -> let arr = createArray size in MultiArray arr\n  } in\n  newEntry id (ENTRY_variable inf) err\n\nlet newFunction id err =\n  try\n    let e = lookupEntry id LOOKUP_CURRENT_SCOPE false in\n    match e.entry_info with\n    | ENTRY_function inf when inf.function_isForward ->\n        inf.function_isForward <- false;\n        inf.function_pstatus <- PARDEF_CHECK;\n        inf.function_redeflist <- inf.function_paramlist;\n        e\n    | _ ->\n        if err then\n          error \"duplicate identifier: %a\" pretty_id id;\n          raise Exit\n  with Not_found ->\n    let inf = {\n      function_isForward = false;\n      function_paramlist = [];\n      function_redeflist = [];\n      function_result = TYPE_none;\n      function_pstatus = PARDEF_DEFINE;\n      function_initquad = 0;\n      function_body = fun _ -> None\n    } in\n    newEntry id (ENTRY_function inf) false\n\nlet newParameter id typ mode f err =\n  match f.entry_info with\n  | ENTRY_function inf -> begin\n      match inf.function_pstatus with\n      | PARDEF_DEFINE ->\n          let inf_p = {\n            parameter_type = typ;\n            parameter_offset = 0;\n            parameter_mode = mode\n          } in\n          let e = newEntry id (ENTRY_parameter inf_p) err in\n          inf.function_paramlist <- e :: inf.function_paramlist;\n          e\n      | PARDEF_CHECK -> begin\n          match inf.function_redeflist with\n          | p :: ps -> begin\n              inf.function_redeflist <- ps;\n              match p.entry_info with\n              | ENTRY_parameter inf ->\n                  if not (equalType inf.parameter_type typ) then\n                    error \"Parameter type mismatch in redeclaration \\\n                           of function %a\" pretty_id f.entry_id\n                  else if inf.parameter_mode != mode then\n                    error \"Parameter passing mode mismatch in redeclaration \\\n                           of function %a\" pretty_id f.entry_id\n                  else if p.entry_id != id then\n                    error \"Parameter name mismatch in redeclaration \\\n                           of function %a\" pretty_id f.entry_id\n                  else\n                    H.add !tab id p;\n                  p\n              | _ ->\n                  internal \"I found a parameter that is not a parameter!\";\n                  raise Exit\n            end\n          | [] ->\n              error \"More parameters than expected in redeclaration \\\n                     of function %a\" pretty_id f.entry_id;\n              raise Exit\n        end\n      | PARDEF_COMPLETE ->\n          internal \"Cannot add a parameter to an already defined function\";\n          raise Exit\n    end\n  | _ ->\n      internal \"Cannot add a parameter to a non-function\";\n      raise Exit\n\nlet newTemporary typ =\n  let id = id_make (\"$\" ^ string_of_int !tempNumber) in\n  !currentScope.sco_negofs <- !currentScope.sco_negofs - sizeOfType typ;\n  let inf = {\n    temporary_type = typ;\n    temporary_offset = !currentScope.sco_negofs\n  } in\n  incr tempNumber;\n  newEntry id (ENTRY_temporary inf) false\n\nlet forwardFunction e =\n  match e.entry_info with\n  | ENTRY_function inf ->\n      inf.function_isForward <- true\n  | _ ->\n      internal \"Cannot make a non-function forward\"\n\nlet endFunctionHeader e typ =\n  match e.entry_info with\n  | ENTRY_function inf ->\n      begin\n        match inf.function_pstatus with\n        | PARDEF_COMPLETE ->\n            internal \"Cannot end parameters in an already defined function\"\n        | PARDEF_DEFINE ->\n            inf.function_result <- typ;\n            let offset = ref start_positive_offset in\n            let fix_offset e =\n              match e.entry_info with\n              | ENTRY_parameter inf ->\n                  inf.parameter_offset <- !offset;\n                  let size =\n                    match inf.parameter_mode with\n                    | PASS_BY_VALUE     -> sizeOfType inf.parameter_type\n                    | PASS_BY_REFERENCE -> 2 in\n                  offset := !offset + size\n              | _ ->\n                  internal \"Cannot fix offset to a non parameter\" in\n            List.iter fix_offset inf.function_paramlist;\n            inf.function_paramlist <- List.rev inf.function_paramlist\n        | PARDEF_CHECK ->\n            if inf.function_redeflist <> [] then\n              error \"Fewer parameters than expected in redeclaration \\\n                     of function %a\" pretty_id e.entry_id;\n            if not (equalType inf.function_result typ) then\n              error \"Result type mismatch in redeclaration of function %a\"\n                    pretty_id e.entry_id;\n      end;\n      inf.function_pstatus <- PARDEF_COMPLETE\n  | _ ->\n      internal \"Cannot end parameters in a non-function\"\n\nlet assignToVariable (id: Identifier.id) (expr_val: variable_value) = \n  try\n    let variable_entry = lookupEntry id LOOKUP_CURRENT_SCOPE true in\n    match variable_entry.entry_info with \n    | ENTRY_variable v -> v.value <- expr_val\n    | _ -> error \"not a variable\"\n  with Not_found -> error \"Variable %a not found\" pretty_id id\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/tsimiho/Desktop/NTUA/ECE/Semester8/%CE%9C%CE%B5%CF%84%CE%B1%CE%B3%CE%BB%CF%89%CF%84%CF%84%CE%B9%CF%83%CF%84%CE%AD%CF%82/compiler/Symbol.ml","version":8},"contentChanges":[{"text":"open Identifier\nopen Error\nopen Types\nopen Narray\n\nmodule H = Hashtbl.Make (\n  struct\n    type t = id\n    let equal = (==)\n    let hash = Hashtbl.hash\n  end\n)\n\ntype pass_mode = PASS_BY_VALUE | PASS_BY_REFERENCE\n\ntype param_status =\n  | PARDEF_COMPLETE\n  | PARDEF_DEFINE\n  | PARDEF_CHECK\n\ntype scope = {\n  sco_parent          : scope option;\n  sco_nesting         : int;\n  mutable sco_entries : entry list;\n  mutable sco_negofs  : int\n}\n\nand variable_value =\n  | IntValue of int\n  | CharValue of char\n  | BoolValue of bool\n  | MultiArray of int multi_array\n  | Unit\n\nand variable_info = {\n  variable_type   : Types.typ;\n  variable_offset : int;\n  (* initialized     : bool; *)\n  mutable value   : variable_value\n}\n\nand function_info = {\n  mutable function_isForward : bool;\n  mutable function_paramlist : entry list;\n  mutable function_redeflist : entry list;\n  mutable function_result    : Types.typ;\n  mutable function_pstatus   : param_status;\n  mutable function_initquad  : int;\n  mutable function_body      : unit -> variable_value option\n}\n\nand parameter_info = {\n  parameter_type           : Types.typ;\n  mutable parameter_offset : int;\n  parameter_mode           : pass_mode\n}\n\nand temporary_info = {\n  temporary_type   : Types.typ;\n  temporary_offset : int\n}\n\nand entry_info = ENTRY_none\n               | ENTRY_variable of variable_info\n               | ENTRY_function of function_info\n               | ENTRY_parameter of parameter_info\n               | ENTRY_temporary of temporary_info\n\nand entry = {\n  entry_id    : Identifier.id;\n  entry_scope : scope\n  entry_info  : entry_info\n}\n\ntype lookup_type = LOOKUP_CURRENT_SCOPE | LOOKUP_ALL_SCOPES\n\nlet start_positive_offset = 8\nlet start_negative_offset = 0\n\nlet the_outer_scope = {\n  sco_parent = None;\n  sco_nesting = 0;\n  sco_entries = [] ;\n  sco_negofs = start_negative_offset\n}\n\nlet no_entry id = {\n  entry_id = id;\n  entry_scope = the_outer_scope;\n  entry_info = ENTRY_none\n}\n\nlet currentScope = ref the_outer_scope\nlet quadNext = ref 1\nlet tempNumber = ref 1\n\nlet tab = ref (H.create 0)\n\nlet initSymbolTable size =\n   tab := H.create size;\n   currentScope := the_outer_scope\n\nlet openScope () =\n  let sco = {\n    sco_parent = Some !currentScope;\n    sco_nesting = !currentScope.sco_nesting + 1;\n    sco_entries = [];\n    sco_negofs = start_negative_offset\n  } in\n  currentScope := sco\n\nlet closeScope () =\n  let sco = !currentScope in\n  let manyentry e = H.remove !tab e.entry_id in\n  List.iter manyentry sco.sco_entries;\n  match sco.sco_parent with\n  | Some scp ->\n      currentScope := scp\n  | None ->\n      internal \"cannot close the outer scope!\"\n\nexception Failure_NewEntry of entry\n\nlet newEntry id inf err =\n  try\n    if err then begin\n      try\n        let e = H.find !tab id in\n        if e.entry_scope.sco_nesting = !currentScope.sco_nesting then\n           raise (Failure_NewEntry e)\n      with Not_found ->\n        ()\n    end;\n    let e = {\n      entry_id = id;\n      entry_scope = !currentScope;\n      entry_info = inf\n    } in\n    H.add !tab id e;\n    !currentScope.sco_entries <- e :: !currentScope.sco_entries;\n    e\n  with Failure_NewEntry e ->\n    error \"duplicate identifier %a\" pretty_id id;\n    e\n\nlet lookupEntry id how err =\n  let scc = !currentScope in\n  let lookup () =\n    match how with\n    | LOOKUP_CURRENT_SCOPE ->\n        let e = H.find !tab id in\n        if e.entry_scope.sco_nesting = scc.sco_nesting then\n          e\n        else\n          raise Not_found\n    | LOOKUP_ALL_SCOPES ->\n        H.find !tab id in\n  if err then\n    try\n      lookup ()\n    with Not_found ->\n      error \"unknown identifier %a (first occurrence)\"\n        pretty_id id;\n      H.add !tab id (no_entry id);\n      raise Exit\n  else\n    lookup ()\n\nlet newVariable id typ err =\n  !currentScope.sco_negofs <- !currentScope.sco_negofs - sizeOfType typ;\n  let size = extractDimensionSizes typ in\n  let inf = {\n    variable_type = typ;\n    variable_offset = !currentScope.sco_negofs;\n    value = match typ with\n            | TYPE_int -> IntValue 0\n            | TYPE_char -> CharValue '0'\n            | _ -> let arr = createArray size in MultiArray arr\n  } in\n  newEntry id (ENTRY_variable inf) err\n\nlet newFunction id err =\n  try\n    let e = lookupEntry id LOOKUP_CURRENT_SCOPE false in\n    match e.entry_info with\n    | ENTRY_function inf when inf.function_isForward ->\n        inf.function_isForward <- false;\n        inf.function_pstatus <- PARDEF_CHECK;\n        inf.function_redeflist <- inf.function_paramlist;\n        e\n    | _ ->\n        if err then\n          error \"duplicate identifier: %a\" pretty_id id;\n          raise Exit\n  with Not_found ->\n    let inf = {\n      function_isForward = false;\n      function_paramlist = [];\n      function_redeflist = [];\n      function_result = TYPE_none;\n      function_pstatus = PARDEF_DEFINE;\n      function_initquad = 0;\n      function_body = fun _ -> None\n    } in\n    newEntry id (ENTRY_function inf) false\n\nlet newParameter id typ mode f err =\n  match f.entry_info with\n  | ENTRY_function inf -> begin\n      match inf.function_pstatus with\n      | PARDEF_DEFINE ->\n          let inf_p = {\n            parameter_type = typ;\n            parameter_offset = 0;\n            parameter_mode = mode\n          } in\n          let e = newEntry id (ENTRY_parameter inf_p) err in\n          inf.function_paramlist <- e :: inf.function_paramlist;\n          e\n      | PARDEF_CHECK -> begin\n          match inf.function_redeflist with\n          | p :: ps -> begin\n              inf.function_redeflist <- ps;\n              match p.entry_info with\n              | ENTRY_parameter inf ->\n                  if not (equalType inf.parameter_type typ) then\n                    error \"Parameter type mismatch in redeclaration \\\n                           of function %a\" pretty_id f.entry_id\n                  else if inf.parameter_mode != mode then\n                    error \"Parameter passing mode mismatch in redeclaration \\\n                           of function %a\" pretty_id f.entry_id\n                  else if p.entry_id != id then\n                    error \"Parameter name mismatch in redeclaration \\\n                           of function %a\" pretty_id f.entry_id\n                  else\n                    H.add !tab id p;\n                  p\n              | _ ->\n                  internal \"I found a parameter that is not a parameter!\";\n                  raise Exit\n            end\n          | [] ->\n              error \"More parameters than expected in redeclaration \\\n                     of function %a\" pretty_id f.entry_id;\n              raise Exit\n        end\n      | PARDEF_COMPLETE ->\n          internal \"Cannot add a parameter to an already defined function\";\n          raise Exit\n    end\n  | _ ->\n      internal \"Cannot add a parameter to a non-function\";\n      raise Exit\n\nlet newTemporary typ =\n  let id = id_make (\"$\" ^ string_of_int !tempNumber) in\n  !currentScope.sco_negofs <- !currentScope.sco_negofs - sizeOfType typ;\n  let inf = {\n    temporary_type = typ;\n    temporary_offset = !currentScope.sco_negofs\n  } in\n  incr tempNumber;\n  newEntry id (ENTRY_temporary inf) false\n\nlet forwardFunction e =\n  match e.entry_info with\n  | ENTRY_function inf ->\n      inf.function_isForward <- true\n  | _ ->\n      internal \"Cannot make a non-function forward\"\n\nlet endFunctionHeader e typ =\n  match e.entry_info with\n  | ENTRY_function inf ->\n      begin\n        match inf.function_pstatus with\n        | PARDEF_COMPLETE ->\n            internal \"Cannot end parameters in an already defined function\"\n        | PARDEF_DEFINE ->\n            inf.function_result <- typ;\n            let offset = ref start_positive_offset in\n            let fix_offset e =\n              match e.entry_info with\n              | ENTRY_parameter inf ->\n                  inf.parameter_offset <- !offset;\n                  let size =\n                    match inf.parameter_mode with\n                    | PASS_BY_VALUE     -> sizeOfType inf.parameter_type\n                    | PASS_BY_REFERENCE -> 2 in\n                  offset := !offset + size\n              | _ ->\n                  internal \"Cannot fix offset to a non parameter\" in\n            List.iter fix_offset inf.function_paramlist;\n            inf.function_paramlist <- List.rev inf.function_paramlist\n        | PARDEF_CHECK ->\n            if inf.function_redeflist <> [] then\n              error \"Fewer parameters than expected in redeclaration \\\n                     of function %a\" pretty_id e.entry_id;\n            if not (equalType inf.function_result typ) then\n              error \"Result type mismatch in redeclaration of function %a\"\n                    pretty_id e.entry_id;\n      end;\n      inf.function_pstatus <- PARDEF_COMPLETE\n  | _ ->\n      internal \"Cannot end parameters in a non-function\"\n\nlet assignToVariable (id: Identifier.id) (expr_val: variable_value) = \n  try\n    let variable_entry = lookupEntry id LOOKUP_CURRENT_SCOPE true in\n    match variable_entry.entry_info with \n    | ENTRY_variable v -> v.value <- expr_val\n    | _ -> error \"not a variable\"\n  with Not_found -> error \"Variable %a not found\" pretty_id id\n"}]}}
Read message 
{"jsonrpc":"2.0","id":3,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/tsimiho/Desktop/NTUA/ECE/Semester8/%CE%9C%CE%B5%CF%84%CE%B1%CE%B3%CE%BB%CF%89%CF%84%CF%84%CE%B9%CF%83%CF%84%CE%AD%CF%82/compiler/Symbol.ml"},"position":{"line":0,"character":0}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0300407409668ms
Sending response {"id": 3, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":4,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/tsimiho/Desktop/NTUA/ECE/Semester8/%CE%9C%CE%B5%CF%84%CE%B1%CE%B3%CE%BB%CF%89%CF%84%CF%84%CE%B9%CF%83%CF%84%CE%AD%CF%82/compiler/Parser.mly"},"position":{"line":0,"character":0}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0288486480713ms
Sending response {"id": 4, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":5,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/tsimiho/Desktop/NTUA/ECE/Semester8/%CE%9C%CE%B5%CF%84%CE%B1%CE%B3%CE%BB%CF%89%CF%84%CF%84%CE%B9%CF%83%CF%84%CE%AD%CF%82/compiler/Irgen.ml"},"position":{"line":0,"character":0}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0290870666504ms
Sending response {"id": 5, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///Users/tsimiho/Desktop/NTUA/ECE/Semester8/%CE%9C%CE%B5%CF%84%CE%B1%CE%B3%CE%BB%CF%89%CF%84%CF%84%CE%B9%CF%83%CF%84%CE%AD%CF%82/minibasic_llvm/Ast.ml","languageId":"reason","version":1,"text":"type var  = char\ntype oper = O_plus | O_minus | O_times\n\ntype ast_stmt =\n| S_print of ast_expr\n| S_let of var * ast_expr\n| S_for of ast_expr * ast_stmt\n| S_block of ast_stmt list\n| S_if of ast_expr * ast_stmt\n\nand ast_expr =\n| E_const of int\n| E_var of var\n| E_op of ast_expr * oper * ast_expr\n\nlet vars = Array.make 26 0\n\nlet rec run_expr ast =\n  match ast with\n  | E_const n         -> n\n  | E_var x           -> vars.(int_of_char x - int_of_char 'a')\n  | E_op (e1, op, e2) -> let v1 = run_expr e1\n                         and v2 = run_expr e2 in\n                         match op with\n                         | O_plus  -> v1 + v2\n                         | O_minus -> v1 - v2\n                         | O_times -> v1 * v2\n\nlet rec run_stmt ast =\n  match ast with\n  | S_print e    -> let v = run_expr e in\n                    Printf.printf \"%d\\n\" v\n  | S_let (x, e) -> let v = run_expr e in\n                    vars.(int_of_char x - int_of_char 'a') <- v\n  | S_for (e, s) -> let v = run_expr e in\n                    for i = 1 to v do\n                      run_stmt s\n                    done\n  | S_block b    -> run b\n  | S_if (e, s)  -> let v = run_expr e in\n                    if v <> 0 then run_stmt s\n\nand run asts = List.iter run_stmt asts\n\ntype llvm_info = {\n  context          : Llvm.llcontext;\n  the_module       : Llvm.llmodule;\n  builder          : Llvm.llbuilder;\n  i8               : Llvm.lltype;\n  i32              : Llvm.lltype;\n  i64              : Llvm.lltype;\n  c32              : int -> Llvm.llvalue;\n  c64              : int -> Llvm.llvalue;\n  the_vars         : Llvm.llvalue;\n  the_nl           : Llvm.llvalue;\n  the_writeInteger : Llvm.llvalue;\n  the_writeString  : Llvm.llvalue;\n}\n\nlet rec compile_expr info ast =\n  match ast with\n  | E_const n         -> info.c64 n\n  | E_var x           -> let n = int_of_char x - int_of_char 'a' in\n                         let v = Llvm.build_gep info.the_vars\n                                                [| info.c32 0; info.c32 n |]\n                                                (String.make 1 x ^ \"_ptr\")\n                                                info.builder in\n                         Llvm.build_load v (String.make 1 x) info.builder\n  | E_op (e1, op, e2) -> let l = compile_expr info e1 in\n                         let r = compile_expr info e2 in\n                         begin\n                           match op with\n                           | O_plus  -> Llvm.build_add l r \"addtmp\" info.builder\n                           | O_minus -> Llvm.build_sub l r \"subtmp\" info.builder\n                           | O_times -> Llvm.build_mul l r \"multmp\" info.builder\n                         end\n\nlet rec compile_stmt info ast =\n  match ast with\n  | S_print e    -> let n = compile_expr info e in\n                    ignore (Llvm.build_call info.the_writeInteger [| n |] \"\"\n                                            info.builder);\n                    let nl = Llvm.build_gep info.the_nl\n                                            [| info.c32 0; info.c32 0 |]\n                                            \"nl\" info.builder in\n                    ignore (Llvm.build_call info.the_writeString [| nl |] \"\"\n                                            info.builder)\n  | S_let (x, e) -> let n = int_of_char x - int_of_char 'a' in\n                    let l = Llvm.build_gep info.the_vars\n                                           [| info.c32 0; info.c32 n |]\n                                           (String.make 1 x ^ \"_ptr\")\n                                           info.builder in\n                    let r = compile_expr info e in\n                    ignore (Llvm.build_store r l info.builder)\n  | S_for (e, s) -> let n = compile_expr info e in\n                    let bb = Llvm.insertion_block info.builder in\n                    let f = Llvm.block_parent bb in\n                    let loop_bb = Llvm.append_block info.context \"loop\" f in\n                    let body_bb = Llvm.append_block info.context \"body\" f in\n                    let after_bb = Llvm.append_block info.context \"after\" f in\n                    ignore (Llvm.build_br loop_bb info.builder);\n                    Llvm.position_at_end loop_bb info.builder;\n                    let phi_iter =\n                      Llvm.build_phi [(n, bb)] \"iter\" info.builder in\n                    let loop_cond =\n                      Llvm.build_icmp Llvm.Icmp.Sgt phi_iter (info.c64 0)\n                                      \"loop_cond\" info.builder in\n                    ignore (Llvm.build_cond_br loop_cond body_bb after_bb\n                                               info.builder);\n                    Llvm.position_at_end body_bb info.builder;\n                    let remaining = Llvm.build_sub phi_iter (info.c64 1)\n                                                   \"remaining\" info.builder in\n                    compile_stmt info s;\n                    Llvm.add_incoming\n                      (remaining, Llvm.insertion_block info.builder) phi_iter;\n                    ignore (Llvm.build_br loop_bb info.builder);\n                    Llvm.position_at_end after_bb info.builder\n  | S_block b    -> List.iter (compile_stmt info) b\n  | S_if (e, s)  -> let v = compile_expr info e in\n                    let cond = Llvm.build_icmp Llvm.Icmp.Ne v (info.c64 0)\n                                               \"if_cond\" info.builder in\n                    let bb = Llvm.insertion_block info.builder in\n                    let f = Llvm.block_parent bb in\n                    let then_bb = Llvm.append_block info.context \"then\" f in\n                    let after_bb = Llvm.append_block info.context \"after\" f in\n                    ignore (Llvm.build_cond_br cond then_bb after_bb\n                                               info.builder);\n                    Llvm.position_at_end then_bb info.builder;\n                    compile_stmt info s;\n                    ignore (Llvm.build_br after_bb info.builder);\n                    Llvm.position_at_end after_bb info.builder\n\nlet llvm_compile_and_dump asts =\n  (* Initialize *)\n  Llvm_all_backends.initialize ();\n  let context = Llvm.global_context () in\n  let the_module = Llvm.create_module context \"minibasic program\" in\n  let builder = Llvm.builder context in\n  let pm = Llvm.PassManager.create () in\n  List.iter (fun f -> f pm) [\n    Llvm_scalar_opts.add_memory_to_register_promotion;\n    Llvm_scalar_opts.add_instruction_combination;\n    Llvm_scalar_opts.add_reassociation;\n    Llvm_scalar_opts.add_gvn;\n    Llvm_scalar_opts.add_cfg_simplification;\n  ];\n  (* Initialize types *)\n  let i8 = Llvm.i8_type context in\n  let i32 = Llvm.i32_type context in\n  let i64 = Llvm.i64_type context in\n  (* Initialize constant functions *)\n  let c32 = Llvm.const_int i32 in\n  let c64 = Llvm.const_int i64 in\n  (* Initialize global variables *)\n  let vars_type = Llvm.array_type i64 26 in\n  let the_vars = Llvm.declare_global vars_type \"vars\" the_module in\n  Llvm.set_linkage Llvm.Linkage.Private the_vars;\n  Llvm.set_initializer (Llvm.const_null vars_type) the_vars;\n  Llvm.set_alignment 16 the_vars;\n  let nl = \"\\n\" in\n  let nl_type = Llvm.array_type i8 (1 + String.length nl) in\n  let the_nl = Llvm.declare_global nl_type \"nl\" the_module in\n  Llvm.set_linkage Llvm.Linkage.Private the_nl;\n  Llvm.set_global_constant true the_nl;\n  Llvm.set_initializer (Llvm.const_stringz context nl) the_nl;\n  Llvm.set_alignment 1 the_nl;\n  (* Initialize library functions *)\n  let writeInteger_type =\n    Llvm.function_type (Llvm.void_type context) [| i64 |] in\n  let the_writeInteger =\n    Llvm.declare_function \"writeInteger\" writeInteger_type the_module in\n  let writeString_type =\n    Llvm.function_type (Llvm.void_type context) [| Llvm.pointer_type i8 |] in\n  let the_writeString =\n    Llvm.declare_function \"writeString\" writeString_type the_module in\n  (* Define and start and main function *)\n  let main_type = Llvm.function_type i32 [| |] in\n  let main = Llvm.declare_function \"main\" main_type the_module in\n  let bb = Llvm.append_block context \"entry\" main in\n  Llvm.position_at_end bb builder;\n  (* Emit the program code *)\n  let info = {\n    context          = context;\n    the_module       = the_module;\n    builder          = builder;\n    i8               = i8;\n    i32              = i32;\n    i64              = i64;\n    c32              = c32;\n    c64              = c64;\n    the_vars         = the_vars;\n    the_nl           = the_nl;\n    the_writeInteger = the_writeInteger;\n    the_writeString  = the_writeString;\n  } in\n  List.iter (compile_stmt info) asts;\n  ignore (Llvm.build_ret (c32 0) builder);\n  (* Verify *)\n  Llvm_analysis.assert_valid_module the_module;\n  (* Optimize *)\n  ignore (Llvm.PassManager.run_module the_module pm);\n  (* Print out the IR *)\n  Llvm.print_module \"a.ll\" the_module\n"}}}
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/tsimiho/Desktop/NTUA/ECE/Semester8/%CE%9C%CE%B5%CF%84%CE%B1%CE%B3%CE%BB%CF%89%CF%84%CF%84%CE%B9%CF%83%CF%84%CE%AD%CF%82/minibasic_llvm/Ast.ml","version":2},"contentChanges":[{"text":"type var  = char\ntype oper = O_plus | O_minus | O_times\n\ntype ast_stmt =\n| S_print of ast_expr\n| S_let of var * ast_expr\n| S_for of ast_expr * ast_stmt\n| S_block of ast_stmt list\n| S_if of ast_expr * ast_stmt\n\nand ast_expr =\n| E_const of int\n| E_var of var\n| E_op of ast_expr * oper * ast_expr\n\nlet vars = Array.make 26 0\n\nlet rec run_expr ast =\n  match ast with\n  | E_const n         -> n\n  | E_var x           -> vars.(int_of_char x - int_of_char 'a')\n  | E_op (e1, op, e2) -> let v1 = run_expr e1\n                         and v2 = run_expr e2 in\n                         match op with\n                         | O_plus  -> v1 + v2\n                         | O_minus -> v1 - v2\n                         | O_times -> v1 * v2\n\nlet rec run_stmt ast =\n  match ast with\n  | S_print e    -> let v = run_expr e in\n                    Printf.printf \"%d\\n\" v\n  | S_let (x, e) -> let v = run_expr e in\n                    vars.(int_of_char x - int_of_char 'a') <- v\n  | S_for (e, s) -> let v = run_expr e in\n                    for i = 1 to v do\n                      run_stmt s\n                    done\n  | S_block b    -> run b\n  | S_if (e, s)  -> let v = run_expr e in\n                    if v <> 0 then run_stmt s\n\nand run asts = List.iter run_stmt asts\n\ntype llvm_info = {\n  context          : Llvm.llcontext;\n  the_module       : Llvm.llmodule;\n  builder          : Llvm.llbuilder;\n  i8               : Llvm.lltype;\n  i32              : Llvm.lltype;\n  i64              : Llvm.lltype;\n  c32              : int -> Llvm.llvalue;\n  c64              : int -> Llvm.llvalue;\n  the_vars         : Llvm.llvalue;\n  the_nl           : Llvm.llvalue;\n  the_writeInteger : Llvm.llvalue;\n  the_writeString  : Llvm.llvalue;\n}\n\nlet rec compile_expr info ast =\n  match ast with\n  | E_const n         -> info.c64 n\n  | E_var x           -> let n = int_of_char x - int_of_char 'a' in\n                         let v = Llvm.build_gep info.the_vars\n                                                [| info.c32 0; info.c32 n |]\n                                                (String.make 1 x ^ \"_ptr\")\n                                                info.builder in\n                         Llvm.build_load v (String.make 1 x) info.builder\n  | E_op (e1, op, e2) -> let l = compile_expr info e1 in\n                         let r = compile_expr info e2 in\n                         begin\n                           match op with\n                           | O_plus  -> Llvm.build_add l r \"addtmp\" info.builder\n                           | O_minus -> Llvm.build_sub l r \"subtmp\" info.builder\n                           | O_times -> Llvm.build_mul l r \"multmp\" info.builder\n                         end\n\nlet rec compile_stmt info ast =\n  match ast with\n  | S_print e    -> let n = compile_expr info e in\n                    ignore (Llvm.build_call info.the_writeInteger [| n |] \"\"\n                                            info.builder);\n                    let nl = Llvm.build_gep info.the_nl\n                                            [| info.c32 0; info.c32 0 |]\n                                            \"nl\" info.builder in\n                    ignore (Llvm.build_call info.the_writeString [| nl |] \"\"\n                                            info.builder)\n  | S_let (x, e) -> let n = int_of_char x - int_of_char 'a' in\n                    let l = Llvm.build_gep info.the_vars\n                                           [| info.c32 0; info.c32 n |]\n                                           (String.make 1 x ^ \"_ptr\")\n                                           info.builder in\n                    let r = compile_expr info e in\n                    ignore (Llvm.build_store r l info.builder)\n  | S_for (e, s) -> let n = compile_expr info e in\n                    let bb = Llvm.insertion_block info.builder in\n                    let f = Llvm.block_parent bb in\n                    let loop_bb = Llvm.append_block info.context \"loop\" f in\n                    let body_bb = Llvm.append_block info.context \"body\" f in\n                    let after_bb = Llvm.append_block info.context \"after\" f in\n                    ignore (Llvm.build_br loop_bb info.builder);\n                    Llvm.position_at_end loop_bb info.builder;\n                    let phi_iter =\n                      Llvm.build_phi [(n, bb)] \"iter\" info.builder in\n                    let loop_cond =\n                      Llvm.build_icmp Llvm.Icmp.Sgt phi_iter (info.c64 0)\n                                      \"loop_cond\" info.builder in\n                    ignore (Llvm.build_cond_br loop_cond body_bb after_bb\n                                               info.builder);\n                    Llvm.position_at_end body_bb info.builder;\n                    let remaining = Llvm.build_sub phi_iter (info.c64 1)\n                                                   \"remaining\" info.builder in\n                    compile_stmt info s;\n                    Llvm.add_incoming\n                      (remaining, Llvm.insertion_block info.builder) phi_iter;\n                    ignore (Llvm.build_br loop_bb info.builder);\n                    Llvm.position_at_end after_bb info.builder\n  | S_block b    -> List.iter (compile_stmt info) b\n  | S_if (e, s)  -> let v = compile_expr info e in\n                    let cond = Llvm.build_icmp Llvm.Icmp.Ne v (info.c64 0)\n                                               \"if_cond\" info.builder in\n                    let bb = Llvm.insertion_block info.builder in\n                    let f = Llvm.block_parent bb in\n                    let then_bb = Llvm.append_block info.context \"then\" f in\n                    let after_bb = Llvm.append_block info.context \"after\" f in\n                    ignore (Llvm.build_cond_br cond then_bb after_bb\n                                               info.builder);\n                    Llvm.position_at_end then_bb info.builder;\n                    compile_stmt info s;\n                    ignore (Llvm.build_br after_bb info.builder);\n                    Llvm.position_at_end after_bb info.builder\n\nlet llvm_compile_and_dump asts =\n  (* Initialize *)\n  Llvm_all_backends.initialize ();\n  let context = Llvm.global_context () in\n  let the_module = Llvm.create_module context \"minibasic program\" in\n  let builder = Llvm.builder context in\n  let pm = Llvm.PassManager.create () in\n  List.iter (fun f -> f pm) [\n    Llvm_scalar_opts.add_memory_to_register_promotion;\n    Llvm_scalar_opts.add_instruction_combination;\n    Llvm_scalar_opts.add_reassociation;\n    Llvm_scalar_opts.add_gvn;\n    Llvm_scalar_opts.add_cfg_simplification;\n  ];\n  (* Initialize types *)\n  let i8 = Llvm.i8_type context in\n  let i32 = Llvm.i32_type context in\n  let i64 = Llvm.i64_type context in\n  (* Initialize constant functions *)\n  let c32 = Llvm.const_int i32 in\n  let c64 = Llvm.const_int i64 in\n  (* Initialize global variables *)\n  let vars_type = Llvm.array_type i64 26 in\n  let the_vars = Llvm.declare_global vars_type \"vars\" the_module in\n  Llvm.set_linkage Llvm.Linkage.Private the_vars;\n  Llvm.set_initializer (Llvm.const_null vars_type) the_vars;\n  Llvm.set_alignment 16 the_vars;\n  let nl = \"\\n\" in\n  let nl_type = Llvm.array_type i8 (1 + String.length nl) in\n  let the_nl = Llvm.declare_global nl_type \"nl\" the_module in\n  Llvm.set_linkage Llvm.Linkage.Private the_nl;\n  Llvm.set_global_constant true the_nl;\n  Llvm.set_initializer (Llvm.const_stringz context nl) the_nl;\n  Llvm.set_alignment 1 the_nl;\n  (* Initialize library functions *)\n  let writeInteger_type =\n    Llvm.function_type (Llvm.void_type context) [| i64 |] in\n  let the_writeInteger =\n    Llvm.declare_function \"writeInteger\" writeInteger_type the_module in\n  let writeString_type =\n    Llvm.function_type (Llvm.void_type context) [| Llvm.pointer_type i8 |] in\n  let the_writeString =\n    Llvm.declare_function \"writeString\" writeString_type the_module in\n  (* Define and start and main function *)\n  let main_type = Llvm.function_type i32 [| |] in\n  let main = Llvm.declare_function \"main\" main_type the_module in\n  let bb = Llvm.append_block context \"entry\" main in\n  Llvm.position_at_end bb builder;\n  (* Emit the program code *)\n  let info = {\n    context          = context;\n    the_module       = the_module;\n    builder          = builder;\n    i8               = i8;\n    i32              = i32;\n    i64              = i64;\n    c32              = c32;\n    c64              = c64;\n    the_vars         = the_vars;\n    the_nl           = the_nl;\n    the_writeInteger = the_writeInteger;\n    the_writeString  = the_writeString;\n  } in\n  List.iter (compile_stmt info) asts;\n  ignore (Llvm.build_ret (c32 0) builder);\n  (* Verify *)\n  Llvm_analysis.assert_valid_module the_module;\n  (* Optimize *)\n  ignore (Llvm.PassManager.run_module the_module pm);\n  (* Print out the IR *)\n  Llvm.print_module \"a.ll\" the_module\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/tsimiho/Desktop/NTUA/ECE/Semester8/%CE%9C%CE%B5%CF%84%CE%B1%CE%B3%CE%BB%CF%89%CF%84%CF%84%CE%B9%CF%83%CF%84%CE%AD%CF%82/minibasic_llvm/Ast.ml","version":3},"contentChanges":[{"text":"type var  = char\ntype oper = O_plus | O_minus | O_times\n\ntype ast_stmt =\n| S_print of ast_expr\n| S_let of var * ast_expr\n| S_for of ast_expr * ast_stmt\n| S_block of ast_stmt list\n| S_if of ast_expr * ast_stmt\n\nand ast_expr =\n| E_const of int\n| E_var of var\n| E_op of ast_expr * oper * ast_expr\n\nlet vars = Array.make 26 0\n\nlet rec run_expr ast =\n  match ast with\n  | E_const n         -> n\n  | E_var x           -> vars.(int_of_char x - int_of_char 'a')\n  | E_op (e1, op, e2) -> let v1 = run_expr e1\n                         and v2 = run_expr e2 in\n                         match op with\n                         | O_plus  -> v1 + v2\n                         | O_minus -> v1 - v2\n                         | O_times -> v1 * v2\n\nlet rec run_stmt ast =\n  match ast with\n  | S_print e    -> let v = run_expr e in\n                    Printf.printf \"%d\\n\" v\n  | S_let (x, e) -> let v = run_expr e in\n                    vars.(int_of_char x - int_of_char 'a') <- v\n  | S_for (e, s) -> let v = run_expr e in\n                    for i = 1 to v do\n                      run_stmt s\n                    done\n  | S_block b    -> run b\n  | S_if (e, s)  -> let v = run_expr e in\n                    if v <> 0 then run_stmt s\n\nand run asts = List.iter run_stmt asts\n\ntype llvm_info = {\n  context          : Llvm.llcontext;\n  the_module       : Llvm.llmodule;\n  builder          : Llvm.llbuilder;\n  i8               : Llvm.lltype;\n  i32              : Llvm.lltype;\n  i64              : Llvm.lltype;\n  c32              : int -> Llvm.llvalue;\n  c64              : int -> Llvm.llvalue;\n  the_vars         : Llvm.llvalue;\n  the_nl           : Llvm.llvalue;\n  the_writeInteger : Llvm.llvalue;\n  the_writeString  : Llvm.llvalue;\n}\n\nlet rec compile_expr info ast =\n  match ast with\n  | E_const n         -> info.c64 n\n  | E_var x           -> let n = int_of_char x - int_of_char 'a' in\n                         let v = Llvm.build_gep info.the_vars\n                                                [| info.c32 0; info.c32 n |]\n                                                (String.make 1 x ^ \"_ptr\")\n                                                info.builder in\n                         Llvm.build_load v (String.make 1 x) info.builder\n  | E_op (e1, op, e2) -> let l = compile_expr info e1 in\n                         let r = compile_expr info e2 in\n                         begin\n                           match op with\n                           | O_plus  -> Llvm.build_add l r \"addtmp\" info.builder\n                           | O_minus -> Llvm.build_sub l r \"subtmp\" info.builder\n                           | O_times -> Llvm.build_mul l r \"multmp\" info.builder\n                         end\n\nlet rec compile_stmt info ast =\n  match ast with\n  | S_print e    -> let n = compile_expr info e in\n                    ignore (Llvm.build_call info.the_writeInteger [| n |] \"\"\n                                            info.builder);\n                    let nl = Llvm.build_gep info.the_nl\n                                            [| info.c32 0; info.c32 0 |]\n                                            \"nl\" info.builder in\n                    ignore (Llvm.build_call info.the_writeString [| nl |] \"\"\n                                            info.builder)\n  | S_let (x, e) -> let n = int_of_char x - int_of_char 'a' in\n                    let l = Llvm.build_gep info.the_vars\n                                           [| info.c32 0; info.c32 n |]\n                                           (String.make 1 x ^ \"_ptr\")\n                                           info.builder in\n                    let r = compile_expr info e in\n                    ignore (Llvm.build_store r l info.builder)\n  | S_for (e, s) -> let n = compile_expr info e in\n                    let bb = Llvm.insertion_block info.builder in\n                    let f = Llvm.block_parent bb in\n                    let loop_bb = Llvm.append_block info.context \"loop\" f in\n                    let body_bb = Llvm.append_block info.context \"body\" f in\n                    let after_bb = Llvm.append_block info.context \"after\" f in\n                    ignore (Llvm.build_br loop_bb info.builder);\n                    Llvm.position_at_end loop_bb info.builder;\n                    let phi_iter =\n                      Llvm.build_phi [(n, bb)] \"iter\" info.builder in\n                    let loop_cond =\n                      Llvm.build_icmp Llvm.Icmp.Sgt phi_iter (info.c64 0)\n                                      \"loop_cond\" info.builder in\n                    ignore (Llvm.build_cond_br loop_cond body_bb after_bb\n                                               info.builder);\n                    Llvm.position_at_end body_bb info.builder;\n                    let remaining = Llvm.build_sub phi_iter (info.c64 1)\n                                                   \"remaining\" info.builder in\n                    compile_stmt info s;\n                    Llvm.add_incoming\n                      (remaining, Llvm.insertion_block info.builder) phi_iter;\n                    ignore (Llvm.build_br loop_bb info.builder);\n                    Llvm.position_at_end after_bb info.builder\n  | S_block b    -> List.iter (compile_stmt info) b\n  | S_if (e, s)  -> let v = compile_expr info e in\n                    let cond = Llvm.build_icmp Llvm.Icmp.Ne v (info.c64 0)\n                                               \"if_cond\" info.builder in\n                    let bb = Llvm.insertion_block info.builder in\n                    let f = Llvm.block_parent bb in\n                    let then_bb = Llvm.append_block info.context \"then\" f in\n                    let after_bb = Llvm.append_block info.context \"after\" f in\n                    ignore (Llvm.build_cond_br cond then_bb after_bb\n                                               info.builder);\n                    Llvm.position_at_end then_bb info.builder;\n                    compile_stmt info s;\n                    ignore (Llvm.build_br after_bb info.builder);\n                    Llvm.position_at_end after_bb info.builder\n\nlet llvm_compile_and_dump asts =\n  (* Initialize *)\n  Llvm_all_backends.initialize ();\n  let context = Llvm.global_context () in\n  let the_module = Llvm.create_module context \"minibasic program\" in\n  let builder = Llvm.builder context in\n  let pm = Llvm.PassManager.create () in\n  List.iter (fun f -> f pm) [\n    Llvm_scalar_opts.add_memory_to_register_promotion;\n    Llvm_scalar_opts.add_instruction_combination;\n    Llvm_scalar_opts.add_reassociation;\n    Llvm_scalar_opts.add_gvn;\n    Llvm_scalar_opts.add_cfg_simplification;\n  ];\n  (* Initialize types *)\n  let i8 = Llvm.i8_type context in\n  let i32 = Llvm.i32_type context in\n  let i64 = Llvm.i64_type context in\n  (* Initialize constant functions *)\n  let c32 = Llvm.const_int i32 in\n  let c64 = Llvm.const_int i64 in\n  (* Initialize global variables *)\n  let vars_type = Llvm.array_type i64 26 in\n  let the_vars = Llvm.declare_global vars_type \"vars\" the_module in\n  Llvm.set_linkage Llvm.Linkage.Private the_vars;\n  Llvm.set_initializer (Llvm.const_null vars_type) the_vars;\n  Llvm.set_alignment 16 the_vars;\n  let nl = \"\\n\" in\n  let nl_type = Llvm.array_type i8 (1 + String.length nl) in\n  let the_nl = Llvm.declare_global nl_type \"nl\" the_module in\n  Llvm.set_linkage Llvm.Linkage.Private the_nl;\n  Llvm.set_global_constant true the_nl;\n  Llvm.set_initializer (Llvm.const_stringz context nl) the_nl;\n  Llvm.set_alignment 1 the_nl;\n  (* Initialize library functions *)\n  let writeInteger_type =\n    Llvm.function_type (Llvm.void_type context) [| i64 |] in\n  let the_writeInteger =\n    Llvm.declare_function \"writeInteger\" writeInteger_type the_module in\n  let writeString_type =\n    Llvm.function_type (Llvm.void_type context) [| Llvm.pointer_type i8 |] in\n  let the_writeString =\n    Llvm.declare_function \"writeString\" writeString_type the_module in\n  (* Define and start and main function *)\n  let main_type = Llvm.function_type i32 [| |] in\n  let main = Llvm.declare_function \"main\" main_type the_module in\n  let bb = Llvm.append_block context \"entry\" main in\n  Llvm.position_at_end bb builder;\n  (* Emit the program code *)\n  let info = {\n    context          = context;\n    the_module       = the_module;\n    builder          = builder;\n    i8               = i8;\n    i32              = i32;\n    i64              = i64;\n    c32              = c32;\n    c64              = c64;\n    the_vars         = the_vars;\n    the_nl           = the_nl;\n    the_writeInteger = the_writeInteger;\n    the_writeString  = the_writeString;\n  } in\n  List.iter (compile_stmt info) asts;\n  ignore (Llvm.build_ret (c32 0) builder);\n  (* Verify *)\n  Llvm_analysis.assert_valid_module the_module;\n  (* Optimize *)\n  ignore (Llvm.PassManager.run_module the_module pm);\n  (* Print out the IR *)\n  Llvm.print_module \"a.ll\" the_module\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/tsimiho/Desktop/NTUA/ECE/Semester8/%CE%9C%CE%B5%CF%84%CE%B1%CE%B3%CE%BB%CF%89%CF%84%CF%84%CE%B9%CF%83%CF%84%CE%AD%CF%82/minibasic_llvm/Ast.ml","version":4},"contentChanges":[{"text":"type var  = char\ntype oper = O_plus | O_minus | O_times\n\ntype ast_stmt =\n| S_print of ast_expr\n| S_let of var * ast_expr\n| S_for of ast_expr * ast_stmt\n| S_block of ast_stmt list\n| S_if of ast_expr * ast_stmt\n\nand ast_expr =\n| E_const of int\n| E_var of var\n| E_op of ast_expr * oper * ast_expr\n\nlet vars = Array.make 26 0\n\nlet rec run_expr ast =\n  match ast with\n  | E_const n         -> n\n  | E_var x           -> vars.(int_of_char x - int_of_char 'a')\n  | E_op (e1, op, e2) -> let v1 = run_expr e1\n                         and v2 = run_expr e2 in\n                         match op with\n                         | O_plus  -> v1 + v2\n                         | O_minus -> v1 - v2\n                         | O_times -> v1 * v2\n\nlet rec run_stmt ast =\n  match ast with\n  | S_print e    -> let v = run_expr e in\n                    Printf.printf \"%d\\n\" v\n  | S_let (x, e) -> let v = run_expr e in\n                    vars.(int_of_char x - int_of_char 'a') <- v\n  | S_for (e, s) -> let v = run_expr e in\n                    for i = 1 to v do\n                      run_stmt s\n                    done\n  | S_block b    -> run b\n  | S_if (e, s)  -> let v = run_expr e in\n                    if v <> 0 then run_stmt s\n\nand run asts = List.iter run_stmt asts\n\ntype llvm_info = {\n  context          : Llvm.llcontext;\n  the_module       : Llvm.llmodule;\n  builder          : Llvm.llbuilder;\n  i8               : Llvm.lltype;\n  i32              : Llvm.lltype;\n  i64              : Llvm.lltype;\n  c32              : int -> Llvm.llvalue;\n  c64              : int -> Llvm.llvalue;\n  the_vars         : Llvm.llvalue;\n  the_nl           : Llvm.llvalue;\n  the_writeInteger : Llvm.llvalue;\n  the_writeString  : Llvm.llvalue;\n}\n\nlet rec compile_expr info ast =\n  match ast with\n  | E_const n         -> info.c64 n\n  | E_var x           -> let n = int_of_char x - int_of_char 'a' in\n                         let v = Llvm.build_gep info.the_vars\n                                                [| info.c32 0; info.c32 n |]\n                                                (String.make 1 x ^ \"_ptr\")\n                                                info.builder in\n                         Llvm.build_load v (String.make 1 x) info.builder\n  | E_op (e1, op, e2) -> let l = compile_expr info e1 in\n                         let r = compile_expr info e2 in\n                         begin\n                           match op with\n                           | O_plus  -> Llvm.build_add l r \"addtmp\" info.builder\n                           | O_minus -> Llvm.build_sub l r \"subtmp\" info.builder\n                           | O_times -> Llvm.build_mul l r \"multmp\" info.builder\n                         end\n\nlet rec compile_stmt info ast =\n  match ast with\n  | S_print e    -> let n = compile_expr info e in\n                    ignore (Llvm.build_call info.the_writeInteger [| n |] \"\"\n                                            info.builder);\n                    let nl = Llvm.build_gep info.the_nl\n                                            [| info.c32 0; info.c32 0 |]\n                                            \"nl\" info.builder in\n                    ignore (Llvm.build_call info.the_writeString [| nl |] \"\"\n                                            info.builder)\n  | S_let (x, e) -> let n = int_of_char x - int_of_char 'a' in\n                    let l = Llvm.build_gep info.the_vars\n                                           [| info.c32 0; info.c32 n |]\n                                           (String.make 1 x ^ \"_ptr\")\n                                           info.builder in\n                    let r = compile_expr info e in\n                    ignore (Llvm.build_store r l info.builder)\n  | S_for (e, s) -> let n = compile_expr info e in\n                    let bb = Llvm.insertion_block info.builder in\n                    let f = Llvm.block_parent bb in\n                    let loop_bb = Llvm.append_block info.context \"loop\" f in\n                    let body_bb = Llvm.append_block info.context \"body\" f in\n                    let after_bb = Llvm.append_block info.context \"after\" f in\n                    ignore (Llvm.build_br loop_bb info.builder);\n                    Llvm.position_at_end loop_bb info.builder;\n                    let phi_iter =\n                      Llvm.build_phi [(n, bb)] \"iter\" info.builder in\n                    let loop_cond =\n                      Llvm.build_icmp Llvm.Icmp.Sgt phi_iter (info.c64 0)\n                                      \"loop_cond\" info.builder in\n                    ignore (Llvm.build_cond_br loop_cond body_bb after_bb\n                                               info.builder);\n                    Llvm.position_at_end body_bb info.builder;\n                    let remaining = Llvm.build_sub phi_iter (info.c64 1)\n                                                   \"remaining\" info.builder in\n                    compile_stmt info s;\n                    Llvm.add_incoming\n                      (remaining, Llvm.insertion_block info.builder) phi_iter;\n                    ignore (Llvm.build_br loop_bb info.builder);\n                    Llvm.position_at_end after_bb info.builder\n  | S_block b    -> List.iter (compile_stmt info) b\n  | S_if (e, s)  -> let v = compile_expr info e in\n                    let cond = Llvm.build_icmp Llvm.Icmp.Ne v (info.c64 0)\n                                               \"if_cond\" info.builder in\n                    let bb = Llvm.insertion_block info.builder in\n                    let f = Llvm.block_parent bb in\n                    let then_bb = Llvm.append_block info.context \"then\" f in\n                    let after_bb = Llvm.append_block info.context \"after\" f in\n                    ignore (Llvm.build_cond_br cond then_bb after_bb\n                                               info.builder);\n                    Llvm.position_at_end then_bb info.builder;\n                    compile_stmt info s;\n                    ignore (Llvm.build_br after_bb info.builder);\n                    Llvm.position_at_end after_bb info.builder\n\nlet llvm_compile_and_dump asts =\n  (* Initialize *)\n  Llvm_all_backends.initialize ();\n  let context = Llvm.global_context () in\n  let the_module = Llvm.create_module context \"minibasic program\" in\n  let builder = Llvm.builder context in\n  let pm = Llvm.PassManager.create () in\n  List.iter (fun f -> f pm) [\n    Llvm_scalar_opts.add_memory_to_register_promotion;\n    Llvm_scalar_opts.add_instruction_combination;\n    Llvm_scalar_opts.add_reassociation;\n    Llvm_scalar_opts.add_gvn;\n    Llvm_scalar_opts.add_cfg_simplification;\n  ];\n  (* Initialize types *)\n  let i8 = Llvm.i8_type context in\n  let i32 = Llvm.i32_type context in\n  let i64 = Llvm.i64_type context in\n  (* Initialize constant functions *)\n  let c32 = Llvm.const_int i32 in\n  let c64 = Llvm.const_int i64 in\n  (* Initialize global variables *)\n  let vars_type = Llvm.array_type i64 26 in\n  let the_vars = Llvm.declare_global vars_type \"vars\" the_module in\n  Llvm.set_linkage Llvm.Linkage.Private the_vars;\n  Llvm.set_initializer (Llvm.const_null vars_type) the_vars;\n  Llvm.set_alignment 16 the_vars;\n  let nl = \"\\n\" in\n  let nl_type = Llvm.array_type i8 (1 + String.length nl) in\n  let the_nl = Llvm.declare_global nl_type \"nl\" the_module in\n  Llvm.set_linkage Llvm.Linkage.Private the_nl;\n  Llvm.set_global_constant true the_nl;\n  Llvm.set_initializer (Llvm.const_stringz context nl) the_nl;\n  Llvm.set_alignment 1 the_nl;\n  (* Initialize library functions *)\n  let writeInteger_type =\n    Llvm.function_type (Llvm.void_type context) [| i64 |] in\n  let the_writeInteger =\n    Llvm.declare_function \"writeInteger\" writeInteger_type the_module in\n  let writeString_type =\n    Llvm.function_type (Llvm.void_type context) [| Llvm.pointer_type i8 |] in\n  let the_writeString =\n    Llvm.declare_function \"writeString\" writeString_type the_module in\n  (* Define and start and main function *)\n  let main_type = Llvm.function_type i32 [| |] in\n  let main = Llvm.declare_function \"main\" main_type the_module in\n  let bb = Llvm.append_block context \"entry\" main in\n  Llvm.position_at_end bb builder;\n  (* Emit the program code *)\n  let info = {\n    context          = context;\n    the_module       = the_module;\n    builder          = builder;\n    i8               = i8;\n    i32              = i32;\n    i64              = i64;\n    c32              = c32;\n    c64              = c64;\n    the_vars         = the_vars;\n    the_nl           = the_nl;\n    the_writeInteger = the_writeInteger;\n    the_writeString  = the_writeString;\n  } in\n  List.iter (compile_stmt info) asts;\n  ignore (Llvm.build_ret (c32 0) builder);\n  (* Verify *)\n  Llvm_analysis.assert_valid_module the_module;\n  (* Optimize *)\n  ignore (Llvm.PassManager.run_module the_module pm);\n  (* Print out the IR *)\n  Llvm.print_module \"a.ll\" the_module\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/tsimiho/Desktop/NTUA/ECE/Semester8/%CE%9C%CE%B5%CF%84%CE%B1%CE%B3%CE%BB%CF%89%CF%84%CF%84%CE%B9%CF%83%CF%84%CE%AD%CF%82/minibasic_llvm/Ast.ml","version":5},"contentChanges":[{"text":"type var  = char\ntype oper = O_plus | O_minus | O_times\n\ntype ast_stmt =\n| S_print of ast_expr\n| S_let of var * ast_expr\n| S_for of ast_expr * ast_stmt\n| S_block of ast_stmt list\n| S_if of ast_expr * ast_stmt\n\nand ast_expr =\n| E_const of int\n| E_var of var\n| E_op of ast_expr * oper * ast_expr\n\nlet vars = Array.make 26 0\n\nlet rec run_expr ast =\n  match ast with\n  | E_const n         -> n\n  | E_var x           -> vars.(int_of_char x - int_of_char 'a')\n  | E_op (e1, op, e2) -> let v1 = run_expr e1\n                         and v2 = run_expr e2 in\n                         match op with\n                         | O_plus  -> v1 + v2\n                         | O_minus -> v1 - v2\n                         | O_times -> v1 * v2\n\nlet rec run_stmt ast =\n  match ast with\n  | S_print e    -> let v = run_expr e in\n                    Printf.printf \"%d\\n\" v\n  | S_let (x, e) -> let v = run_expr e in\n                    vars.(int_of_char x - int_of_char 'a') <- v\n  | S_for (e, s) -> let v = run_expr e in\n                    for i = 1 to v do\n                      run_stmt s\n                    done\n  | S_block b    -> run b\n  | S_if (e, s)  -> let v = run_expr e in\n                    if v <> 0 then run_stmt s\n\nand run asts = List.iter run_stmt asts\n\ntype llvm_info = {\n  context          : Llvm.llcontext;\n  the_module       : Llvm.llmodule;\n  builder          : Llvm.llbuilder;\n  i8               : Llvm.lltype;\n  i32              : Llvm.lltype;\n  i64              : Llvm.lltype;\n  c32              : int -> Llvm.llvalue;\n  c64              : int -> Llvm.llvalue;\n  the_vars         : Llvm.llvalue;\n  the_nl           : Llvm.llvalue;\n  the_writeInteger : Llvm.llvalue;\n  the_writeString  : Llvm.llvalue;\n}\n\nlet rec compile_expr info ast =\n  match ast with\n  | E_const n         -> info.c64 n\n  | E_var x           -> let n = int_of_char x - int_of_char 'a' in\n                         let v = Llvm.build_gep info.the_vars\n                                                [| info.c32 0; info.c32 n |]\n                                                (String.make 1 x ^ \"_ptr\")\n                                                info.builder in\n                         Llvm.build_load v (String.make 1 x) info.builder\n  | E_op (e1, op, e2) -> let l = compile_expr info e1 in\n                         let r = compile_expr info e2 in\n                         begin\n                           match op with\n                           | O_plus  -> Llvm.build_add l r \"addtmp\" info.builder\n                           | O_minus -> Llvm.build_sub l r \"subtmp\" info.builder\n                           | O_times -> Llvm.build_mul l r \"multmp\" info.builder\n                         end\n\nlet rec compile_stmt info ast =\n  match ast with\n  | S_print e    -> let n = compile_expr info e in\n                    ignore (Llvm.build_call info.the_writeInteger [| n |] \"\"\n                                            info.builder);\n                    let nl = Llvm.build_gep info.the_nl\n                                            [| info.c32 0; info.c32 0 |]\n                                            \"nl\" info.builder in\n                    ignore (Llvm.build_call info.the_writeString [| nl |] \"\"\n                                            info.builder)\n  | S_let (x, e) -> let n = int_of_char x - int_of_char 'a' in\n                    let l = Llvm.build_gep info.the_vars\n                                           [| info.c32 0; info.c32 n |]\n                                           (String.make 1 x ^ \"_ptr\")\n                                           info.builder in\n                    let r = compile_expr info e in\n                    ignore (Llvm.build_store r l info.builder)\n  | S_for (e, s) -> let n = compile_expr info e in\n                    let bb = Llvm.insertion_block info.builder in\n                    let f = Llvm.block_parent bb in\n                    let loop_bb = Llvm.append_block info.context \"loop\" f in\n                    let body_bb = Llvm.append_block info.context \"body\" f in\n                    let after_bb = Llvm.append_block info.context \"after\" f in\n                    ignore (Llvm.build_br loop_bb info.builder);\n                    Llvm.position_at_end loop_bb info.builder;\n                    let phi_iter =\n                      Llvm.build_phi [(n, bb)] \"iter\" info.builder in\n                    let loop_cond =\n                      Llvm.build_icmp Llvm.Icmp.Sgt phi_iter (info.c64 0)\n                                      \"loop_cond\" info.builder in\n                    ignore (Llvm.build_cond_br loop_cond body_bb after_bb\n                                               info.builder);\n                    Llvm.position_at_end body_bb info.builder;\n                    let remaining = Llvm.build_sub phi_iter (info.c64 1)\n                                                   \"remaining\" info.builder in\n                    compile_stmt info s;\n                    Llvm.add_incoming\n                      (remaining, Llvm.insertion_block info.builder) phi_iter;\n                    ignore (Llvm.build_br loop_bb info.builder);\n                    Llvm.position_at_end after_bb info.builder\n  | S_block b    -> List.iter (compile_stmt info) b\n  | S_if (e, s)  -> let v = compile_expr info e in\n                    let cond = Llvm.build_icmp Llvm.Icmp.Ne v (info.c64 0)\n                                               \"if_cond\" info.builder in\n                    let bb = Llvm.insertion_block info.builder in\n                    let f = Llvm.block_parent bb in\n                    let then_bb = Llvm.append_block info.context \"then\" f in\n                    let after_bb = Llvm.append_block info.context \"after\" f in\n                    ignore (Llvm.build_cond_br cond then_bb after_bb\n                                               info.builder);\n                    Llvm.position_at_end then_bb info.builder;\n                    compile_stmt info s;\n                    ignore (Llvm.build_br after_bb info.builder);\n                    Llvm.position_at_end after_bb info.builder\n\nlet llvm_compile_and_dump asts =\n  (* Initialize *)\n  Llvm_all_backends.initialize ();\n  let context = Llvm.global_context () in\n  let the_module = Llvm.create_module context \"minibasic program\" in\n  let builder = Llvm.builder context in\n  let pm = Llvm.PassManager.create () in\n  List.iter (fun f -> f pm) [\n    Llvm_scalar_opts.add_memory_to_register_promotion;\n    Llvm_scalar_opts.add_instruction_combination;\n    Llvm_scalar_opts.add_reassociation;\n    Llvm_scalar_opts.add_gvn;\n    Llvm_scalar_opts.add_cfg_simplification;\n  ];\n  (* Initialize types *)\n  let i8 = Llvm.i8_type context in\n  let i32 = Llvm.i32_type context in\n  let i64 = Llvm.i64_type context in\n  (* Initialize constant functions *)\n  let c32 = Llvm.const_int i32 in\n  let c64 = Llvm.const_int i64 in\n  (* Initialize global variables *)\n  let vars_type = Llvm.array_type i64 26 in\n  let the_vars = Llvm.declare_global vars_type \"vars\" the_module in\n  Llvm.set_linkage Llvm.Linkage.Private the_vars;\n  Llvm.set_initializer (Llvm.const_null vars_type) the_vars;\n  Llvm.set_alignment 16 the_vars;\n  let nl = \"\\n\" in\n  let nl_type = Llvm.array_type i8 (1 + String.length nl) in\n  let the_nl = Llvm.declare_global nl_type \"nl\" the_module in\n  Llvm.set_linkage Llvm.Linkage.Private the_nl;\n  Llvm.set_global_constant true the_nl;\n  Llvm.set_initializer (Llvm.const_stringz context nl) the_nl;\n  Llvm.set_alignment 1 the_nl;\n  (* Initialize library functions *)\n  let writeInteger_type =\n    Llvm.function_type (Llvm.void_type context) [| i64 |] in\n  let the_writeInteger =\n    Llvm.declare_function \"writeInteger\" writeInteger_type the_module in\n  let writeString_type =\n    Llvm.function_type (Llvm.void_type context) [| Llvm.pointer_type i8 |] in\n  let the_writeString =\n    Llvm.declare_function \"writeString\" writeString_type the_module in\n  (* Define and start and main function *)\n  let main_type = Llvm.function_type i32 [| |] in\n  let main = Llvm.declare_function \"main\" main_type the_module in\n  let bb = Llvm.append_block context \"entry\" main in\n  Llvm.position_at_end bb builder;\n  (* Emit the program code *)\n  let info = {\n    context          = context;\n    the_module       = the_module;\n    builder          = builder;\n    i8               = i8;\n    i32              = i32;\n    i64              = i64;\n    c32              = c32;\n    c64              = c64;\n    the_vars         = the_vars;\n    the_nl           = the_nl;\n    the_writeInteger = the_writeInteger;\n    the_writeString  = the_writeString;\n  } in\n  List.iter (compile_stmt info) asts;\n  ignore (Llvm.build_ret (c32 0) builder);\n  (* Verify *)\n  Llvm_analysis.assert_valid_module the_module;\n  (* Optimize *)\n  ignore (Llvm.PassManager.run_module the_module pm);\n  (* Print out the IR *)\n  Llvm.print_module \"a.ll\" the_module\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/tsimiho/Desktop/NTUA/ECE/Semester8/%CE%9C%CE%B5%CF%84%CE%B1%CE%B3%CE%BB%CF%89%CF%84%CF%84%CE%B9%CF%83%CF%84%CE%AD%CF%82/minibasic_llvm/Ast.ml","version":6},"contentChanges":[{"text":"type var  = char\ntype oper = O_plus | O_minus | O_times\n\ntype ast_stmt =\n| S_print of ast_expr\n| S_let of var * ast_expr\n| S_for of ast_expr * ast_stmt\n| S_block of ast_stmt list\n| S_if of ast_expr * ast_stmt\n\nand ast_expr =\n| E_const of int\n| E_var of var\n| E_op of ast_expr * oper * ast_expr\n\nlet vars = Array.make 26 0\n\nlet rec run_expr ast =\n  match ast with\n  | E_const n         -> n\n  | E_var x           -> vars.(int_of_char x - int_of_char 'a')\n  | E_op (e1, op, e2) -> let v1 = run_expr e1\n                         and v2 = run_expr e2 in\n                         match op with\n                         | O_plus  -> v1 + v2\n                         | O_minus -> v1 - v2\n                         | O_times -> v1 * v2\n\nlet rec run_stmt ast =\n  match ast with\n  | S_print e    -> let v = run_expr e in\n                    Printf.printf \"%d\\n\" v\n  | S_let (x, e) -> let v = run_expr e in\n                    vars.(int_of_char x - int_of_char 'a') <- v\n  | S_for (e, s) -> let v = run_expr e in\n                    for i = 1 to v do\n                      run_stmt s\n                    done\n  | S_block b    -> run b\n  | S_if (e, s)  -> let v = run_expr e in\n                    if v <> 0 then run_stmt s\n\nand run asts = List.iter run_stmt asts\n\ntype llvm_info = {\n  context          : Llvm.llcontext;\n  the_module       : Llvm.llmodule;\n  builder          : Llvm.llbuilder;\n  i8               : Llvm.lltype;\n  i32              : Llvm.lltype;\n  i64              : Llvm.lltype;\n  c32              : int -> Llvm.llvalue;\n  c64              : int -> Llvm.llvalue;\n  the_vars         : Llvm.llvalue;\n  the_nl           : Llvm.llvalue;\n  the_writeInteger : Llvm.llvalue;\n  the_writeString  : Llvm.llvalue;\n}\n\nlet rec compile_expr info ast =\n  match ast with\n  | E_const n         -> info.c64 n\n  | E_var x           -> let n = int_of_char x - int_of_char 'a' in\n                         let v = Llvm.build_gep info.the_vars\n                                                [| info.c32 0; info.c32 n |]\n                                                (String.make 1 x ^ \"_ptr\")\n                                                info.builder in\n                         Llvm.build_load v (String.make 1 x) info.builder\n  | E_op (e1, op, e2) -> let l = compile_expr info e1 in\n                         let r = compile_expr info e2 in\n                         begin\n                           match op with\n                           | O_plus  -> Llvm.build_add l r \"addtmp\" info.builder\n                           | O_minus -> Llvm.build_sub l r \"subtmp\" info.builder\n                           | O_times -> Llvm.build_mul l r \"multmp\" info.builder\n                         end\n\nlet rec compile_stmt info ast =\n  match ast with\n  | S_print e    -> let n = compile_expr info e in\n                    ignore (Llvm.build_call info.the_writeInteger [| n |] \"\"\n                                            info.builder);\n                    let nl = Llvm.build_gep info.the_nl\n                                            [| info.c32 0; info.c32 0 |]\n                                            \"nl\" info.builder in\n                    ignore (Llvm.build_call info.the_writeString [| nl |] \"\"\n                                            info.builder)\n  | S_let (x, e) -> let n = int_of_char x - int_of_char 'a' in\n                    let l = Llvm.build_gep info.the_vars\n                                           [| info.c32 0; info.c32 n |]\n                                           (String.make 1 x ^ \"_ptr\")\n                                           info.builder in\n                    let r = compile_expr info e in\n                    ignore (Llvm.build_store r l info.builder)\n  | S_for (e, s) -> let n = compile_expr info e in\n                    let bb = Llvm.insertion_block info.builder in\n                    let f = Llvm.block_parent bb in\n                    let loop_bb = Llvm.append_block info.context \"loop\" f in\n                    let body_bb = Llvm.append_block info.context \"body\" f in\n                    let after_bb = Llvm.append_block info.context \"after\" f in\n                    ignore (Llvm.build_br loop_bb info.builder);\n                    Llvm.position_at_end loop_bb info.builder;\n                    let phi_iter =\n                      Llvm.build_phi [(n, bb)] \"iter\" info.builder in\n                    let loop_cond =\n                      Llvm.build_icmp Llvm.Icmp.Sgt phi_iter (info.c64 0)\n                                      \"loop_cond\" info.builder in\n                    ignore (Llvm.build_cond_br loop_cond body_bb after_bb\n                                               info.builder);\n                    Llvm.position_at_end body_bb info.builder;\n                    let remaining = Llvm.build_sub phi_iter (info.c64 1)\n                                                   \"remaining\" info.builder in\n                    compile_stmt info s;\n                    Llvm.add_incoming\n                      (remaining, Llvm.insertion_block info.builder) phi_iter;\n                    ignore (Llvm.build_br loop_bb info.builder);\n                    Llvm.position_at_end after_bb info.builder\n  | S_block b    -> List.iter (compile_stmt info) b\n  | S_if (e, s)  -> let v = compile_expr info e in\n                    let cond = Llvm.build_icmp Llvm.Icmp.Ne v (info.c64 0)\n                                               \"if_cond\" info.builder in\n                    let bb = Llvm.insertion_block info.builder in\n                    let f = Llvm.block_parent bb in\n                    let then_bb = Llvm.append_block info.context \"then\" f in\n                    let after_bb = Llvm.append_block info.context \"after\" f in\n                    ignore (Llvm.build_cond_br cond then_bb after_bb\n                                               info.builder);\n                    Llvm.position_at_end then_bb info.builder;\n                    compile_stmt info s;\n                    ignore (Llvm.build_br after_bb info.builder);\n                    Llvm.position_at_end after_bb info.builder\n\nlet llvm_compile_and_dump asts =\n  (* Initialize *)\n  Llvm_all_backends.initialize ();\n  let context = Llvm.global_context () in\n  let the_module = Llvm.create_module context \"minibasic program\" in\n  let builder = Llvm.builder context in\n  let pm = Llvm.PassManager.create () in\n  List.iter (fun f -> f pm) [\n    Llvm_scalar_opts.add_memory_to_register_promotion;\n    Llvm_scalar_opts.add_instruction_combination;\n    Llvm_scalar_opts.add_reassociation;\n    Llvm_scalar_opts.add_gvn;\n    Llvm_scalar_opts.add_cfg_simplification;\n  ];\n  (* Initialize types *)\n  let i8 = Llvm.i8_type context in\n  let i32 = Llvm.i32_type context in\n  let i64 = Llvm.i64_type context in\n  (* Initialize constant functions *)\n  let c32 = Llvm.const_int i32 in\n  let c64 = Llvm.const_int i64 in\n  (* Initialize global variables *)\n  let vars_type = Llvm.array_type i64 26 in\n  let the_vars = Llvm.declare_global vars_type \"vars\" the_module in\n  Llvm.set_linkage Llvm.Linkage.Private the_vars;\n  Llvm.set_initializer (Llvm.const_null vars_type) the_vars;\n  Llvm.set_alignment 16 the_vars;\n  let nl = \"\\n\" in\n  let nl_type = Llvm.array_type i8 (1 + String.length nl) in\n  let the_nl = Llvm.declare_global nl_type \"nl\" the_module in\n  Llvm.set_linkage Llvm.Linkage.Private the_nl;\n  Llvm.set_global_constant true the_nl;\n  Llvm.set_initializer (Llvm.const_stringz context nl) the_nl;\n  Llvm.set_alignment 1 the_nl;\n  (* Initialize library functions *)\n  let writeInteger_type =\n    Llvm.function_type (Llvm.void_type context) [| i64 |] in\n  let the_writeInteger =\n    Llvm.declare_function \"writeInteger\" writeInteger_type the_module in\n  let writeString_type =\n    Llvm.function_type (Llvm.void_type context) [| Llvm.pointer_type i8 |] in\n  let the_writeString =\n    Llvm.declare_function \"writeString\" writeString_type the_module in\n  (* Define and start and main function *)\n  let main_type = Llvm.function_type i32 [| |] in\n  let main = Llvm.declare_function \"main\" main_type the_module in\n  let bb = Llvm.append_block context \"entry\" main in\n  Llvm.position_at_end bb builder;\n  (* Emit the program code *)\n  let info = {\n    context          = context;\n    the_module       = the_module;\n    builder          = builder;\n    i8               = i8;\n    i32              = i32;\n    i64              = i64;\n    c32              = c32;\n    c64              = c64;\n    the_vars         = the_vars;\n    the_nl           = the_nl;\n    the_writeInteger = the_writeInteger;\n    the_writeString  = the_writeString;\n  } in\n  List.iter (compile_stmt info) asts;\n  ignore (Llvm.build_ret (c32 0) builder);\n  (* Verify *)\n  Llvm_analysis.assert_valid_module the_module;\n  (* Optimize *)\n  ignore (Llvm.PassManager.run_module the_module pm);\n  (* Print out the IR *)\n  Llvm.print_module \"a.ll\" the_module\n"}]}}
Read message 
{"jsonrpc":"2.0","id":6,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/tsimiho/Desktop/NTUA/ECE/Semester8/%CE%9C%CE%B5%CF%84%CE%B1%CE%B3%CE%BB%CF%89%CF%84%CF%84%CE%B9%CF%83%CF%84%CE%AD%CF%82/minibasic_llvm/Ast.ml"},"position":{"line":0,"character":0}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0300407409668ms
Sending response {"id": 6, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":7,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/tsimiho/Desktop/NTUA/ECE/Semester8/%CE%9C%CE%B5%CF%84%CE%B1%CE%B3%CE%BB%CF%89%CF%84%CF%84%CE%B9%CF%83%CF%84%CE%AD%CF%82/minibasic_llvm/Ast.ml"},"position":{"line":19,"character":2}}}
[server] Got a method textDocument/hover
[server] processing took 0.0419616699219ms
Sending response {"id": 7, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":8,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/tsimiho/Desktop/NTUA/ECE/Semester8/%CE%9C%CE%B5%CF%84%CE%B1%CE%B3%CE%BB%CF%89%CF%84%CF%84%CE%B9%CF%83%CF%84%CE%AD%CF%82/minibasic_llvm/Ast.ml"},"position":{"line":20,"character":15}}}
[server] Got a method textDocument/hover
[server] processing took 0.0221729278564ms
Sending response {"id": 8, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":9,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/tsimiho/Desktop/NTUA/ECE/Semester8/%CE%9C%CE%B5%CF%84%CE%B1%CE%B3%CE%BB%CF%89%CF%84%CF%84%CE%B9%CF%83%CF%84%CE%AD%CF%82/minibasic_llvm/Ast.ml"},"position":{"line":136,"character":17}}}
[server] Got a method textDocument/hover
[server] processing took 0.0231266021729ms
Sending response {"id": 9, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":10,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/tsimiho/Desktop/NTUA/ECE/Semester8/%CE%9C%CE%B5%CF%84%CE%B1%CE%B3%CE%BB%CF%89%CF%84%CF%84%CE%B9%CF%83%CF%84%CE%AD%CF%82/minibasic_llvm/Ast.ml"},"position":{"line":0,"character":0}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0340938568115ms
Sending response {"id": 10, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":11,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/tsimiho/Desktop/NTUA/ECE/Semester8/%CE%9C%CE%B5%CF%84%CE%B1%CE%B3%CE%BB%CF%89%CF%84%CF%84%CE%B9%CF%83%CF%84%CE%AD%CF%82/compiler/Parser.mly"},"position":{"line":0,"character":0}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0181198120117ms
Sending response {"id": 11, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":12,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/tsimiho/Desktop/NTUA/ECE/Semester8/%CE%9C%CE%B5%CF%84%CE%B1%CE%B3%CE%BB%CF%89%CF%84%CF%84%CE%B9%CF%83%CF%84%CE%AD%CF%82/compiler/Parser.mly"},"position":{"line":15,"character":30}}}
[server] Got a method textDocument/hover
[server] processing took 0.0119209289551ms
Sending response {"id": 12, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":13,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/tsimiho/Desktop/NTUA/ECE/Semester8/%CE%9C%CE%B5%CF%84%CE%B1%CE%B3%CE%BB%CF%89%CF%84%CF%84%CE%B9%CF%83%CF%84%CE%AD%CF%82/compiler/Parser.mly"},"position":{"line":114,"character":22}}}
[server] Got a method textDocument/hover
[server] processing took 0.028133392334ms
Sending response {"id": 13, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":14,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/tsimiho/Desktop/NTUA/ECE/Semester8/%CE%9C%CE%B5%CF%84%CE%B1%CE%B3%CE%BB%CF%89%CF%84%CF%84%CE%B9%CF%83%CF%84%CE%AD%CF%82/compiler/Parser.mly"},"position":{"line":273,"character":58}}}
[server] Got a method textDocument/hover
[server] processing took 0.0219345092773ms
Sending response {"id": 14, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":15,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/tsimiho/Desktop/NTUA/ECE/Semester8/%CE%9C%CE%B5%CF%84%CE%B1%CE%B3%CE%BB%CF%89%CF%84%CF%84%CE%B9%CF%83%CF%84%CE%AD%CF%82/compiler/Parser.mly"},"position":{"line":275,"character":94}}}
[server] Got a method textDocument/hover
[server] processing took 0.0231266021729ms
Sending response {"id": 15, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":16,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/tsimiho/Desktop/NTUA/ECE/Semester8/%CE%9C%CE%B5%CF%84%CE%B1%CE%B3%CE%BB%CF%89%CF%84%CF%84%CE%B9%CF%83%CF%84%CE%AD%CF%82/minibasic_llvm/Ast.ml"},"position":{"line":0,"character":0}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0228881835938ms
Sending response {"id": 16, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":17,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/tsimiho/Desktop/NTUA/ECE/Semester8/%CE%9C%CE%B5%CF%84%CE%B1%CE%B3%CE%BB%CF%89%CF%84%CF%84%CE%B9%CF%83%CF%84%CE%AD%CF%82/minibasic_llvm/Ast.ml"},"position":{"line":186,"character":17}}}
[server] Got a method textDocument/hover
[server] processing took 0.0369548797607ms
Sending response {"id": 17, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":18,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/tsimiho/Desktop/NTUA/ECE/Semester8/%CE%9C%CE%B5%CF%84%CE%B1%CE%B3%CE%BB%CF%89%CF%84%CF%84%CE%B9%CF%83%CF%84%CE%AD%CF%82/minibasic_llvm/Ast.ml"},"position":{"line":183,"character":21}}}
[server] Got a method textDocument/hover
[server] processing took 0.0221729278564ms
Sending response {"id": 18, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":19,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/tsimiho/Desktop/NTUA/ECE/Semester8/%CE%9C%CE%B5%CF%84%CE%B1%CE%B3%CE%BB%CF%89%CF%84%CF%84%CE%B9%CF%83%CF%84%CE%AD%CF%82/minibasic_llvm/Ast.ml"},"position":{"line":132,"character":0}}}
[server] Got a method textDocument/hover
[server] processing took 0.0360012054443ms
Sending response {"id": 19, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":20,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/tsimiho/Desktop/NTUA/ECE/Semester8/%CE%9C%CE%B5%CF%84%CE%B1%CE%B3%CE%BB%CF%89%CF%84%CF%84%CE%B9%CF%83%CF%84%CE%AD%CF%82/minibasic_llvm/Ast.ml"},"position":{"line":132,"character":0}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0321865081787ms
Sending response {"id": 20, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":21,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/tsimiho/Desktop/NTUA/ECE/Semester8/%CE%9C%CE%B5%CF%84%CE%B1%CE%B3%CE%BB%CF%89%CF%84%CF%84%CE%B9%CF%83%CF%84%CE%AD%CF%82/minibasic_llvm/Ast.ml"},"position":{"line":133,"character":7}}}
[server] Got a method textDocument/hover
[server] processing took 0.0219345092773ms
Sending response {"id": 21, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":22,"method":"textDocument/definition","params":{"textDocument":{"uri":"file:///Users/tsimiho/Desktop/NTUA/ECE/Semester8/%CE%9C%CE%B5%CF%84%CE%B1%CE%B3%CE%BB%CF%89%CF%84%CF%84%CE%B9%CF%83%CF%84%CE%AD%CF%82/minibasic_llvm/Ast.ml"},"position":{"line":133,"character":7}}}
[server] Got a method textDocument/definition
[server] processing took 0.0171661376953ms
Sending response {"id": 22, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":23,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/tsimiho/Desktop/NTUA/ECE/Semester8/%CE%9C%CE%B5%CF%84%CE%B1%CE%B3%CE%BB%CF%89%CF%84%CF%84%CE%B9%CF%83%CF%84%CE%AD%CF%82/minibasic_llvm/Ast.ml"},"position":{"line":203,"character":0}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0379085540771ms
Sending response {"id": 23, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":24,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/tsimiho/Desktop/NTUA/ECE/Semester8/%CE%9C%CE%B5%CF%84%CE%B1%CE%B3%CE%BB%CF%89%CF%84%CF%84%CE%B9%CF%83%CF%84%CE%AD%CF%82/minibasic_llvm/Ast.ml"},"range":{"start":{"line":132,"character":0},"end":{"line":203,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0369548797607ms
Sending response {"id": 24, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":25,"method":"textDocument/definition","params":{"textDocument":{"uri":"file:///Users/tsimiho/Desktop/NTUA/ECE/Semester8/%CE%9C%CE%B5%CF%84%CE%B1%CE%B3%CE%BB%CF%89%CF%84%CF%84%CE%B9%CF%83%CF%84%CE%AD%CF%82/minibasic_llvm/Ast.ml"},"position":{"line":177,"character":7}}}
[server] Got a method textDocument/definition
[server] processing took 0.0169277191162ms
Sending response {"id": 25, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didClose","params":{"textDocument":{"uri":"file:///Users/tsimiho/Desktop/NTUA/ECE/Semester8/%CE%9C%CE%B5%CF%84%CE%B1%CE%B3%CE%BB%CF%89%CF%84%CF%84%CE%B9%CF%83%CF%84%CE%AD%CF%82/minibasic_llvm/Ast.ml"}}}
Read message 
{"jsonrpc":"2.0","id":26,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/tsimiho/Desktop/NTUA/ECE/Semester8/%CE%9C%CE%B5%CF%84%CE%B1%CE%B3%CE%BB%CF%89%CF%84%CF%84%CE%B9%CF%83%CF%84%CE%AD%CF%82/compiler/Symbol.ml"},"position":{"line":0,"character":0}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0369548797607ms
Sending response {"id": 26, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":27,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/tsimiho/Desktop/NTUA/ECE/Semester8/%CE%9C%CE%B5%CF%84%CE%B1%CE%B3%CE%BB%CF%89%CF%84%CF%84%CE%B9%CF%83%CF%84%CE%AD%CF%82/compiler/Irgen.ml"},"position":{"line":0,"character":0}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.126838684082ms
Sending response {"id": 27, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":28,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/tsimiho/Desktop/NTUA/ECE/Semester8/%CE%9C%CE%B5%CF%84%CE%B1%CE%B3%CE%BB%CF%89%CF%84%CF%84%CE%B9%CF%83%CF%84%CE%AD%CF%82/compiler/Irgen.ml"},"position":{"line":22,"character":0}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0360012054443ms
Sending response {"id": 28, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/tsimiho/Desktop/NTUA/ECE/Semester8/%CE%9C%CE%B5%CF%84%CE%B1%CE%B3%CE%BB%CF%89%CF%84%CF%84%CE%B9%CF%83%CF%84%CE%AD%CF%82/compiler/Irgen.ml","version":2},"contentChanges":[{"text":"let llvm_compile_and_dump asts =\n  (* Initialize *)\n  Llvm_all_backends.initialize ();\n  let context = Llvm.global_context () in\n  let the_module = Llvm.create_module context \"minibasic program\" in\n  let builder = Llvm.builder context in\n  let pm = Llvm.PassManager.create () in\n  List.iter (fun f -> f pm) [\n    Llvm_scalar_opts.add_memory_to_register_promotion;\n    Llvm_scalar_opts.add_instruction_combination;\n    Llvm_scalar_opts.add_reassociation;\n    Llvm_scalar_opts.add_gvn;\n    Llvm_scalar_opts.add_cfg_simplification;\n  ];\n  (* Initialize types *)\n  let i8 = Llvm.i8_type context in\n  let i32 = Llvm.i32_type context in\n  let i64 = Llvm.i64_type context in\n  (* Initialize constant functions *)\n  let c32 = Llvm.const_int i32 in\n  let c64 = Llvm.const_int i64 in\n  (* Initialize global variables *)\n  let vars_type = Llvm.array_type i64 26 in\n  let the_vars = Llvm.declare_global vars_type \"vars\" the_module in\n  Llvm.set_linkage Llvm.Linkage.Private the_vars;\n  Llvm.set_initializer (Llvm.const_null vars_type) the_vars;\n  Llvm.set_alignment 16 the_vars;\n  let nl = \"\\n\" in\n  let nl_type = Llvm.array_type i8 (1 + String.length nl) in\n  let the_nl = Llvm.declare_global nl_type \"nl\" the_module in\n  Llvm.set_linkage Llvm.Linkage.Private the_nl;\n  Llvm.set_global_constant true the_nl;\n  Llvm.set_initializer (Llvm.const_stringz context nl) the_nl;\n  Llvm.set_alignment 1 the_nl;\n  (* Initialize library functions *)\n  let writeInteger_type =\n    Llvm.function_type (Llvm.void_type context) [| i64 |] in\n  let the_writeInteger =\n    Llvm.declare_function \"writeInteger\" writeInteger_type the_module in\n  let writeString_type =\n    Llvm.function_type (Llvm.void_type context) [| Llvm.pointer_type i8 |] in\n  let the_writeString =\n    Llvm.declare_function \"writeString\" writeString_type the_module in\n  (* Define and start and main function *)\n  let main_type = Llvm.function_type i32 [| |] in\n  let main = Llvm.declare_function \"main\" main_type the_module in\n  let bb = Llvm.append_block context \"entry\" main in\n  Llvm.position_at_end bb builder;\n  (* Emit the program code *)\n  let info = {\n    context          = context;\n    the_module       = the_module;\n    builder          = builder;\n    i8               = i8;\n    i32              = i32;\n    i64              = i64;\n    c32              = c32;\n    c64              = c64;\n    the_vars         = the_vars;\n    the_nl           = the_nl;\n    the_writeInteger = the_writeInteger;\n    the_writeString  = the_writeString;\n  } in\n  List.iter (compile_stmt info) asts;\n  ignore (Llvm.build_ret (c32 0) builder);\n  (* Verify *)\n  Llvm_analysis.assert_valid_module the_module;\n  (* Optimize *)\n  ignore (Llvm.PassManager.run_module the_module pm);\n  (* Print out the IR *)\n  Llvm.print_module \"a.ll\" the_module\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/tsimiho/Desktop/NTUA/ECE/Semester8/%CE%9C%CE%B5%CF%84%CE%B1%CE%B3%CE%BB%CF%89%CF%84%CF%84%CE%B9%CF%83%CF%84%CE%AD%CF%82/compiler/Irgen.ml","version":3},"contentChanges":[{"text":"let llvm_compile_and_dump asts =\n  (* Initialize *)\n  Llvm_all_backends.initialize ();\n  let context = Llvm.global_context () in\n  let the_module = Llvm.create_module context \"minibasic program\" in\n  let builder = Llvm.builder context in\n  let pm = Llvm.PassManager.create () in\n  List.iter (fun f -> f pm) [\n    Llvm_scalar_opts.add_memory_to_register_promotion;\n    Llvm_scalar_opts.add_instruction_combination;\n    Llvm_scalar_opts.add_reassociation;\n    Llvm_scalar_opts.add_gvn;\n    Llvm_scalar_opts.add_cfg_simplification;\n  ];\n  (* Initialize types *)\n  let i8 = Llvm.i8_type context in\n  let i32 = Llvm.i32_type context in\n  let i64 = Llvm.i64_type context in\n  (* Initialize constant functions *)\n  let c32 = Llvm.const_int i32 in\n  let c64 = Llvm.const_int i64 in\n  (* Initialize global variables *)\n  let vars_type = Llvm.array_type i64 26 in\n  let the_vars = Llvm.declare_global vars_type \"vars\" the_module in\n  Llvm.set_linkage Llvm.Linkage.Private the_vars;\n  Llvm.set_initializer (Llvm.const_null vars_type) the_vars;\n  Llvm.set_alignment 16 the_vars;\n  let nl = \"\\n\" in\n  let nl_type = Llvm.array_type i8 (1 + String.length nl) in\n  let the_nl = Llvm.declare_global nl_type \"nl\" the_module in\n  Llvm.set_linkage Llvm.Linkage.Private the_nl;\n  Llvm.set_global_constant true the_nl;\n  Llvm.set_initializer (Llvm.const_stringz context nl) the_nl;\n  Llvm.set_alignment 1 the_nl;\n  (* Initialize library functions *)\n  let writeInteger_type =\n    Llvm.function_type (Llvm.void_type context) [| i64 |] in\n  let the_writeInteger =\n    Llvm.declare_function \"writeInteger\" writeInteger_type the_module in\n  let writeString_type =\n    Llvm.function_type (Llvm.void_type context) [| Llvm.pointer_type i8 |] in\n  let the_writeString =\n    Llvm.declare_function \"writeString\" writeString_type the_module in\n  (* Define and start and main function *)\n  let main_type = Llvm.function_type i32 [| |] in\n  let main = Llvm.declare_function \"main\" main_type the_module in\n  let bb = Llvm.append_block context \"entry\" main in\n  Llvm.position_at_end bb builder;\n  (* Emit the program code *)\n  let info = {\n    context          = context;\n    the_module       = the_module;\n    builder          = builder;\n    i8               = i8;\n    i32              = i32;\n    i64              = i64;\n    c32              = c32;\n    c64              = c64;\n    the_vars         = the_vars;\n    the_nl           = the_nl;\n    the_writeInteger = the_writeInteger;\n    the_writeString  = the_writeString;\n  } in\n  List.iter (compile_stmt info) asts;\n  ignore (Llvm.build_ret (c32 0) builder);\n  (* Verify *)\n  Llvm_analysis.assert_valid_module the_module;\n  (* Optimize *)\n  ignore (Llvm.PassManager.run_module the_module pm);\n  (* Print out the IR *)\n  Llvm.print_module \"a.ll\" the_module\n"}]}}
Read message 
{"jsonrpc":"2.0","id":29,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/tsimiho/Desktop/NTUA/ECE/Semester8/%CE%9C%CE%B5%CF%84%CE%B1%CE%B3%CE%BB%CF%89%CF%84%CF%84%CE%B9%CF%83%CF%84%CE%AD%CF%82/compiler/Irgen.ml"},"position":{"line":71,"character":0}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0350475311279ms
Sending response {"id": 29, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":30,"method":"textDocument/formatting","params":{"textDocument":{"uri":"file:///Users/tsimiho/Desktop/NTUA/ECE/Semester8/%CE%9C%CE%B5%CF%84%CE%B1%CE%B3%CE%BB%CF%89%CF%84%CF%84%CE%B9%CF%83%CF%84%CE%AD%CF%82/compiler/Irgen.ml"},"options":{"tabSize":2,"insertSpaces":true}}}
[server] Got a method textDocument/formatting
[server] processing took 0.0190734863281ms
Sending response {"id": 30, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///Users/tsimiho/Desktop/NTUA/ECE/Semester8/%CE%9C%CE%B5%CF%84%CE%B1%CE%B3%CE%BB%CF%89%CF%84%CF%84%CE%B9%CF%83%CF%84%CE%AD%CF%82/compiler/Irgen.ml","version":1}}}
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":31,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/tsimiho/Desktop/NTUA/ECE/Semester8/%CE%9C%CE%B5%CF%84%CE%B1%CE%B3%CE%BB%CF%89%CF%84%CF%84%CE%B9%CF%83%CF%84%CE%AD%CF%82/compiler/Irgen.ml"},"range":{"start":{"line":12,"character":4},"end":{"line":12,"character":43}},"context":{"diagnostics":[{"range":{"start":{"line":12,"character":4},"end":{"line":12,"character":43}},"severity":1,"source":"OCaml Merlin","message":"Unbound module Llvm_scalar_opts"}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0178813934326ms
Sending response {"id": 31, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":32,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/tsimiho/Desktop/NTUA/ECE/Semester8/%CE%9C%CE%B5%CF%84%CE%B1%CE%B3%CE%BB%CF%89%CF%84%CF%84%CE%B9%CF%83%CF%84%CE%AD%CF%82/compiler/Irgen.ml"},"position":{"line":12,"character":15}}}
[server] Got a method textDocument/hover
[server] processing took 0.0121593475342ms
Sending response {"id": 32, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":33,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/tsimiho/Desktop/NTUA/ECE/Semester8/%CE%9C%CE%B5%CF%84%CE%B1%CE%B3%CE%BB%CF%89%CF%84%CF%84%CE%B9%CF%83%CF%84%CE%AD%CF%82/compiler/Irgen.ml"},"position":{"line":3,"character":9}}}
[server] Got a method textDocument/hover
[server] processing took 0.0200271606445ms
Sending response {"id": 33, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":34,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/tsimiho/Desktop/NTUA/ECE/Semester8/%CE%9C%CE%B5%CF%84%CE%B1%CE%B3%CE%BB%CF%89%CF%84%CF%84%CE%B9%CF%83%CF%84%CE%AD%CF%82/compiler/Irgen.ml"},"range":{"start":{"line":2,"character":2},"end":{"line":2,"character":30}},"context":{"diagnostics":[{"range":{"start":{"line":2,"character":2},"end":{"line":2,"character":30}},"severity":1,"source":"OCaml Merlin","message":"Unbound module Llvm_all_backends"}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0169277191162ms
Sending response {"id": 34, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":35,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/tsimiho/Desktop/NTUA/ECE/Semester8/%CE%9C%CE%B5%CF%84%CE%B1%CE%B3%CE%BB%CF%89%CF%84%CF%84%CE%B9%CF%83%CF%84%CE%AD%CF%82/compiler/Irgen.ml"},"position":{"line":2,"character":9}}}
[server] Got a method textDocument/hover
[server] processing took 0.0100135803223ms
Sending response {"id": 35, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":36,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/tsimiho/Desktop/NTUA/ECE/Semester8/%CE%9C%CE%B5%CF%84%CE%B1%CE%B3%CE%BB%CF%89%CF%84%CF%84%CE%B9%CF%83%CF%84%CE%AD%CF%82/compiler/Irgen.ml"},"range":{"start":{"line":2,"character":2},"end":{"line":2,"character":30}},"context":{"diagnostics":[{"range":{"start":{"line":2,"character":2},"end":{"line":2,"character":30}},"severity":1,"source":"OCaml Merlin","message":"Unbound module Llvm_all_backends"}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0128746032715ms
Sending response {"id": 36, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":37,"method":"textDocument/definition","params":{"textDocument":{"uri":"file:///Users/tsimiho/Desktop/NTUA/ECE/Semester8/%CE%9C%CE%B5%CF%84%CE%B1%CE%B3%CE%BB%CF%89%CF%84%CF%84%CE%B9%CF%83%CF%84%CE%AD%CF%82/compiler/Irgen.ml"},"position":{"line":2,"character":0}}}
[server] Got a method textDocument/definition
[server] processing took 0.0159740447998ms
Sending response {"id": 37, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/tsimiho/Desktop/NTUA/ECE/Semester8/%CE%9C%CE%B5%CF%84%CE%B1%CE%B3%CE%BB%CF%89%CF%84%CF%84%CE%B9%CF%83%CF%84%CE%AD%CF%82/compiler/Irgen.ml","version":4},"contentChanges":[{"text":"let llvm_compile_and_dump asts =\n  (* Initialize *)\n  Llvm_all_backends.initialize ();\n  let context = Llvm.global_context () in\n  let the_module = Llvm.create_module context \"minibasic program\" in\n  let builder = Llvm.builder context in\n  let pm = Llvm.PassManager.create () in\n  List.iter (fun f -> f pm) [\n    Llvm_scalar_opts.add_memory_to_register_promotion;\n    Llvm_scalar_opts.add_instruction_combination;\n    Llvm_scalar_opts.add_reassociation;\n    Llvm_scalar_opts.add_gvn;\n    Llvm_scalar_opts.add_cfg_simplification;\n  ];\n  (* Initialize types *)\n  let i8 = Llvm.i8_type context in\n  let i32 = Llvm.i32_type context in\n  let i64 = Llvm.i64_type context in\n  (* Initialize constant functions *)\n  let c32 = Llvm.const_int i32 in\n  let c64 = Llvm.const_int i64 in\n  (* Initialize global variables *)\n  let vars_type = Llvm.array_type i64 26 in\n  let the_vars = Llvm.declare_global vars_type \"vars\" the_module in\n  Llvm.set_linkage Llvm.Linkage.Private the_vars;\n  Llvm.set_initializer (Llvm.const_null vars_type) the_vars;\n  Llvm.set_alignment 16 the_vars;\n  let nl = \"\\n\" in\n  let nl_type = Llvm.array_type i8 (1 + String.length nl) in\n  let the_nl = Llvm.declare_global nl_type \"nl\" the_module in\n  Llvm.set_linkage Llvm.Linkage.Private the_nl;\n  Llvm.set_global_constant true the_nl;\n  Llvm.set_initializer (Llvm.const_stringz context nl) the_nl;\n  Llvm.set_alignment 1 the_nl;\n  (* Initialize library functions *)\n  let writeInteger_type =\n    Llvm.function_type (Llvm.void_type context) [| i64 |] in\n  let the_writeInteger =\n    Llvm.declare_function \"writeInteger\" writeInteger_type the_module in\n  let writeString_type =\n    Llvm.function_type (Llvm.void_type context) [| Llvm.pointer_type i8 |] in\n  let the_writeString =\n    Llvm.declare_function \"writeString\" writeString_type the_module in\n  (* Define and start and main function *)\n  let main_type = Llvm.function_type i32 [| |] in\n  let main = Llvm.declare_function \"main\" main_type the_module in\n  let bb = Llvm.append_block context \"entry\" main in\n  Llvm.position_at_end bb builder;\n  (* Emit the program code *)\n  let info = {\n    context          = context;\n    the_module       = the_module;\n    builder          = builder;\n    i8               = i8;\n    i32              = i32;\n    i64              = i64;\n    c32              = c32;\n    c64              = c64;\n    the_vars         = the_vars;\n    the_nl           = the_nl;\n    the_writeInteger = the_writeInteger;\n    the_writeString  = the_writeString;\n  } in\n  List.iter (compile_stmt info) asts;\n  ignore (Llvm.build_ret (c32 0) builder);\n  (* Verify *)\n  Llvm_analysis.assert_valid_module the_module;\n  (* Optimize *)\n  ignore (Llvm.PassManager.run_module the_module pm);\n  (* Print out the IR *)\n  Llvm.print_module \"a.ll\" the_module\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/tsimiho/Desktop/NTUA/ECE/Semester8/%CE%9C%CE%B5%CF%84%CE%B1%CE%B3%CE%BB%CF%89%CF%84%CF%84%CE%B9%CF%83%CF%84%CE%AD%CF%82/compiler/Irgen.ml","version":5},"contentChanges":[{"text":"let llvm_compile_and_dump asts =\n  (* Initialize *)\n  Llvm_all_backends.initialize ();\n  let context = Llvm.global_context () in\n  let the_module = Llvm.create_module context \"minibasic program\" in\n  let builder = Llvm.builder context in\n  let pm = Llvm.PassManager.create () in\n  List.iter (fun f -> f pm) [\n    Llvm_scalar_opts.add_memory_to_register_promotion;\n    Llvm_scalar_opts.add_instruction_combination;\n    Llvm_scalar_opts.add_reassociation;\n    Llvm_scalar_opts.add_gvn;\n    Llvm_scalar_opts.add_cfg_simplification;\n  ];\n  (* Initialize types *)\n  let i8 = Llvm.i8_type context in\n  let i32 = Llvm.i32_type context in\n  let i64 = Llvm.i64_type context in\n  (* Initialize constant functions *)\n  let c32 = Llvm.const_int i32 in\n  let c64 = Llvm.const_int i64 in\n  (* Initialize global variables *)\n  let vars_type = Llvm.array_type i64 26 in\n  let the_vars = Llvm.declare_global vars_type \"vars\" the_module in\n  Llvm.set_linkage Llvm.Linkage.Private the_vars;\n  Llvm.set_initializer (Llvm.const_null vars_type) the_vars;\n  Llvm.set_alignment 16 the_vars;\n  let nl = \"\\n\" in\n  let nl_type = Llvm.array_type i8 (1 + String.length nl) in\n  let the_nl = Llvm.declare_global nl_type \"nl\" the_module in\n  Llvm.set_linkage Llvm.Linkage.Private the_nl;\n  Llvm.set_global_constant true the_nl;\n  Llvm.set_initializer (Llvm.const_stringz context nl) the_nl;\n  Llvm.set_alignment 1 the_nl;\n  (* Initialize library functions *)\n  let writeInteger_type =\n    Llvm.function_type (Llvm.void_type context) [| i64 |] in\n  let the_writeInteger =\n    Llvm.declare_function \"writeInteger\" writeInteger_type the_module in\n  let writeString_type =\n    Llvm.function_type (Llvm.void_type context) [| Llvm.pointer_type i8 |] in\n  let the_writeString =\n    Llvm.declare_function \"writeString\" writeString_type the_module in\n  (* Define and start and main function *)\n  let main_type = Llvm.function_type i32 [| |] in\n  let main = Llvm.declare_function \"main\" main_type the_module in\n  let bb = Llvm.append_block context \"entry\" main in\n  Llvm.position_at_end bb builder;\n  (* Emit the program code *)\n  let info = {\n    context          = context;\n    the_module       = the_module;\n    builder          = builder;\n    i8               = i8;\n    i32              = i32;\n    i64              = i64;\n    c32              = c32;\n    c64              = c64;\n    the_vars         = the_vars;\n    the_nl           = the_nl;\n    the_writeInteger = the_writeInteger;\n    the_writeString  = the_writeString;\n  } in\n  List.iter (compile_stmt info) asts;\n  ignore (Llvm.build_ret (c32 0) builder);\n  (* Verify *)\n  Llvm_analysis.assert_valid_module the_module;\n  (* Optimize *)\n  ignore (Llvm.PassManager.run_module the_module pm);\n  (* Print out the IR *)\n  Llvm.print_module \"a.ll\" the_module\n"}]}}
Read message 
{"jsonrpc":"2.0","id":38,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/tsimiho/Desktop/NTUA/ECE/Semester8/%CE%9C%CE%B5%CF%84%CE%B1%CE%B3%CE%BB%CF%89%CF%84%CF%84%CE%B9%CF%83%CF%84%CE%AD%CF%82/compiler/Irgen.ml"},"position":{"line":71,"character":0}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0338554382324ms
Sending response {"id": 38, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":39,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/tsimiho/Desktop/NTUA/ECE/Semester8/%CE%9C%CE%B5%CF%84%CE%B1%CE%B3%CE%BB%CF%89%CF%84%CF%84%CE%B9%CF%83%CF%84%CE%AD%CF%82/compiler/Irgen.ml"},"range":{"start":{"line":2,"character":2},"end":{"line":2,"character":30}},"context":{"diagnostics":[{"range":{"start":{"line":2,"character":2},"end":{"line":2,"character":30}},"severity":1,"source":"OCaml Merlin","message":"Unbound module Llvm_all_backends"}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0159740447998ms
Sending response {"id": 39, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":40,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/tsimiho/Desktop/NTUA/ECE/Semester8/%CE%9C%CE%B5%CF%84%CE%B1%CE%B3%CE%BB%CF%89%CF%84%CF%84%CE%B9%CF%83%CF%84%CE%AD%CF%82/compiler/Irgen.ml"},"range":{"start":{"line":2,"character":2},"end":{"line":2,"character":30}},"context":{"diagnostics":[{"range":{"start":{"line":2,"character":2},"end":{"line":2,"character":30}},"severity":1,"source":"OCaml Merlin","message":"Unbound module Llvm_all_backends"}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.014066696167ms
Sending response {"id": 40, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":41,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/tsimiho/Desktop/NTUA/ECE/Semester8/%CE%9C%CE%B5%CF%84%CE%B1%CE%B3%CE%BB%CF%89%CF%84%CF%84%CE%B9%CF%83%CF%84%CE%AD%CF%82/compiler/Irgen.ml"},"range":{"start":{"line":2,"character":2},"end":{"line":2,"character":30}},"context":{"diagnostics":[{"range":{"start":{"line":2,"character":2},"end":{"line":2,"character":30}},"severity":1,"source":"OCaml Merlin","message":"Unbound module Llvm_all_backends"}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0150203704834ms
Sending response {"id": 41, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":42,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/tsimiho/Desktop/NTUA/ECE/Semester8/%CE%9C%CE%B5%CF%84%CE%B1%CE%B3%CE%BB%CF%89%CF%84%CF%84%CE%B9%CF%83%CF%84%CE%AD%CF%82/compiler/Irgen.ml"},"position":{"line":12,"character":44}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0381469726562ms
Sending response {"id": 42, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":43,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/tsimiho/Desktop/NTUA/ECE/Semester8/%CE%9C%CE%B5%CF%84%CE%B1%CE%B3%CE%BB%CF%89%CF%84%CF%84%CE%B9%CF%83%CF%84%CE%AD%CF%82/compiler/Irgen.ml"},"position":{"line":0,"character":0}}}
[server] Got a method textDocument/hover
[server] processing took 0.0338554382324ms
Sending response {"id": 43, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":44,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/tsimiho/Desktop/NTUA/ECE/Semester8/%CE%9C%CE%B5%CF%84%CE%B1%CE%B3%CE%BB%CF%89%CF%84%CF%84%CE%B9%CF%83%CF%84%CE%AD%CF%82/compiler/Irgen.ml"},"position":{"line":0,"character":0}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0388622283936ms
Sending response {"id": 44, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/tsimiho/Desktop/NTUA/ECE/Semester8/%CE%9C%CE%B5%CF%84%CE%B1%CE%B3%CE%BB%CF%89%CF%84%CF%84%CE%B9%CF%83%CF%84%CE%AD%CF%82/compiler/Irgen.ml","version":6},"contentChanges":[{"text":"open Llvm\nopen Llvm_analysis\nopen Llvm_scalar_opts\nopen Llvm_ipo\nopen Llvm_vectorize\nopen Llvm_target\nopen Llvm.PassManager\n\nlet context = global_context ()\nlet the_module = create_module context \"alan source file\"\nlet builder = builder context\nlet int_type = i64_type context\nlet char_type = i8_type context\nlet void_type = void_type context\nlet bool_type = i1_type context\n\nlet rec to_llvm_type x = match x with\n| TYPE_int -> int_type\n| TYPE_byte -> char_type\n| TYPE_array (t,n) -> array_type (to_llvm_type t) n\n| TYPE_proc -> void_type\n| _ -> internal \"Trying to get an invalid llvm type\"; raise Terminate\n"}]}}
Read message 
{"jsonrpc":"2.0","id":45,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/tsimiho/Desktop/NTUA/ECE/Semester8/%CE%9C%CE%B5%CF%84%CE%B1%CE%B3%CE%BB%CF%89%CF%84%CF%84%CE%B9%CF%83%CF%84%CE%AD%CF%82/compiler/Irgen.ml"},"position":{"line":22,"character":0}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.032901763916ms
Sending response {"id": 45, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/tsimiho/Desktop/NTUA/ECE/Semester8/%CE%9C%CE%B5%CF%84%CE%B1%CE%B3%CE%BB%CF%89%CF%84%CF%84%CE%B9%CF%83%CF%84%CE%AD%CF%82/compiler/Irgen.ml","version":7},"contentChanges":[{"text":"let llvm_compile_and_dump asts =\n  (* Initialize *)\n  Llvm_all_backends.initialize ();\n  let context = Llvm.global_context () in\n  let the_module = Llvm.create_module context \"minibasic program\" in\n  let builder = Llvm.builder context in\n  let pm = Llvm.PassManager.create () in\n  List.iter (fun f -> f pm) [\n    Llvm_scalar_opts.add_memory_to_register_promotion;\n    Llvm_scalar_opts.add_instruction_combination;\n    Llvm_scalar_opts.add_reassociation;\n    Llvm_scalar_opts.add_gvn;\n    Llvm_scalar_opts.add_cfg_simplification;\n  ];\n  (* Initialize types *)\n  let i8 = Llvm.i8_type context in\n  let i32 = Llvm.i32_type context in\n  let i64 = Llvm.i64_type context in\n  (* Initialize constant functions *)\n  let c32 = Llvm.const_int i32 in\n  let c64 = Llvm.const_int i64 in\n  (* Initialize global variables *)\n  let vars_type = Llvm.array_type i64 26 in\n  let the_vars = Llvm.declare_global vars_type \"vars\" the_module in\n  Llvm.set_linkage Llvm.Linkage.Private the_vars;\n  Llvm.set_initializer (Llvm.const_null vars_type) the_vars;\n  Llvm.set_alignment 16 the_vars;\n  let nl = \"\\n\" in\n  let nl_type = Llvm.array_type i8 (1 + String.length nl) in\n  let the_nl = Llvm.declare_global nl_type \"nl\" the_module in\n  Llvm.set_linkage Llvm.Linkage.Private the_nl;\n  Llvm.set_global_constant true the_nl;\n  Llvm.set_initializer (Llvm.const_stringz context nl) the_nl;\n  Llvm.set_alignment 1 the_nl;\n  (* Initialize library functions *)\n  let writeInteger_type =\n    Llvm.function_type (Llvm.void_type context) [| i64 |] in\n  let the_writeInteger =\n    Llvm.declare_function \"writeInteger\" writeInteger_type the_module in\n  let writeString_type =\n    Llvm.function_type (Llvm.void_type context) [| Llvm.pointer_type i8 |] in\n  let the_writeString =\n    Llvm.declare_function \"writeString\" writeString_type the_module in\n  (* Define and start and main function *)\n  let main_type = Llvm.function_type i32 [| |] in\n  let main = Llvm.declare_function \"main\" main_type the_module in\n  let bb = Llvm.append_block context \"entry\" main in\n  Llvm.position_at_end bb builder;\n  (* Emit the program code *)\n  let info = {\n    context          = context;\n    the_module       = the_module;\n    builder          = builder;\n    i8               = i8;\n    i32              = i32;\n    i64              = i64;\n    c32              = c32;\n    c64              = c64;\n    the_vars         = the_vars;\n    the_nl           = the_nl;\n    the_writeInteger = the_writeInteger;\n    the_writeString  = the_writeString;\n  } in\n  List.iter (compile_stmt info) asts;\n  ignore (Llvm.build_ret (c32 0) builder);\n  (* Verify *)\n  Llvm_analysis.assert_valid_module the_module;\n  (* Optimize *)\n  ignore (Llvm.PassManager.run_module the_module pm);\n  (* Print out the IR *)\n  Llvm.print_module \"a.ll\" the_module\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/tsimiho/Desktop/NTUA/ECE/Semester8/%CE%9C%CE%B5%CF%84%CE%B1%CE%B3%CE%BB%CF%89%CF%84%CF%84%CE%B9%CF%83%CF%84%CE%AD%CF%82/compiler/Irgen.ml","version":8},"contentChanges":[{"text":"let llvm_compile_and_dump asts =\n  (* Initialize *)\n  Llvm_all_backends.initialize ();\n  let context = Llvm.global_context () in\n  let the_module = Llvm.create_module context \"minibasic program\" in\n  let builder = Llvm.builder context in\n  let pm = Llvm.PassManager.create () in\n  List.iter (fun f -> f pm) [\n    Llvm_scalar_opts.add_memory_to_register_promotion;\n    Llvm_scalar_opts.add_instruction_combination;\n    Llvm_scalar_opts.add_reassociation;\n    Llvm_scalar_opts.add_gvn;\n    Llvm_scalar_opts.add_cfg_simplification;\n  ];\n  (* Initialize types *)\n  let i8 = Llvm.i8_type context in\n  let i32 = Llvm.i32_type context in\n  let i64 = Llvm.i64_type context in\n  (* Initialize constant functions *)\n  let c32 = Llvm.const_int i32 in\n  let c64 = Llvm.const_int i64 in\n  (* Initialize global variables *)\n  let vars_type = Llvm.array_type i64 26 in\n  let the_vars = Llvm.declare_global vars_type \"vars\" the_module in\n  Llvm.set_linkage Llvm.Linkage.Private the_vars;\n  Llvm.set_initializer (Llvm.const_null vars_type) the_vars;\n  Llvm.set_alignment 16 the_vars;\n  let nl = \"\\n\" in\n  let nl_type = Llvm.array_type i8 (1 + String.length nl) in\n  let the_nl = Llvm.declare_global nl_type \"nl\" the_module in\n  Llvm.set_linkage Llvm.Linkage.Private the_nl;\n  Llvm.set_global_constant true the_nl;\n  Llvm.set_initializer (Llvm.const_stringz context nl) the_nl;\n  Llvm.set_alignment 1 the_nl;\n  (* Initialize library functions *)\n  let writeInteger_type =\n    Llvm.function_type (Llvm.void_type context) [| i64 |] in\n  let the_writeInteger =\n    Llvm.declare_function \"writeInteger\" writeInteger_type the_module in\n  let writeString_type =\n    Llvm.function_type (Llvm.void_type context) [| Llvm.pointer_type i8 |] in\n  let the_writeString =\n    Llvm.declare_function \"writeString\" writeString_type the_module in\n  (* Define and start and main function *)\n  let main_type = Llvm.function_type i32 [| |] in\n  let main = Llvm.declare_function \"main\" main_type the_module in\n  let bb = Llvm.append_block context \"entry\" main in\n  Llvm.position_at_end bb builder;\n  (* Emit the program code *)\n  let info = {\n    context          = context;\n    the_module       = the_module;\n    builder          = builder;\n    i8               = i8;\n    i32              = i32;\n    i64              = i64;\n    c32              = c32;\n    c64              = c64;\n    the_vars         = the_vars;\n    the_nl           = the_nl;\n    the_writeInteger = the_writeInteger;\n    the_writeString  = the_writeString;\n  } in\n  List.iter (compile_stmt info) asts;\n  ignore (Llvm.build_ret (c32 0) builder);\n  (* Verify *)\n  Llvm_analysis.assert_valid_module the_module;\n  (* Optimize *)\n  ignore (Llvm.PassManager.run_module the_module pm);\n  (* Print out the IR *)\n  Llvm.print_module \"a.ll\" the_module\n"}]}}
Read message 
{"jsonrpc":"2.0","id":46,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/tsimiho/Desktop/NTUA/ECE/Semester8/%CE%9C%CE%B5%CF%84%CE%B1%CE%B3%CE%BB%CF%89%CF%84%CF%84%CE%B9%CF%83%CF%84%CE%AD%CF%82/compiler/Irgen.ml"},"position":{"line":71,"character":0}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0369548797607ms
Sending response {"id": 46, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":47,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/tsimiho/Desktop/NTUA/ECE/Semester8/%CE%9C%CE%B5%CF%84%CE%B1%CE%B3%CE%BB%CF%89%CF%84%CF%84%CE%B9%CF%83%CF%84%CE%AD%CF%82/compiler/Irgen.ml"},"range":{"start":{"line":4,"character":19},"end":{"line":4,"character":37}},"context":{"diagnostics":[{"range":{"start":{"line":4,"character":19},"end":{"line":4,"character":37}},"severity":1,"source":"OCaml Merlin","message":"Unbound module Llvm"}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0250339508057ms
Sending response {"id": 47, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":48,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/tsimiho/Desktop/NTUA/ECE/Semester8/%CE%9C%CE%B5%CF%84%CE%B1%CE%B3%CE%BB%CF%89%CF%84%CF%84%CE%B9%CF%83%CF%84%CE%AD%CF%82/compiler/Irgen.ml"},"position":{"line":4,"character":27}}}
[server] Got a method textDocument/hover
[server] processing took 0.0150203704834ms
Sending response {"id": 48, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":49,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/tsimiho/Desktop/NTUA/ECE/Semester8/%CE%9C%CE%B5%CF%84%CE%B1%CE%B3%CE%BB%CF%89%CF%84%CF%84%CE%B9%CF%83%CF%84%CE%AD%CF%82/compiler/Parser.mly"},"position":{"line":0,"character":0}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0381469726562ms
Sending response {"id": 49, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/tsimiho/Desktop/NTUA/ECE/Semester8/%CE%9C%CE%B5%CF%84%CE%B1%CE%B3%CE%BB%CF%89%CF%84%CF%84%CE%B9%CF%83%CF%84%CE%AD%CF%82/compiler/Parser.mly","version":10},"contentChanges":[{"text":"%{\n  open Symbol\n  open Types\n  open Identifier\n  open Error\n  open Narray\n\n  initSymbolTable 1000;\n\n  type param = { \n    id: Identifier.id list; \n    mode: pass_mode; \n    param_type: typ \n  }\n\n  and param_mode = PASS_BY_VALUE | PASS_BY_REFERENCE\n\n  let registerHeader id params return_type = \n    let fun_entry = newFunction id true in\n    (* openScope(); *)\n    List.iter ( fun p -> \n                  List.iter ( fun single_id -> \n                                ignore (newParameter single_id p.param_type p.mode fun_entry true) \n                            ) p.id\n              ) params;\n    match fun_entry.entry_info with\n    | ENTRY_function func_info ->\n        func_info.function_result <- return_type;\n    | _ -> error \"Expected a function entry %a\" pretty_id id;\n    endFunctionHeader fun_entry return_type\n\n  let callFunction id args =\n    let func_entry = lookupEntry id LOOKUP_ALL_SCOPES true in\n    match func_entry.entry_info with\n    | ENTRY_function inf -> if inf.function_isForward then\n                              let rec linkParams func_params func_args = \n                                match func_params, func_args with\n                                | fp::fps, fa::fas -> if fp.\n                                | [], [] -> inf.function_body () \n                                | _, _ -> error \"Function %a is called with the worng number of parameters\" pretty_id id; None\n                            else error \"%a has not been implemented\" pretty_id id; None\n    | _ -> error \"%a is not a function\" pretty_id id; None\n\n\n  let print_variable_value value =\n    match value with\n    | IntValue i -> Printf.printf \"IntValue: %d\\n\" i\n    | CharValue c -> Printf.printf \"CharValue: '%c'\\n\" c\n    | BoolValue b -> Printf.printf \"BoolValue: %b\\n\" b\n    | MultiArray arr -> Printf.printf \"MultiArray\"\n    | Unit -> Printf.printf \"Unit\\n\"\n\n  let print_grace_type t =\n    match t with\n    | TYPE_int | TYPE_char -> Printf.printf \"Not an array\\n\"\n    | _  -> Printf.printf \"array\\n\"\n        \n%}\n\n%token T_eof \n%token T_and\n%token T_char\n%token T_div\n%token T_do\n%token T_else\n%token T_fun\n%token T_if\n%token T_int \n%token T_mod\n%token T_not\n%token T_nothing\n%token T_or\n%token T_ref\n%token T_return\n%token T_then\n%token T_var\n%token T_while\n%token<string> T_id\n%token<int> T_int_const\n%token<char> T_char_const\n%token<string> T_string_literal\n%token T_eq\n%token T_lparen\n%token T_rparen\n%token T_plus\n%token T_minus\n%token T_times\n%token T_less\n%token T_more\n%token T_lbrack\n%token T_rbrack\n%token T_lbrace\n%token T_rbrace\n%token T_hash\n%token T_comma\n%token T_semicolon\n%token T_colon\n%token T_leq\n%token T_geq\n%token T_prod\n\n%left T_or\n%left T_and\n%nonassoc T_not\n%nonassoc T_eq T_hash T_less T_more T_geq T_leq\n%left T_plus T_minus\n%left T_times T_div T_mod\n\n%start program\n%type <unit -> unit> program\n%type <unit -> Identifier.id option> func_def\n%type <unit -> unit> local_def_list\n%type <unit -> Identifier.id option> header\n%type <unit -> param list> semi_fpar_def_list\n%type <unit -> param> fpar_def\n%type <unit -> Identifier.id list> comma_id_list\n%type <unit -> typ> data_type\n%type <unit -> int list> bracket_int_const_list\n%type <unit -> typ> ret_type\n%type <unit -> typ> fpar_type\n%type <unit -> typ> grace_type\n%type <unit -> Identifier.id option> local_def\n%type <unit -> Identifier.id option> func_decl\n%type <unit -> Identifier.id option> var_def\n%type <unit -> variable_value option> stmt\n%type <unit -> variable_value option> block\n%type <unit -> variable_value option> stmt_list\n%type <unit -> variable_value option> func_call\n%type <unit -> variable_value list> comma_expr_list\n%type <unit -> (string * int list)> l_value\n%type <unit -> variable_value> expr\n%type <unit -> bool> cond\n\n\n%%\n\nprogram: func_def T_eof { fun _ -> match $1 () with\n                                   | Some id -> ignore(callFunction id [])\n                                   | _ -> error \"not a function\"\n                        }\n\nfunc_def: header local_def_list block { fun _ -> begin \n                                          match $1 () with\n                                          | Some func_name -> \n                                              $2 ();\n                                              let func_body = $3 in\n                                              let func_entry = lookupEntry func_name LOOKUP_ALL_SCOPES true in\n                                              (match func_entry.entry_info with\n                                              | ENTRY_function func_info -> func_info.function_body <- func_body; Some func_name\n                                              | _ -> Some func_name)\n                                          | None -> error \"not a function\"; None\n                                        end\n                                      }\n\nlocal_def_list: /* nothing */            { fun _ -> () }\n              | local_def local_def_list { fun _ -> begin ignore($1 ()); $2 () end }\n\nheader: T_fun T_id T_lparen fpar_def semi_fpar_def_list T_rparen T_colon ret_type { fun _ -> let id = (id_make $2) in\n                                                                                             let params = $4 () :: $5 () in\n                                                                                             let return_type = $8 () in \n                                                                                             registerHeader id params return_type;\n                                                                                             Some id\n                                                                                  }\n      | T_fun T_id T_lparen T_rparen T_colon ret_type                             { fun _ -> let id = (id_make $2) in\n                                                                                             let params = [] in\n                                                                                             let return_type = $6 () in \n                                                                                             registerHeader id params return_type;\n                                                                                             Some id\n                                                                                  } \n\nsemi_fpar_def_list: /* nothing */                           { fun _ -> [] }\n                  | T_semicolon fpar_def semi_fpar_def_list { fun _ -> $2 () :: $3 () }\n\nfpar_def: T_ref T_id comma_id_list T_colon fpar_type { fun _ -> let params = (id_make $2) :: $3 () in\n                                                                let param_type = $5 () in\n                                                                { id = params; mode = PASS_BY_REFERENCE ; param_type = param_type }\n                                                     }\n        | T_id comma_id_list T_colon fpar_type       { fun _ -> let params = (id_make $1) :: $2 () in\n                                                                let param_type = $4 () in\n                                                                { id = params; mode = PASS_BY_VALUE ; param_type = param_type }\n                                                     }\n\ncomma_id_list: /* nothing */              { fun _ -> [] }\n             | T_comma T_id comma_id_list { fun _ -> (id_make $2) :: $3 () }\n\ndata_type: T_int  { fun _ -> TYPE_int }\n         | T_char { fun _ -> TYPE_char }\n\nbracket_int_const_list: /* nothing */                                        { fun _ -> [] }\n                      | T_lbrack T_int_const T_rbrack bracket_int_const_list { fun _ -> $2 :: $4 () }\n\nret_type: data_type { fun _ -> $1 () }\n        | T_nothing { fun _ -> TYPE_proc }\n\nfpar_type: data_type T_lbrack T_rbrack bracket_int_const_list { fun _ -> let base_type = $1 () in\n                                                                         let dimensions = max_int :: $4 () in\n                                                                         match dimensions with\n                                                                         | [] -> base_type\n                                                                         | _ -> TYPE_array (base_type, dimensions)\n                                                              } \n         | data_type bracket_int_const_list                   { fun _ -> let base_type = $1 () in\n                                                                         let dimensions = $2 () in\n                                                                         match dimensions with\n                                                                         | [] -> base_type\n                                                                         | _ -> TYPE_array (base_type, dimensions)\n                                                              }\n\ngrace_type: data_type bracket_int_const_list { fun _ -> let base_type = $1 () in\n                                                        let dimensions = $2 () in\n                                                        match dimensions with\n                                                        | [] -> base_type\n                                                        | _ -> TYPE_array (base_type, dimensions)\n                                             }\n\nlocal_def: func_def  { $1 }\n         | func_decl { $1 }\n         | var_def   { $1 }\n\nfunc_decl: header T_semicolon { $1 }\n\nvar_def: T_var T_id comma_id_list T_colon grace_type T_semicolon { fun _ -> let vars = (id_make $2) :: $3 () in\n                                                                            let var_type = $5 () in\n                                                                            print_grace_type var_type;\n                                                                            List.iter ( fun var -> ignore(newVariable var var_type true) ) vars; None\n                                                                 }\n\nstmt: T_semicolon                       { fun _ -> None }\n    | l_value T_prod expr T_semicolon   { fun _ -> let (id,l) = $1 () in\n                                                   let value = $3 () in\n                                                   assignToVariable (id_make id) value;\n                                                   None\n                                        }\n    | block                             { $1 }\n    | func_call T_semicolon             { $1 }\n    | T_if cond T_then stmt             { fun _ -> if $2 () then $4 () else None }\n    | T_if cond T_then stmt T_else stmt { fun _ -> if $2 () then $4 () else $6 () }\n    | T_while cond T_do stmt            { fun _ -> while $2 () do ignore($4 ()) done; None }\n    | T_return T_semicolon              { fun _ -> None }\n    | T_return expr T_semicolon         { fun _ -> Some($2 ()) }\n\n\nblock: T_lbrace stmt_list T_rbrace { $2 }\n\nstmt_list: /* nothing */  { fun _ -> None }\n         | stmt stmt_list { fun _ -> let result = $1 () in\n                                     match result with\n                                     | Some _ as returnValue -> returnValue\n                                     | None -> $2 ()\n      }\n\nfunc_call: T_id T_lparen T_rparen                      { fun _ -> let func_name = $1 in\n                                                                  match func_name with \n                                                                  | \"writeInteger\" -> print_string \"WriteInteger\"; None\n                                                                  | \"writeChar\"    -> print_string \"WriteChar\"; None\n                                                                  | \"writeString\"  -> print_string \"WriteString\"; None\n                                                                  | \"readInteger\"  -> print_string \"ReadInteger\"; None\n                                                                  | \"readChar\"     -> print_string \"ReadChar\"; None\n                                                                  | \"readString\"   -> print_string \"ReadString\"; None\n                                                                  | _ -> let func_entry = lookupEntry (id_make func_name) LOOKUP_ALL_SCOPES true in\n                                                                         (match func_entry.entry_info with\n                                                                         | ENTRY_function func_info ->\n                                                                           if List.length func_info.function_paramlist = 0 then\n                                                                             callFunction (id_make func_name) []\n                                                                           else (error \"Incorrect number of arguments for function %a\" pretty_id (id_make func_name); None)\n                                                                         | _ -> (error \"%a is not a function\" pretty_id (id_make func_name); None))\n                                                       }\n         | T_id T_lparen expr comma_expr_list T_rparen { fun _ -> let func_name = $1 in\n                                                                  let args = $3 () :: $4 () in\n                                                                  match func_name with \n                                                                  | \"writeInteger\" -> print_string \"WriteInteger\"; None\n                                                                  | \"writeChar\"    -> print_string \"WriteChar\"; None\n                                                                  | \"writeString\"  -> print_string \"WriteString\"; None\n                                                                  | \"readInteger\"  -> print_string \"ReadInteger\"; None\n                                                                  | \"readChar\"     -> print_string \"ReadChar\"; None\n                                                                  | \"readString\"   -> print_string \"ReadString\"; None\n                                                                  | _ -> let func_entry = lookupEntry (id_make func_name) LOOKUP_ALL_SCOPES true in\n                                                                         (match func_entry.entry_info with\n                                                                         | ENTRY_function func_info ->\n                                                                           if List.length func_info.function_paramlist = List.length args then\n                                                                           callFunction (id_make func_name) args\n                                                                         else\n                                                                           (error \"Incorrect number of arguments for function %a\" pretty_id (id_make func_name); None)\n                                                                         | _ -> (error \"%a is not a function\" pretty_id (id_make func_name); None))\n                                                       }\n\n\ncomma_expr_list: /* nothing */                { fun _ -> [] }\n               | T_comma expr comma_expr_list { fun _ -> $2 () :: $3 () }\n\nl_value: T_id                           { fun _ -> ($1,[]) }\n       | T_string_literal               { fun _ -> ($1,[]) }\n       | l_value T_lbrack expr T_rbrack { fun _ -> let (value, l) = $1 () in\n                                                   match $3 () with \n                                                   | IntValue exp -> (value, exp :: l)\n                                                   | _ -> error \"not an integer\"; (value, [])\n                                        }\n\n\nexpr: T_int_const            { fun _ -> IntValue $1 }\n    | T_char_const           { fun _ -> CharValue $1 }\n    | l_value                { fun _ -> let (value , l) = $1 () in\n                                        MultiArray (createArray l)\n                             }\n    | T_lparen expr T_rparen { $2 }\n    | func_call              { fun _ -> match $1 () with\n                                        | Some value -> value\n                                        | None -> Unit\n                             }\n    | T_plus expr            { fun _ -> match $2 () with \n                                        | IntValue num -> IntValue num\n                                        | _ -> error \"not an integer; +\"; Unit\n                             }\n    | T_minus expr           { fun _ -> match $2 () with \n                                        | IntValue num -> IntValue (- num)\n                                        | _ -> error \"not an integer; -\"; Unit\n                             }    \n    | expr T_plus expr       { fun _ -> match ($1 (), $3 ()) with\n                                        | (IntValue a, IntValue b) -> IntValue (a + b)\n                                        | _ -> error \"not an integer; plus\"; Unit\n                             }\n    | expr T_minus expr      { fun _ -> let val1 = $1 () in\n                                        let val2 = $3 () in\n                                        print_variable_value val1;\n                                        print_variable_value val2;\n                                        match (val1, val2) with\n                                        | (IntValue a, IntValue b) -> IntValue (a - b)\n                                        | (c, d) -> error \"not an integer; minus\"; Unit\n                             }\n    | expr T_times expr      { fun _ -> match ($1 (), $3 ()) with\n                                        | (IntValue a, IntValue b) -> IntValue (a * b)\n                                        | _ -> error \"not an integer; times\"; Unit\n                             }\n    | expr T_div expr        { fun _ -> match ($1 (), $3 ()) with\n                                        | (IntValue a, IntValue b) -> IntValue (a / b)\n                                        | _ -> error \"not an integer; div\"; Unit\n                             }\n    | expr T_mod expr        { fun _ -> match ($1 (), $3 ()) with\n                                        | (IntValue a, IntValue b) -> IntValue (a mod b)\n                                        | _ -> error \"not an integer; mod\"; Unit\n                             }\n \ncond: T_lparen cond T_rparen { $2 }\n    | T_not cond             { fun _ -> not ($2 ()) }\n    | cond T_and cond        { fun _ -> $1 () && $3 () }\n    | cond T_or cond         { fun _ -> $1 () || $3 () }\n    | expr T_eq expr         { fun _ -> $1 () = $3 () }\n    | expr T_hash expr       { fun _ -> $1 () <> $3 () }\n    | expr T_less expr       { fun _ -> $1 () < $3 () }\n    | expr T_more expr       { fun _ -> $1 () > $3 () }\n    | expr T_leq expr        { fun _ -> $1 () <= $3 () }\n    | expr T_geq expr        { fun _ -> $1 () >= $3 () }\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/tsimiho/Desktop/NTUA/ECE/Semester8/%CE%9C%CE%B5%CF%84%CE%B1%CE%B3%CE%BB%CF%89%CF%84%CF%84%CE%B9%CF%83%CF%84%CE%AD%CF%82/compiler/Parser.mly","version":11},"contentChanges":[{"text":"%{\n  open Symbol\n  open Types\n  open Identifier\n  open Error\n  open Narray\n\n  initSymbolTable 1000;\n\n  type param = { \n    id: Identifier.id list; \n    mode: pass_mode; \n    param_type: typ \n  }\n\n  and param_mode = PASS_BY_VALUE | PASS_BY_REFERENCE\n\n  let registerHeader id params return_type = \n    let fun_entry = newFunction id true in\n    (* openScope(); *)\n    List.iter ( fun p -> \n                  List.iter ( fun single_id -> \n                                ignore (newParameter single_id p.param_type p.mode fun_entry true) \n                            ) p.id\n              ) params;\n    match fun_entry.entry_info with\n    | ENTRY_function func_info ->\n        func_info.function_result <- return_type;\n    | _ -> error \"Expected a function entry %a\" pretty_id id;\n    endFunctionHeader fun_entry return_type\n\n  let callFunction id args =\n    let func_entry = lookupEntry id LOOKUP_ALL_SCOPES true in\n    match func_entry.entry_info with\n    | ENTRY_function inf -> if inf.function_isForward then\n                              let rec linkParams func_params func_args = \n                                match func_params, func_args with\n                                | fp::fps, fa::fas -> if fp.\n                                | [], [] -> inf.function_body () \n                                | _, _ -> error \"Function %a is called with the worng number of parameters\" pretty_id id; None\n                            else error \"%a has not been implemented\" pretty_id id; None\n    | _ -> error \"%a is not a function\" pretty_id id; None\n\n\n  let print_variable_value value =\n    match value with\n    | IntValue i -> Printf.printf \"IntValue: %d\\n\" i\n    | CharValue c -> Printf.printf \"CharValue: '%c'\\n\" c\n    | BoolValue b -> Printf.printf \"BoolValue: %b\\n\" b\n    | MultiArray arr -> Printf.printf \"MultiArray\"\n    | Unit -> Printf.printf \"Unit\\n\"\n\n  let print_grace_type t =\n    match t with\n    | TYPE_int | TYPE_char -> Printf.printf \"Not an array\\n\"\n    | _  -> Printf.printf \"array\\n\"\n        \n%}\n\n%token T_eof \n%token T_and\n%token T_char\n%token T_div\n%token T_do\n%token T_else\n%token T_fun\n%token T_if\n%token T_int \n%token T_mod\n%token T_not\n%token T_nothing\n%token T_or\n%token T_ref\n%token T_return\n%token T_then\n%token T_var\n%token T_while\n%token<string> T_id\n%token<int> T_int_const\n%token<char> T_char_const\n%token<string> T_string_literal\n%token T_eq\n%token T_lparen\n%token T_rparen\n%token T_plus\n%token T_minus\n%token T_times\n%token T_less\n%token T_more\n%token T_lbrack\n%token T_rbrack\n%token T_lbrace\n%token T_rbrace\n%token T_hash\n%token T_comma\n%token T_semicolon\n%token T_colon\n%token T_leq\n%token T_geq\n%token T_prod\n\n%left T_or\n%left T_and\n%nonassoc T_not\n%nonassoc T_eq T_hash T_less T_more T_geq T_leq\n%left T_plus T_minus\n%left T_times T_div T_mod\n\n%start program\n%type <unit -> unit> program\n%type <unit -> Identifier.id option> func_def\n%type <unit -> unit> local_def_list\n%type <unit -> Identifier.id option> header\n%type <unit -> param list> semi_fpar_def_list\n%type <unit -> param> fpar_def\n%type <unit -> Identifier.id list> comma_id_list\n%type <unit -> typ> data_type\n%type <unit -> int list> bracket_int_const_list\n%type <unit -> typ> ret_type\n%type <unit -> typ> fpar_type\n%type <unit -> typ> grace_type\n%type <unit -> Identifier.id option> local_def\n%type <unit -> Identifier.id option> func_decl\n%type <unit -> Identifier.id option> var_def\n%type <unit -> variable_value option> stmt\n%type <unit -> variable_value option> block\n%type <unit -> variable_value option> stmt_list\n%type <unit -> variable_value option> func_call\n%type <unit -> variable_value list> comma_expr_list\n%type <unit -> (string * int list)> l_value\n%type <unit -> variable_value> expr\n%type <unit -> bool> cond\n\n\n%%\n\nprogram: func_def T_eof { fun _ -> match $1 () with\n                                   | Some id -> ignore(callFunction id [])\n                                   | _ -> error \"not a function\"\n                        }\n\nfunc_def: header local_def_list block { fun _ -> begin \n                                          match $1 () with\n                                          | Some func_name -> \n                                              $2 ();\n                                              let func_body = $3 in\n                                              let func_entry = lookupEntry func_name LOOKUP_ALL_SCOPES true in\n                                              (match func_entry.entry_info with\n                                              | ENTRY_function func_info -> func_info.function_body <- func_body; Some func_name\n                                              | _ -> Some func_name)\n                                          | None -> error \"not a function\"; None\n                                        end\n                                      }\n\nlocal_def_list: /* nothing */            { fun _ -> () }\n              | local_def local_def_list { fun _ -> begin ignore($1 ()); $2 () end }\n\nheader: T_fun T_id T_lparen fpar_def semi_fpar_def_list T_rparen T_colon ret_type { fun _ -> let id = (id_make $2) in\n                                                                                             let params = $4 () :: $5 () in\n                                                                                             let return_type = $8 () in \n                                                                                             registerHeader id params return_type;\n                                                                                             Some id\n                                                                                  }\n      | T_fun T_id T_lparen T_rparen T_colon ret_type                             { fun _ -> let id = (id_make $2) in\n                                                                                             let params = [] in\n                                                                                             let return_type = $6 () in \n                                                                                             registerHeader id params return_type;\n                                                                                             Some id\n                                                                                  } \n\nsemi_fpar_def_list: /* nothing */                           { fun _ -> [] }\n                  | T_semicolon fpar_def semi_fpar_def_list { fun _ -> $2 () :: $3 () }\n\nfpar_def: T_ref T_id comma_id_list T_colon fpar_type { fun _ -> let params = (id_make $2) :: $3 () in\n                                                                let param_type = $5 () in\n                                                                { id = params; mode = PASS_BY_REFERENCE ; param_type = param_type }\n                                                     }\n        | T_id comma_id_list T_colon fpar_type       { fun _ -> let params = (id_make $1) :: $2 () in\n                                                                let param_type = $4 () in\n                                                                { id = params; mode = PASS_BY_VALUE ; param_type = param_type }\n                                                     }\n\ncomma_id_list: /* nothing */              { fun _ -> [] }\n             | T_comma T_id comma_id_list { fun _ -> (id_make $2) :: $3 () }\n\ndata_type: T_int  { fun _ -> TYPE_int }\n         | T_char { fun _ -> TYPE_char }\n\nbracket_int_const_list: /* nothing */                                        { fun _ -> [] }\n                      | T_lbrack T_int_const T_rbrack bracket_int_const_list { fun _ -> $2 :: $4 () }\n\nret_type: data_type { fun _ -> $1 () }\n        | T_nothing { fun _ -> TYPE_proc }\n\nfpar_type: data_type T_lbrack T_rbrack bracket_int_const_list { fun _ -> let base_type = $1 () in\n                                                                         let dimensions = max_int :: $4 () in\n                                                                         match dimensions with\n                                                                         | [] -> base_type\n                                                                         | _ -> TYPE_array (base_type, dimensions)\n                                                              } \n         | data_type bracket_int_const_list                   { fun _ -> let base_type = $1 () in\n                                                                         let dimensions = $2 () in\n                                                                         match dimensions with\n                                                                         | [] -> base_type\n                                                                         | _ -> TYPE_array (base_type, dimensions)\n                                                              }\n\ngrace_type: data_type bracket_int_const_list { fun _ -> let base_type = $1 () in\n                                                        let dimensions = $2 () in\n                                                        match dimensions with\n                                                        | [] -> base_type\n                                                        | _ -> TYPE_array (base_type, dimensions)\n                                             }\n\nlocal_def: func_def  { $1 }\n         | func_decl { $1 }\n         | var_def   { $1 }\n\nfunc_decl: header T_semicolon { $1 }\n\nvar_def: T_var T_id comma_id_list T_colon grace_type T_semicolon { fun _ -> let vars = (id_make $2) :: $3 () in\n                                                                            let var_type = $5 () in\n                                                                            print_grace_type var_type;\n                                                                            List.iter ( fun var -> ignore(newVariable var var_type true) ) vars; None\n                                                                 }\n\nstmt: T_semicolon                       { fun _ -> None }\n    | l_value T_prod expr T_semicolon   { fun _ -> let (id,l) = $1 () in\n                                                   let value = $3 () in\n                                                   assignToVariable (id_make id) value;\n                                                   None\n                                        }\n    | block                             { $1 }\n    | func_call T_semicolon             { $1 }\n    | T_if cond T_then stmt             { fun _ -> if $2 () then $4 () else None }\n    | T_if cond T_then stmt T_else stmt { fun _ -> if $2 () then $4 () else $6 () }\n    | T_while cond T_do stmt            { fun _ -> while $2 () do ignore($4 ()) done; None }\n    | T_return T_semicolon              { fun _ -> None }\n    | T_return expr T_semicolon         { fun _ -> Some($2 ()) }\n\n\nblock: T_lbrace stmt_list T_rbrace { $2 }\n\nstmt_list: /* nothing */  { fun _ -> None }\n         | stmt stmt_list { fun _ -> let result = $1 () in\n                                     match result with\n                                     | Some _ as returnValue -> returnValue\n                                     | None -> $2 ()\n      }\n\nfunc_call: T_id T_lparen T_rparen                      { fun _ -> let func_name = $1 in\n                                                                  match func_name with \n                                                                  | \"writeInteger\" -> print_string \"WriteInteger\"; None\n                                                                  | \"writeChar\"    -> print_string \"WriteChar\"; None\n                                                                  | \"writeString\"  -> print_string \"WriteString\"; None\n                                                                  | \"readInteger\"  -> print_string \"ReadInteger\"; None\n                                                                  | \"readChar\"     -> print_string \"ReadChar\"; None\n                                                                  | \"readString\"   -> print_string \"ReadString\"; None\n                                                                  | _ -> let func_entry = lookupEntry (id_make func_name) LOOKUP_ALL_SCOPES true in\n                                                                         (match func_entry.entry_info with\n                                                                         | ENTRY_function func_info ->\n                                                                           if List.length func_info.function_paramlist = 0 then\n                                                                             callFunction (id_make func_name) []\n                                                                           else (error \"Incorrect number of arguments for function %a\" pretty_id (id_make func_name); None)\n                                                                         | _ -> (error \"%a is not a function\" pretty_id (id_make func_name); None))\n                                                       }\n         | T_id T_lparen expr comma_expr_list T_rparen { fun _ -> let func_name = $1 in\n                                                                  let args = $3 () :: $4 () in\n                                                                  match func_name with \n                                                                  | \"writeInteger\" -> print_string \"WriteInteger\"; None\n                                                                  | \"writeChar\"    -> print_string \"WriteChar\"; None\n                                                                  | \"writeString\"  -> print_string \"WriteString\"; None\n                                                                  | \"readInteger\"  -> print_string \"ReadInteger\"; None\n                                                                  | \"readChar\"     -> print_string \"ReadChar\"; None\n                                                                  | \"readString\"   -> print_string \"ReadString\"; None\n                                                                  | _ -> let func_entry = lookupEntry (id_make func_name) LOOKUP_ALL_SCOPES true in\n                                                                         (match func_entry.entry_info with\n                                                                         | ENTRY_function func_info ->\n                                                                           if List.length func_info.function_paramlist = List.length args then\n                                                                           callFunction (id_make func_name) args\n                                                                         else\n                                                                           (error \"Incorrect number of arguments for function %a\" pretty_id (id_make func_name); None)\n                                                                         | _ -> (error \"%a is not a function\" pretty_id (id_make func_name); None))\n                                                       }\n\n\ncomma_expr_list: /* nothing */                { fun _ -> [] }\n               | T_comma expr comma_expr_list { fun _ -> $2 () :: $3 () }\n\nl_value: T_id                           { fun _ -> ($1,[]) }\n       | T_string_literal               { fun _ -> ($1,[]) }\n       | l_value T_lbrack expr T_rbrack { fun _ -> let (value, l) = $1 () in\n                                                   match $3 () with \n                                                   | IntValue exp -> (value, exp :: l)\n                                                   | _ -> error \"not an integer\"; (value, [])\n                                        }\n\n\nexpr: T_int_const            { fun _ -> IntValue $1 }\n    | T_char_const           { fun _ -> CharValue $1 }\n    | l_value                { fun _ -> let (value , l) = $1 () in\n                                        MultiArray (createArray l)\n                             }\n    | T_lparen expr T_rparen { $2 }\n    | func_call              { fun _ -> match $1 () with\n                                        | Some value -> value\n                                        | None -> Unit\n                             }\n    | T_plus expr            { fun _ -> match $2 () with \n                                        | IntValue num -> IntValue num\n                                        | _ -> error \"not an integer; +\"; Unit\n                             }\n    | T_minus expr           { fun _ -> match $2 () with \n                                        | IntValue num -> IntValue (- num)\n                                        | _ -> error \"not an integer; -\"; Unit\n                             }    \n    | expr T_plus expr       { fun _ -> match ($1 (), $3 ()) with\n                                        | (IntValue a, IntValue b) -> IntValue (a + b)\n                                        | _ -> error \"not an integer; plus\"; Unit\n                             }\n    | expr T_minus expr      { fun _ -> let val1 = $1 () in\n                                        let val2 = $3 () in\n                                        print_variable_value val1;\n                                        print_variable_value val2;\n                                        match (val1, val2) with\n                                        | (IntValue a, IntValue b) -> IntValue (a - b)\n                                        | (c, d) -> error \"not an integer; minus\"; Unit\n                             }\n    | expr T_times expr      { fun _ -> match ($1 (), $3 ()) with\n                                        | (IntValue a, IntValue b) -> IntValue (a * b)\n                                        | _ -> error \"not an integer; times\"; Unit\n                             }\n    | expr T_div expr        { fun _ -> match ($1 (), $3 ()) with\n                                        | (IntValue a, IntValue b) -> IntValue (a / b)\n                                        | _ -> error \"not an integer; div\"; Unit\n                             }\n    | expr T_mod expr        { fun _ -> match ($1 (), $3 ()) with\n                                        | (IntValue a, IntValue b) -> IntValue (a mod b)\n                                        | _ -> error \"not an integer; mod\"; Unit\n                             }\n \ncond: T_lparen cond T_rparen { $2 }\n    | T_not cond             { fun _ -> not ($2 ()) }\n    | cond T_and cond        { fun _ -> $1 () && $3 () }\n    | cond T_or cond         { fun _ -> $1 () || $3 () }\n    | expr T_eq expr         { fun _ -> $1 () = $3 () }\n    | expr T_hash expr       { fun _ -> $1 () <> $3 () }\n    | expr T_less expr       { fun _ -> $1 () < $3 () }\n    | expr T_more expr       { fun _ -> $1 () > $3 () }\n    | expr T_leq expr        { fun _ -> $1 () <= $3 () }\n    | expr T_geq expr        { fun _ -> $1 () >= $3 () }\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/tsimiho/Desktop/NTUA/ECE/Semester8/%CE%9C%CE%B5%CF%84%CE%B1%CE%B3%CE%BB%CF%89%CF%84%CF%84%CE%B9%CF%83%CF%84%CE%AD%CF%82/compiler/Parser.mly","version":12},"contentChanges":[{"text":"%{\n  open Symbol\n  open Types\n  open Identifier\n  open Error\n  open Narray\n\n  initSymbolTable 1000;\n\n  type param = { \n    id: Identifier.id list; \n    mode: pass_mode; \n    param_type: typ \n  }\n\n  and param_mode = PASS_BY_VALUE | PASS_BY_REFERENCE\n\n  let registerHeader id params return_type = \n    let fun_entry = newFunction id true in\n    (* openScope(); *)\n    List.iter ( fun p -> \n                  List.iter ( fun single_id -> \n                                ignore (newParameter single_id p.param_type p.mode fun_entry true) \n                            ) p.id\n              ) params;\n    match fun_entry.entry_info with\n    | ENTRY_function func_info ->\n        func_info.function_result <- return_type;\n    | _ -> error \"Expected a function entry %a\" pretty_id id;\n    endFunctionHeader fun_entry return_type\n\n  let callFunction id args =\n    let func_entry = lookupEntry id LOOKUP_ALL_SCOPES true in\n    match func_entry.entry_info with\n    | ENTRY_function inf -> if inf.function_isForward then\n                              let rec linkParams func_params func_args = \n                                match func_params, func_args with\n                                | fp::fps, fa::fas -> if fp.\n                                | [], [] -> inf.function_body () \n                                | _, _ -> error \"Function %a is called with the worng number of parameters\" pretty_id id; None\n                            else error \"%a has not been implemented\" pretty_id id; None\n    | _ -> error \"%a is not a function\" pretty_id id; None\n\n\n  let print_variable_value value =\n    match value with\n    | IntValue i -> Printf.printf \"IntValue: %d\\n\" i\n    | CharValue c -> Printf.printf \"CharValue: '%c'\\n\" c\n    | BoolValue b -> Printf.printf \"BoolValue: %b\\n\" b\n    | MultiArray arr -> Printf.printf \"MultiArray\"\n    | Unit -> Printf.printf \"Unit\\n\"\n\n  let print_grace_type t =\n    match t with\n    | TYPE_int | TYPE_char -> Printf.printf \"Not an array\\n\"\n    | _  -> Printf.printf \"array\\n\"\n        \n%}\n\n%token T_eof \n%token T_and\n%token T_char\n%token T_div\n%token T_do\n%token T_else\n%token T_fun\n%token T_if\n%token T_int \n%token T_mod\n%token T_not\n%token T_nothing\n%token T_or\n%token T_ref\n%token T_return\n%token T_then\n%token T_var\n%token T_while\n%token<string> T_id\n%token<int> T_int_const\n%token<char> T_char_const\n%token<string> T_string_literal\n%token T_eq\n%token T_lparen\n%token T_rparen\n%token T_plus\n%token T_minus\n%token T_times\n%token T_less\n%token T_more\n%token T_lbrack\n%token T_rbrack\n%token T_lbrace\n%token T_rbrace\n%token T_hash\n%token T_comma\n%token T_semicolon\n%token T_colon\n%token T_leq\n%token T_geq\n%token T_prod\n\n%left T_or\n%left T_and\n%nonassoc T_not\n%nonassoc T_eq T_hash T_less T_more T_geq T_leq\n%left T_plus T_minus\n%left T_times T_div T_mod\n\n%start program\n%type <unit -> unit> program\n%type <unit -> Identifier.id option> func_def\n%type <unit -> unit> local_def_list\n%type <unit -> Identifier.id option> header\n%type <unit -> param list> semi_fpar_def_list\n%type <unit -> param> fpar_def\n%type <unit -> Identifier.id list> comma_id_list\n%type <unit -> typ> data_type\n%type <unit -> int list> bracket_int_const_list\n%type <unit -> typ> ret_type\n%type <unit -> typ> fpar_type\n%type <unit -> typ> grace_type\n%type <unit -> Identifier.id option> local_def\n%type <unit -> Identifier.id option> func_decl\n%type <unit -> Identifier.id option> var_def\n%type <unit -> variable_value option> stmt\n%type <unit -> variable_value option> block\n%type <unit -> variable_value option> stmt_list\n%type <unit -> variable_value option> func_call\n%type <unit -> variable_value list> comma_expr_list\n%type <unit -> (string * int list)> l_value\n%type <unit -> variable_value> expr\n%type <unit -> bool> cond\n\n\n%%\n\nprogram: func_def T_eof { fun _ -> match $1 () with\n                                   | Some id -> ignore(callFunction id [])\n                                   | _ -> error \"not a function\"\n                        }\n\nfunc_def: header local_def_list block { fun _ -> begin \n                                          match $1 () with\n                                          | Some func_name -> \n                                              $2 ();\n                                              let func_body = $3 in\n                                              let func_entry = lookupEntry func_name LOOKUP_ALL_SCOPES true in\n                                              (match func_entry.entry_info with\n                                              | ENTRY_function func_info -> func_info.function_body <- func_body; Some func_name\n                                              | _ -> Some func_name)\n                                          | None -> error \"not a function\"; None\n                                        end\n                                      }\n\nlocal_def_list: /* nothing */            { fun _ -> () }\n              | local_def local_def_list { fun _ -> begin ignore($1 ()); $2 () end }\n\nheader: T_fun T_id T_lparen fpar_def semi_fpar_def_list T_rparen T_colon ret_type { fun _ -> let id = (id_make $2) in\n                                                                                             let params = $4 () :: $5 () in\n                                                                                             let return_type = $8 () in \n                                                                                             registerHeader id params return_type;\n                                                                                             Some id\n                                                                                  }\n      | T_fun T_id T_lparen T_rparen T_colon ret_type                             { fun _ -> let id = (id_make $2) in\n                                                                                             let params = [] in\n                                                                                             let return_type = $6 () in \n                                                                                             registerHeader id params return_type;\n                                                                                             Some id\n                                                                                  } \n\nsemi_fpar_def_list: /* nothing */                           { fun _ -> [] }\n                  | T_semicolon fpar_def semi_fpar_def_list { fun _ -> $2 () :: $3 () }\n\nfpar_def: T_ref T_id comma_id_list T_colon fpar_type { fun _ -> let params = (id_make $2) :: $3 () in\n                                                                let param_type = $5 () in\n                                                                { id = params; mode = PASS_BY_REFERENCE ; param_type = param_type }\n                                                     }\n        | T_id comma_id_list T_colon fpar_type       { fun _ -> let params = (id_make $1) :: $2 () in\n                                                                let param_type = $4 () in\n                                                                { id = params; mode = PASS_BY_VALUE ; param_type = param_type }\n                                                     }\n\ncomma_id_list: /* nothing */              { fun _ -> [] }\n             | T_comma T_id comma_id_list { fun _ -> (id_make $2) :: $3 () }\n\ndata_type: T_int  { fun _ -> TYPE_int }\n         | T_char { fun _ -> TYPE_char }\n\nbracket_int_const_list: /* nothing */                                        { fun _ -> [] }\n                      | T_lbrack T_int_const T_rbrack bracket_int_const_list { fun _ -> $2 :: $4 () }\n\nret_type: data_type { fun _ -> $1 () }\n        | T_nothing { fun _ -> TYPE_proc }\n\nfpar_type: data_type T_lbrack T_rbrack bracket_int_const_list { fun _ -> let base_type = $1 () in\n                                                                         let dimensions = max_int :: $4 () in\n                                                                         match dimensions with\n                                                                         | [] -> base_type\n                                                                         | _ -> TYPE_array (base_type, dimensions)\n                                                              } \n         | data_type bracket_int_const_list                   { fun _ -> let base_type = $1 () in\n                                                                         let dimensions = $2 () in\n                                                                         match dimensions with\n                                                                         | [] -> base_type\n                                                                         | _ -> TYPE_array (base_type, dimensions)\n                                                              }\n\ngrace_type: data_type bracket_int_const_list { fun _ -> let base_type = $1 () in\n                                                        let dimensions = $2 () in\n                                                        match dimensions with\n                                                        | [] -> base_type\n                                                        | _ -> TYPE_array (base_type, dimensions)\n                                             }\n\nlocal_def: func_def  { $1 }\n         | func_decl { $1 }\n         | var_def   { $1 }\n\nfunc_decl: header T_semicolon { $1 }\n\nvar_def: T_var T_id comma_id_list T_colon grace_type T_semicolon { fun _ -> let vars = (id_make $2) :: $3 () in\n                                                                            let var_type = $5 () in\n                                                                            print_grace_type var_type;\n                                                                            List.iter ( fun var -> ignore(newVariable var var_type true) ) vars; None\n                                                                 }\n\nstmt: T_semicolon                       { fun _ -> None }\n    | l_value T_prod expr T_semicolon   { fun _ -> let (id,l) = $1 () in\n                                                   let value = $3 () in\n                                                   assignToVariable (id_make id) value;\n                                                   None\n                                        }\n    | block                             { $1 }\n    | func_call T_semicolon             { $1 }\n    | T_if cond T_then stmt             { fun _ -> if $2 () then $4 () else None }\n    | T_if cond T_then stmt T_else stmt { fun _ -> if $2 () then $4 () else $6 () }\n    | T_while cond T_do stmt            { fun _ -> while $2 () do ignore($4 ()) done; None }\n    | T_return T_semicolon              { fun _ -> None }\n    | T_return expr T_semicolon         { fun _ -> Some($2 ()) }\n\n\nblock: T_lbrace stmt_list T_rbrace { $2 }\n\nstmt_list: /* nothing */  { fun _ -> None }\n         | stmt stmt_list { fun _ -> let result = $1 () in\n                                     match result with\n                                     | Some _ as returnValue -> returnValue\n                                     | None -> $2 ()\n      }\n\nfunc_call: T_id T_lparen T_rparen                      { fun _ -> let func_name = $1 in\n                                                                  match func_name with \n                                                                  | \"writeInteger\" -> print_string \"WriteInteger\"; None\n                                                                  | \"writeChar\"    -> print_string \"WriteChar\"; None\n                                                                  | \"writeString\"  -> print_string \"WriteString\"; None\n                                                                  | \"readInteger\"  -> print_string \"ReadInteger\"; None\n                                                                  | \"readChar\"     -> print_string \"ReadChar\"; None\n                                                                  | \"readString\"   -> print_string \"ReadString\"; None\n                                                                  | _ -> let func_entry = lookupEntry (id_make func_name) LOOKUP_ALL_SCOPES true in\n                                                                         (match func_entry.entry_info with\n                                                                         | ENTRY_function func_info ->\n                                                                           if List.length func_info.function_paramlist = 0 then\n                                                                             callFunction (id_make func_name) []\n                                                                           else (error \"Incorrect number of arguments for function %a\" pretty_id (id_make func_name); None)\n                                                                         | _ -> (error \"%a is not a function\" pretty_id (id_make func_name); None))\n                                                       }\n         | T_id T_lparen expr comma_expr_list T_rparen { fun _ -> let func_name = $1 in\n                                                                  let args = $3 () :: $4 () in\n                                                                  match func_name with \n                                                                  | \"writeInteger\" -> print_string \"WriteInteger\"; None\n                                                                  | \"writeChar\"    -> print_string \"WriteChar\"; None\n                                                                  | \"writeString\"  -> print_string \"WriteString\"; None\n                                                                  | \"readInteger\"  -> print_string \"ReadInteger\"; None\n                                                                  | \"readChar\"     -> print_string \"ReadChar\"; None\n                                                                  | \"readString\"   -> print_string \"ReadString\"; None\n                                                                  | _ -> let func_entry = lookupEntry (id_make func_name) LOOKUP_ALL_SCOPES true in\n                                                                         (match func_entry.entry_info with\n                                                                         | ENTRY_function func_info ->\n                                                                           if List.length func_info.function_paramlist = List.length args then\n                                                                           callFunction (id_make func_name) args\n                                                                         else\n                                                                           (error \"Incorrect number of arguments for function %a\" pretty_id (id_make func_name); None)\n                                                                         | _ -> (error \"%a is not a function\" pretty_id (id_make func_name); None))\n                                                       }\n\n\ncomma_expr_list: /* nothing */                { fun _ -> [] }\n               | T_comma expr comma_expr_list { fun _ -> $2 () :: $3 () }\n\nl_value: T_id                           { fun _ -> ($1,[]) }\n       | T_string_literal               { fun _ -> ($1,[]) }\n       | l_value T_lbrack expr T_rbrack { fun _ -> let (value, l) = $1 () in\n                                                   match $3 () with \n                                                   | IntValue exp -> (value, exp :: l)\n                                                   | _ -> error \"not an integer\"; (value, [])\n                                        }\n\n\nexpr: T_int_const            { fun _ -> IntValue $1 }\n    | T_char_const           { fun _ -> CharValue $1 }\n    | l_value                { fun _ -> let (value , l) = $1 () in\n                                        MultiArray (createArray l)\n                             }\n    | T_lparen expr T_rparen { $2 }\n    | func_call              { fun _ -> match $1 () with\n                                        | Some value -> value\n                                        | None -> Unit\n                             }\n    | T_plus expr            { fun _ -> match $2 () with \n                                        | IntValue num -> IntValue num\n                                        | _ -> error \"not an integer; +\"; Unit\n                             }\n    | T_minus expr           { fun _ -> match $2 () with \n                                        | IntValue num -> IntValue (- num)\n                                        | _ -> error \"not an integer; -\"; Unit\n                             }    \n    | expr T_plus expr       { fun _ -> match ($1 (), $3 ()) with\n                                        | (IntValue a, IntValue b) -> IntValue (a + b)\n                                        | _ -> error \"not an integer; plus\"; Unit\n                             }\n    | expr T_minus expr      { fun _ -> let val1 = $1 () in\n                                        let val2 = $3 () in\n                                        print_variable_value val1;\n                                        print_variable_value val2;\n                                        match (val1, val2) with\n                                        | (IntValue a, IntValue b) -> IntValue (a - b)\n                                        | (c, d) -> error \"not an integer; minus\"; Unit\n                             }\n    | expr T_times expr      { fun _ -> match ($1 (), $3 ()) with\n                                        | (IntValue a, IntValue b) -> IntValue (a * b)\n                                        | _ -> error \"not an integer; times\"; Unit\n                             }\n    | expr T_div expr        { fun _ -> match ($1 (), $3 ()) with\n                                        | (IntValue a, IntValue b) -> IntValue (a / b)\n                                        | _ -> error \"not an integer; div\"; Unit\n                             }\n    | expr T_mod expr        { fun _ -> match ($1 (), $3 ()) with\n                                        | (IntValue a, IntValue b) -> IntValue (a mod b)\n                                        | _ -> error \"not an integer; mod\"; Unit\n                             }\n \ncond: T_lparen cond T_rparen { $2 }\n    | T_not cond             { fun _ -> not ($2 ()) }\n    | cond T_and cond        { fun _ -> $1 () && $3 () }\n    | cond T_or cond         { fun _ -> $1 () || $3 () }\n    | expr T_eq expr         { fun _ -> $1 () = $3 () }\n    | expr T_hash expr       { fun _ -> $1 () <> $3 () }\n    | expr T_less expr       { fun _ -> $1 () < $3 () }\n    | expr T_more expr       { fun _ -> $1 () > $3 () }\n    | expr T_leq expr        { fun _ -> $1 () <= $3 () }\n    | expr T_geq expr        { fun _ -> $1 () >= $3 () }\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/tsimiho/Desktop/NTUA/ECE/Semester8/%CE%9C%CE%B5%CF%84%CE%B1%CE%B3%CE%BB%CF%89%CF%84%CF%84%CE%B9%CF%83%CF%84%CE%AD%CF%82/compiler/Parser.mly","version":13},"contentChanges":[{"text":"%{\n  open Symbol\n  open Types\n  open Identifier\n  open Error\n  open Narray\n\n  initSymbolTable 1000;\n\n  type param = { \n    id: Identifier.id list; \n    mode: pass_mode; \n    param_type: typ \n  }\n\n  and param_mode = PASS_BY_VALUE | PASS_BY_REFERENCE\n\n  let registerHeader id params return_type = \n    let fun_entry = newFunction id true in\n    (* openScope(); *)\n    List.iter ( fun p -> \n                  List.iter ( fun single_id -> \n                                ignore (newParameter single_id p.param_type p.mode fun_entry true) \n                            ) p.id\n              ) params;\n    match fun_entry.entry_info with\n    | ENTRY_function func_info ->\n        func_info.function_result <- return_type;\n    | _ -> error \"Expected a function entry %a\" pretty_id id;\n    endFunctionHeader fun_entry return_type\n\n  let callFunction id args =\n    let func_entry = lookupEntry id LOOKUP_ALL_SCOPES true in\n    match func_entry.entry_info with\n    | ENTRY_function inf -> if inf.function_isForward then\n                              let rec linkParams func_params func_args = \n                                match func_params, func_args with\n                                | fp::fps, fa::fas -> if fp.\n                                | [], [] -> inf.function_body () \n                                | _, _ -> error \"Function %a is called with the worng number of parameters\" pretty_id id; None\n                            else error \"%a has not been implemented\" pretty_id id; None\n    | _ -> error \"%a is not a function\" pretty_id id; None\n\n\n  let print_variable_value value =\n    match value with\n    | IntValue i -> Printf.printf \"IntValue: %d\\n\" i\n    | CharValue c -> Printf.printf \"CharValue: '%c'\\n\" c\n    | BoolValue b -> Printf.printf \"BoolValue: %b\\n\" b\n    | MultiArray arr -> Printf.printf \"MultiArray\"\n    | Unit -> Printf.printf \"Unit\\n\"\n\n  let print_grace_type t =\n    match t with\n    | TYPE_int | TYPE_char -> Printf.printf \"Not an array\\n\"\n    | _  -> Printf.printf \"array\\n\"\n        \n%}\n\n%token T_eof \n%token T_and\n%token T_char\n%token T_div\n%token T_do\n%token T_else\n%token T_fun\n%token T_if\n%token T_int \n%token T_mod\n%token T_not\n%token T_nothing\n%token T_or\n%token T_ref\n%token T_return\n%token T_then\n%token T_var\n%token T_while\n%token<string> T_id\n%token<int> T_int_const\n%token<char> T_char_const\n%token<string> T_string_literal\n%token T_eq\n%token T_lparen\n%token T_rparen\n%token T_plus\n%token T_minus\n%token T_times\n%token T_less\n%token T_more\n%token T_lbrack\n%token T_rbrack\n%token T_lbrace\n%token T_rbrace\n%token T_hash\n%token T_comma\n%token T_semicolon\n%token T_colon\n%token T_leq\n%token T_geq\n%token T_prod\n\n%left T_or\n%left T_and\n%nonassoc T_not\n%nonassoc T_eq T_hash T_less T_more T_geq T_leq\n%left T_plus T_minus\n%left T_times T_div T_mod\n\n%start program\n%type <unit -> unit> program\n%type <unit -> Identifier.id option> func_def\n%type <unit -> unit> local_def_list\n%type <unit -> Identifier.id option> header\n%type <unit -> param list> semi_fpar_def_list\n%type <unit -> param> fpar_def\n%type <unit -> Identifier.id list> comma_id_list\n%type <unit -> typ> data_type\n%type <unit -> int list> bracket_int_const_list\n%type <unit -> typ> ret_type\n%type <unit -> typ> fpar_type\n%type <unit -> typ> grace_type\n%type <unit -> Identifier.id option> local_def\n%type <unit -> Identifier.id option> func_decl\n%type <unit -> Identifier.id option> var_def\n%type <unit -> variable_value option> stmt\n%type <unit -> variable_value option> block\n%type <unit -> variable_value option> stmt_list\n%type <unit -> variable_value option> func_call\n%type <unit -> variable_value list> comma_expr_list\n%type <unit -> (string * int list)> l_value\n%type <unit -> variable_value> expr\n%type <unit -> bool> cond\n\n\n%%\n\nprogram: func_def T_eof { fun _ -> match $1 () with\n                                   | Some id -> ignore(callFunction id [])\n                                   | _ -> error \"not a function\"\n                        }\n\nfunc_def: header local_def_list block { fun _ -> begin \n                                          match $1 () with\n                                          | Some func_name -> \n                                              $2 ();\n                                              let func_body = $3 in\n                                              let func_entry = lookupEntry func_name LOOKUP_ALL_SCOPES true in\n                                              (match func_entry.entry_info with\n                                              | ENTRY_function func_info -> func_info.function_body <- func_body; Some func_name\n                                              | _ -> Some func_name)\n                                          | None -> error \"not a function\"; None\n                                        end\n                                      }\n\nlocal_def_list: /* nothing */            { fun _ -> () }\n              | local_def local_def_list { fun _ -> begin ignore($1 ()); $2 () end }\n\nheader: T_fun T_id T_lparen fpar_def semi_fpar_def_list T_rparen T_colon ret_type { fun _ -> let id = (id_make $2) in\n                                                                                             let params = $4 () :: $5 () in\n                                                                                             let return_type = $8 () in \n                                                                                             registerHeader id params return_type;\n                                                                                             Some id\n                                                                                  }\n      | T_fun T_id T_lparen T_rparen T_colon ret_type                             { fun _ -> let id = (id_make $2) in\n                                                                                             let params = [] in\n                                                                                             let return_type = $6 () in \n                                                                                             registerHeader id params return_type;\n                                                                                             Some id\n                                                                                  } \n\nsemi_fpar_def_list: /* nothing */                           { fun _ -> [] }\n                  | T_semicolon fpar_def semi_fpar_def_list { fun _ -> $2 () :: $3 () }\n\nfpar_def: T_ref T_id comma_id_list T_colon fpar_type { fun _ -> let params = (id_make $2) :: $3 () in\n                                                                let param_type = $5 () in\n                                                                { id = params; mode = PASS_BY_REFERENCE ; param_type = param_type }\n                                                     }\n        | T_id comma_id_list T_colon fpar_type       { fun _ -> let params = (id_make $1) :: $2 () in\n                                                                let param_type = $4 () in\n                                                                { id = params; mode = PASS_BY_VALUE ; param_type = param_type }\n                                                     }\n\ncomma_id_list: /* nothing */              { fun _ -> [] }\n             | T_comma T_id comma_id_list { fun _ -> (id_make $2) :: $3 () }\n\ndata_type: T_int  { fun _ -> TYPE_int }\n         | T_char { fun _ -> TYPE_char }\n\nbracket_int_const_list: /* nothing */                                        { fun _ -> [] }\n                      | T_lbrack T_int_const T_rbrack bracket_int_const_list { fun _ -> $2 :: $4 () }\n\nret_type: data_type { fun _ -> $1 () }\n        | T_nothing { fun _ -> TYPE_proc }\n\nfpar_type: data_type T_lbrack T_rbrack bracket_int_const_list { fun _ -> let base_type = $1 () in\n                                                                         let dimensions = max_int :: $4 () in\n                                                                         match dimensions with\n                                                                         | [] -> base_type\n                                                                         | _ -> TYPE_array (base_type, dimensions)\n                                                              } \n         | data_type bracket_int_const_list                   { fun _ -> let base_type = $1 () in\n                                                                         let dimensions = $2 () in\n                                                                         match dimensions with\n                                                                         | [] -> base_type\n                                                                         | _ -> TYPE_array (base_type, dimensions)\n                                                              }\n\ngrace_type: data_type bracket_int_const_list { fun _ -> let base_type = $1 () in\n                                                        let dimensions = $2 () in\n                                                        match dimensions with\n                                                        | [] -> base_type\n                                                        | _ -> TYPE_array (base_type, dimensions)\n                                             }\n\nlocal_def: func_def  { $1 }\n         | func_decl { $1 }\n         | var_def   { $1 }\n\nfunc_decl: header T_semicolon { $1 }\n\nvar_def: T_var T_id comma_id_list T_colon grace_type T_semicolon { fun _ -> let vars = (id_make $2) :: $3 () in\n                                                                            let var_type = $5 () in\n                                                                            print_grace_type var_type;\n                                                                            List.iter ( fun var -> ignore(newVariable var var_type true) ) vars; None\n                                                                 }\n\nstmt: T_semicolon                       { fun _ -> None }\n    | l_value T_prod expr T_semicolon   { fun _ -> let (id,l) = $1 () in\n                                                   let value = $3 () in\n                                                   assignToVariable (id_make id) value;\n                                                   None\n                                        }\n    | block                             { $1 }\n    | func_call T_semicolon             { $1 }\n    | T_if cond T_then stmt             { fun _ -> if $2 () then $4 () else None }\n    | T_if cond T_then stmt T_else stmt { fun _ -> if $2 () then $4 () else $6 () }\n    | T_while cond T_do stmt            { fun _ -> while $2 () do ignore($4 ()) done; None }\n    | T_return T_semicolon              { fun _ -> None }\n    | T_return expr T_semicolon         { fun _ -> Some($2 ()) }\n\n\nblock: T_lbrace stmt_list T_rbrace { $2 }\n\nstmt_list: /* nothing */  { fun _ -> None }\n         | stmt stmt_list { fun _ -> let result = $1 () in\n                                     match result with\n                                     | Some _ as returnValue -> returnValue\n                                     | None -> $2 ()\n      }\n\nfunc_call: T_id T_lparen T_rparen                      { fun _ -> let func_name = $1 in\n                                                                  match func_name with \n                                                                  | \"writeInteger\" -> print_string \"WriteInteger\"; None\n                                                                  | \"writeChar\"    -> print_string \"WriteChar\"; None\n                                                                  | \"writeString\"  -> print_string \"WriteString\"; None\n                                                                  | \"readInteger\"  -> print_string \"ReadInteger\"; None\n                                                                  | \"readChar\"     -> print_string \"ReadChar\"; None\n                                                                  | \"readString\"   -> print_string \"ReadString\"; None\n                                                                  | _ -> let func_entry = lookupEntry (id_make func_name) LOOKUP_ALL_SCOPES true in\n                                                                         (match func_entry.entry_info with\n                                                                         | ENTRY_function func_info ->\n                                                                           if List.length func_info.function_paramlist = 0 then\n                                                                             callFunction (id_make func_name) []\n                                                                           else (error \"Incorrect number of arguments for function %a\" pretty_id (id_make func_name); None)\n                                                                         | _ -> (error \"%a is not a function\" pretty_id (id_make func_name); None))\n                                                       }\n         | T_id T_lparen expr comma_expr_list T_rparen { fun _ -> let func_name = $1 in\n                                                                  let args = $3 () :: $4 () in\n                                                                  match func_name with \n                                                                  | \"writeInteger\" -> print_string \"WriteInteger\"; None\n                                                                  | \"writeChar\"    -> print_string \"WriteChar\"; None\n                                                                  | \"writeString\"  -> print_string \"WriteString\"; None\n                                                                  | \"readInteger\"  -> print_string \"ReadInteger\"; None\n                                                                  | \"readChar\"     -> print_string \"ReadChar\"; None\n                                                                  | \"readString\"   -> print_string \"ReadString\"; None\n                                                                  | _ -> let func_entry = lookupEntry (id_make func_name) LOOKUP_ALL_SCOPES true in\n                                                                         (match func_entry.entry_info with\n                                                                         | ENTRY_function func_info ->\n                                                                           if List.length func_info.function_paramlist = List.length args then\n                                                                           callFunction (id_make func_name) args\n                                                                         else\n                                                                           (error \"Incorrect number of arguments for function %a\" pretty_id (id_make func_name); None)\n                                                                         | _ -> (error \"%a is not a function\" pretty_id (id_make func_name); None))\n                                                       }\n\n\ncomma_expr_list: /* nothing */                { fun _ -> [] }\n               | T_comma expr comma_expr_list { fun _ -> $2 () :: $3 () }\n\nl_value: T_id                           { fun _ -> ($1,[]) }\n       | T_string_literal               { fun _ -> ($1,[]) }\n       | l_value T_lbrack expr T_rbrack { fun _ -> let (value, l) = $1 () in\n                                                   match $3 () with \n                                                   | IntValue exp -> (value, exp :: l)\n                                                   | _ -> error \"not an integer\"; (value, [])\n                                        }\n\n\nexpr: T_int_const            { fun _ -> IntValue $1 }\n    | T_char_const           { fun _ -> CharValue $1 }\n    | l_value                { fun _ -> let (value , l) = $1 () in\n                                        MultiArray (createArray l)\n                             }\n    | T_lparen expr T_rparen { $2 }\n    | func_call              { fun _ -> match $1 () with\n                                        | Some value -> value\n                                        | None -> Unit\n                             }\n    | T_plus expr            { fun _ -> match $2 () with \n                                        | IntValue num -> IntValue num\n                                        | _ -> error \"not an integer; +\"; Unit\n                             }\n    | T_minus expr           { fun _ -> match $2 () with \n                                        | IntValue num -> IntValue (- num)\n                                        | _ -> error \"not an integer; -\"; Unit\n                             }    \n    | expr T_plus expr       { fun _ -> match ($1 (), $3 ()) with\n                                        | (IntValue a, IntValue b) -> IntValue (a + b)\n                                        | _ -> error \"not an integer; plus\"; Unit\n                             }\n    | expr T_minus expr      { fun _ -> let val1 = $1 () in\n                                        let val2 = $3 () in\n                                        print_variable_value val1;\n                                        print_variable_value val2;\n                                        match (val1, val2) with\n                                        | (IntValue a, IntValue b) -> IntValue (a - b)\n                                        | (c, d) -> error \"not an integer; minus\"; Unit\n                             }\n    | expr T_times expr      { fun _ -> match ($1 (), $3 ()) with\n                                        | (IntValue a, IntValue b) -> IntValue (a * b)\n                                        | _ -> error \"not an integer; times\"; Unit\n                             }\n    | expr T_div expr        { fun _ -> match ($1 (), $3 ()) with\n                                        | (IntValue a, IntValue b) -> IntValue (a / b)\n                                        | _ -> error \"not an integer; div\"; Unit\n                             }\n    | expr T_mod expr        { fun _ -> match ($1 (), $3 ()) with\n                                        | (IntValue a, IntValue b) -> IntValue (a mod b)\n                                        | _ -> error \"not an integer; mod\"; Unit\n                             }\n \ncond: T_lparen cond T_rparen { $2 }\n    | T_not cond             { fun _ -> not ($2 ()) }\n    | cond T_and cond        { fun _ -> $1 () && $3 () }\n    | cond T_or cond         { fun _ -> $1 () || $3 () }\n    | expr T_eq expr         { fun _ -> $1 () = $3 () }\n    | expr T_hash expr       { fun _ -> $1 () <> $3 () }\n    | expr T_less expr       { fun _ -> $1 () < $3 () }\n    | expr T_more expr       { fun _ -> $1 () > $3 () }\n    | expr T_leq expr        { fun _ -> $1 () <= $3 () }\n    | expr T_geq expr        { fun _ -> $1 () >= $3 () }\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/tsimiho/Desktop/NTUA/ECE/Semester8/%CE%9C%CE%B5%CF%84%CE%B1%CE%B3%CE%BB%CF%89%CF%84%CF%84%CE%B9%CF%83%CF%84%CE%AD%CF%82/compiler/Parser.mly","version":14},"contentChanges":[{"text":"%{\n  open Symbol\n  open Types\n  open Identifier\n  open Error\n  open Narray\n\n  initSymbolTable 1000;\n\n  type param = { \n    id: Identifier.id list; \n    mode: pass_mode; \n    param_type: typ \n  }\n\n  and param_mode = PASS_BY_VALUE | PASS_BY_REFERENCE\n\n  let registerHeader id params return_type = \n    let fun_entry = newFunction id true in\n    (* openScope(); *)\n    List.iter ( fun p -> \n                  List.iter ( fun single_id -> \n                                ignore (newParameter single_id p.param_type p.mode fun_entry true) \n                            ) p.id\n              ) params;\n    match fun_entry.entry_info with\n    | ENTRY_function func_info ->\n        func_info.function_result <- return_type;\n    | _ -> error \"Expected a function entry %a\" pretty_id id;\n    endFunctionHeader fun_entry return_type\n\n  let callFunction id args =\n    let func_entry = lookupEntry id LOOKUP_ALL_SCOPES true in\n    match func_entry.entry_info with\n    | ENTRY_function inf -> if inf.function_isForward then\n                              let rec linkParams func_params func_args = \n                                match func_params, func_args with\n                                | fp::fps, fa::fas -> if fp.\n                                | [], [] -> inf.function_body () \n                                | _, _ -> error \"Function %a is called with the worng number of parameters\" pretty_id id; None\n                            else error \"%a has not been implemented\" pretty_id id; None\n    | _ -> error \"%a is not a function\" pretty_id id; None\n\n\n  let print_variable_value value =\n    match value with\n    | IntValue i -> Printf.printf \"IntValue: %d\\n\" i\n    | CharValue c -> Printf.printf \"CharValue: '%c'\\n\" c\n    | BoolValue b -> Printf.printf \"BoolValue: %b\\n\" b\n    | MultiArray arr -> Printf.printf \"MultiArray\"\n    | Unit -> Printf.printf \"Unit\\n\"\n\n  let print_grace_type t =\n    match t with\n    | TYPE_int | TYPE_char -> Printf.printf \"Not an array\\n\"\n    | _  -> Printf.printf \"array\\n\"\n        \n%}\n\n%token T_eof \n%token T_and\n%token T_char\n%token T_div\n%token T_do\n%token T_else\n%token T_fun\n%token T_if\n%token T_int \n%token T_mod\n%token T_not\n%token T_nothing\n%token T_or\n%token T_ref\n%token T_return\n%token T_then\n%token T_var\n%token T_while\n%token<string> T_id\n%token<int> T_int_const\n%token<char> T_char_const\n%token<string> T_string_literal\n%token T_eq\n%token T_lparen\n%token T_rparen\n%token T_plus\n%token T_minus\n%token T_times\n%token T_less\n%token T_more\n%token T_lbrack\n%token T_rbrack\n%token T_lbrace\n%token T_rbrace\n%token T_hash\n%token T_comma\n%token T_semicolon\n%token T_colon\n%token T_leq\n%token T_geq\n%token T_prod\n\n%left T_or\n%left T_and\n%nonassoc T_not\n%nonassoc T_eq T_hash T_less T_more T_geq T_leq\n%left T_plus T_minus\n%left T_times T_div T_mod\n\n%start program\n%type <unit -> unit> program\n%type <unit -> Identifier.id option> func_def\n%type <unit -> unit> local_def_list\n%type <unit -> Identifier.id option> header\n%type <unit -> param list> semi_fpar_def_list\n%type <unit -> param> fpar_def\n%type <unit -> Identifier.id list> comma_id_list\n%type <unit -> typ> data_type\n%type <unit -> int list> bracket_int_const_list\n%type <unit -> typ> ret_type\n%type <unit -> typ> fpar_type\n%type <unit -> typ> grace_type\n%type <unit -> Identifier.id option> local_def\n%type <unit -> Identifier.id option> func_decl\n%type <unit -> Identifier.id option> var_def\n%type <unit -> variable_value option> stmt\n%type <unit -> variable_value option> block\n%type <unit -> variable_value option> stmt_list\n%type <unit -> variable_value option> func_call\n%type <unit -> variable_value list> comma_expr_list\n%type <unit -> (string * int list)> l_value\n%type <unit -> variable_value> expr\n%type <unit -> bool> cond\n\n\n%%\n\nprogram: func_def T_eof { fun _ -> match $1 () with\n                                   | Some id -> ignore(callFunction id [])\n                                   | _ -> error \"not a function\"\n                        }\n\nfunc_def: header local_def_list block { fun _ -> begin \n                                          match $1 () with\n                                          | Some func_name -> \n                                              $2 ();\n                                              let func_body = $3 in\n                                              let func_entry = lookupEntry func_name LOOKUP_ALL_SCOPES true in\n                                              (match func_entry.entry_info with\n                                              | ENTRY_function func_info -> func_info.function_body <- func_body; Some func_name\n                                              | _ -> Some func_name)\n                                          | None -> error \"not a function\"; None\n                                        end\n                                      }\n\nlocal_def_list: /* nothing */            { fun _ -> () }\n              | local_def local_def_list { fun _ -> begin ignore($1 ()); $2 () end }\n\nheader: T_fun T_id T_lparen fpar_def semi_fpar_def_list T_rparen T_colon ret_type { fun _ -> let id = (id_make $2) in\n                                                                                             let params = $4 () :: $5 () in\n                                                                                             let return_type = $8 () in \n                                                                                             registerHeader id params return_type;\n                                                                                             Some id\n                                                                                  }\n      | T_fun T_id T_lparen T_rparen T_colon ret_type                             { fun _ -> let id = (id_make $2) in\n                                                                                             let params = [] in\n                                                                                             let return_type = $6 () in \n                                                                                             registerHeader id params return_type;\n                                                                                             Some id\n                                                                                  } \n\nsemi_fpar_def_list: /* nothing */                           { fun _ -> [] }\n                  | T_semicolon fpar_def semi_fpar_def_list { fun _ -> $2 () :: $3 () }\n\nfpar_def: T_ref T_id comma_id_list T_colon fpar_type { fun _ -> let params = (id_make $2) :: $3 () in\n                                                                let param_type = $5 () in\n                                                                { id = params; mode = PASS_BY_REFERENCE ; param_type = param_type }\n                                                     }\n        | T_id comma_id_list T_colon fpar_type       { fun _ -> let params = (id_make $1) :: $2 () in\n                                                                let param_type = $4 () in\n                                                                { id = params; mode = PASS_BY_VALUE ; param_type = param_type }\n                                                     }\n\ncomma_id_list: /* nothing */              { fun _ -> [] }\n             | T_comma T_id comma_id_list { fun _ -> (id_make $2) :: $3 () }\n\ndata_type: T_int  { fun _ -> TYPE_int }\n         | T_char { fun _ -> TYPE_char }\n\nbracket_int_const_list: /* nothing */                                        { fun _ -> [] }\n                      | T_lbrack T_int_const T_rbrack bracket_int_const_list { fun _ -> $2 :: $4 () }\n\nret_type: data_type { fun _ -> $1 () }\n        | T_nothing { fun _ -> TYPE_proc }\n\nfpar_type: data_type T_lbrack T_rbrack bracket_int_const_list { fun _ -> let base_type = $1 () in\n                                                                         let dimensions = max_int :: $4 () in\n                                                                         match dimensions with\n                                                                         | [] -> base_type\n                                                                         | _ -> TYPE_array (base_type, dimensions)\n                                                              } \n         | data_type bracket_int_const_list                   { fun _ -> let base_type = $1 () in\n                                                                         let dimensions = $2 () in\n                                                                         match dimensions with\n                                                                         | [] -> base_type\n                                                                         | _ -> TYPE_array (base_type, dimensions)\n                                                              }\n\ngrace_type: data_type bracket_int_const_list { fun _ -> let base_type = $1 () in\n                                                        let dimensions = $2 () in\n                                                        match dimensions with\n                                                        | [] -> base_type\n                                                        | _ -> TYPE_array (base_type, dimensions)\n                                             }\n\nlocal_def: func_def  { $1 }\n         | func_decl { $1 }\n         | var_def   { $1 }\n\nfunc_decl: header T_semicolon { $1 }\n\nvar_def: T_var T_id comma_id_list T_colon grace_type T_semicolon { fun _ -> let vars = (id_make $2) :: $3 () in\n                                                                            let var_type = $5 () in\n                                                                            print_grace_type var_type;\n                                                                            List.iter ( fun var -> ignore(newVariable var var_type true) ) vars; None\n                                                                 }\n\nstmt: T_semicolon                       { fun _ -> None }\n    | l_value T_prod expr T_semicolon   { fun _ -> let (id,l) = $1 () in\n                                                   let value = $3 () in\n                                                   assignToVariable (id_make id) value;\n                                                   None\n                                        }\n    | block                             { $1 }\n    | func_call T_semicolon             { $1 }\n    | T_if cond T_then stmt             { fun _ -> if $2 () then $4 () else None }\n    | T_if cond T_then stmt T_else stmt { fun _ -> if $2 () then $4 () else $6 () }\n    | T_while cond T_do stmt            { fun _ -> while $2 () do ignore($4 ()) done; None }\n    | T_return T_semicolon              { fun _ -> None }\n    | T_return expr T_semicolon         { fun _ -> Some($2 ()) }\n\n\nblock: T_lbrace stmt_list T_rbrace { $2 }\n\nstmt_list: /* nothing */  { fun _ -> None }\n         | stmt stmt_list { fun _ -> let result = $1 () in\n                                     match result with\n                                     | Some _ as returnValue -> returnValue\n                                     | None -> $2 ()\n      }\n\nfunc_call: T_id T_lparen T_rparen                      { fun _ -> let func_name = $1 in\n                                                                  match func_name with \n                                                                  | \"writeInteger\" -> print_string \"WriteInteger\"; None\n                                                                  | \"writeChar\"    -> print_string \"WriteChar\"; None\n                                                                  | \"writeString\"  -> print_string \"WriteString\"; None\n                                                                  | \"readInteger\"  -> print_string \"ReadInteger\"; None\n                                                                  | \"readChar\"     -> print_string \"ReadChar\"; None\n                                                                  | \"readString\"   -> print_string \"ReadString\"; None\n                                                                  | _ -> let func_entry = lookupEntry (id_make func_name) LOOKUP_ALL_SCOPES true in\n                                                                         (match func_entry.entry_info with\n                                                                         | ENTRY_function func_info ->\n                                                                           if List.length func_info.function_paramlist = 0 then\n                                                                             callFunction (id_make func_name) []\n                                                                           else (error \"Incorrect number of arguments for function %a\" pretty_id (id_make func_name); None)\n                                                                         | _ -> (error \"%a is not a function\" pretty_id (id_make func_name); None))\n                                                       }\n         | T_id T_lparen expr comma_expr_list T_rparen { fun _ -> let func_name = $1 in\n                                                                  let args = $3 () :: $4 () in\n                                                                  match func_name with \n                                                                  | \"writeInteger\" -> print_string \"WriteInteger\"; None\n                                                                  | \"writeChar\"    -> print_string \"WriteChar\"; None\n                                                                  | \"writeString\"  -> print_string \"WriteString\"; None\n                                                                  | \"readInteger\"  -> print_string \"ReadInteger\"; None\n                                                                  | \"readChar\"     -> print_string \"ReadChar\"; None\n                                                                  | \"readString\"   -> print_string \"ReadString\"; None\n                                                                  | _ -> let func_entry = lookupEntry (id_make func_name) LOOKUP_ALL_SCOPES true in\n                                                                         (match func_entry.entry_info with\n                                                                         | ENTRY_function func_info ->\n                                                                           if List.length func_info.function_paramlist = List.length args then\n                                                                           callFunction (id_make func_name) args\n                                                                         else\n                                                                           (error \"Incorrect number of arguments for function %a\" pretty_id (id_make func_name); None)\n                                                                         | _ -> (error \"%a is not a function\" pretty_id (id_make func_name); None))\n                                                       }\n\n\ncomma_expr_list: /* nothing */                { fun _ -> [] }\n               | T_comma expr comma_expr_list { fun _ -> $2 () :: $3 () }\n\nl_value: T_id                           { fun _ -> ($1,[]) }\n       | T_string_literal               { fun _ -> ($1,[]) }\n       | l_value T_lbrack expr T_rbrack { fun _ -> let (value, l) = $1 () in\n                                                   match $3 () with \n                                                   | IntValue exp -> (value, exp :: l)\n                                                   | _ -> error \"not an integer\"; (value, [])\n                                        }\n\n\nexpr: T_int_const            { fun _ -> IntValue $1 }\n    | T_char_const           { fun _ -> CharValue $1 }\n    | l_value                { fun _ -> let (value , l) = $1 () in\n                                        MultiArray (createArray l)\n                             }\n    | T_lparen expr T_rparen { $2 }\n    | func_call              { fun _ -> match $1 () with\n                                        | Some value -> value\n                                        | None -> Unit\n                             }\n    | T_plus expr            { fun _ -> match $2 () with \n                                        | IntValue num -> IntValue num\n                                        | _ -> error \"not an integer; +\"; Unit\n                             }\n    | T_minus expr           { fun _ -> match $2 () with \n                                        | IntValue num -> IntValue (- num)\n                                        | _ -> error \"not an integer; -\"; Unit\n                             }    \n    | expr T_plus expr       { fun _ -> match ($1 (), $3 ()) with\n                                        | (IntValue a, IntValue b) -> IntValue (a + b)\n                                        | _ -> error \"not an integer; plus\"; Unit\n                             }\n    | expr T_minus expr      { fun _ -> let val1 = $1 () in\n                                        let val2 = $3 () in\n                                        print_variable_value val1;\n                                        print_variable_value val2;\n                                        match (val1, val2) with\n                                        | (IntValue a, IntValue b) -> IntValue (a - b)\n                                        | (c, d) -> error \"not an integer; minus\"; Unit\n                             }\n    | expr T_times expr      { fun _ -> match ($1 (), $3 ()) with\n                                        | (IntValue a, IntValue b) -> IntValue (a * b)\n                                        | _ -> error \"not an integer; times\"; Unit\n                             }\n    | expr T_div expr        { fun _ -> match ($1 (), $3 ()) with\n                                        | (IntValue a, IntValue b) -> IntValue (a / b)\n                                        | _ -> error \"not an integer; div\"; Unit\n                             }\n    | expr T_mod expr        { fun _ -> match ($1 (), $3 ()) with\n                                        | (IntValue a, IntValue b) -> IntValue (a mod b)\n                                        | _ -> error \"not an integer; mod\"; Unit\n                             }\n \ncond: T_lparen cond T_rparen { $2 }\n    | T_not cond             { fun _ -> not ($2 ()) }\n    | cond T_and cond        { fun _ -> $1 () && $3 () }\n    | cond T_or cond         { fun _ -> $1 () || $3 () }\n    | expr T_eq expr         { fun _ -> $1 () = $3 () }\n    | expr T_hash expr       { fun _ -> $1 () <> $3 () }\n    | expr T_less expr       { fun _ -> $1 () < $3 () }\n    | expr T_more expr       { fun _ -> $1 () > $3 () }\n    | expr T_leq expr        { fun _ -> $1 () <= $3 () }\n    | expr T_geq expr        { fun _ -> $1 () >= $3 () }\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/tsimiho/Desktop/NTUA/ECE/Semester8/%CE%9C%CE%B5%CF%84%CE%B1%CE%B3%CE%BB%CF%89%CF%84%CF%84%CE%B9%CF%83%CF%84%CE%AD%CF%82/compiler/Parser.mly","version":15},"contentChanges":[{"text":"%{\n  open Symbol\n  open Types\n  open Identifier\n  open Error\n  open Narray\n\n  initSymbolTable 1000;\n\n  type param = { \n    id: Identifier.id list; \n    mode: pass_mode; \n    param_type: typ \n  }\n\n  and param_mode = PASS_BY_VALUE | PASS_BY_REFERENCE\n\n  let registerHeader id params return_type = \n    let fun_entry = newFunction id true in\n    (* openScope(); *)\n    List.iter ( fun p -> \n                  List.iter ( fun single_id -> \n                                ignore (newParameter single_id p.param_type p.mode fun_entry true) \n                            ) p.id\n              ) params;\n    match fun_entry.entry_info with\n    | ENTRY_function func_info ->\n        func_info.function_result <- return_type;\n    | _ -> error \"Expected a function entry %a\" pretty_id id;\n    endFunctionHeader fun_entry return_type\n\n  let callFunction id args =\n    let func_entry = lookupEntry id LOOKUP_ALL_SCOPES true in\n    match func_entry.entry_info with\n    | ENTRY_function inf -> if inf.function_isForward then\n                              let rec linkParams func_params func_args = \n                                match func_params, func_args with\n                                | fp::fps, fa::fas -> if fp.\n                                | [], [] -> inf.function_body () \n                                | _, _ -> error \"Function %a is called with the worng number of parameters\" pretty_id id; None\n                            else error \"%a has not been implemented\" pretty_id id; None\n    | _ -> error \"%a is not a function\" pretty_id id; None\n\n\n  let print_variable_value value =\n    match value with\n    | IntValue i -> Printf.printf \"IntValue: %d\\n\" i\n    | CharValue c -> Printf.printf \"CharValue: '%c'\\n\" c\n    | BoolValue b -> Printf.printf \"BoolValue: %b\\n\" b\n    | MultiArray arr -> Printf.printf \"MultiArray\"\n    | Unit -> Printf.printf \"Unit\\n\"\n\n  let print_grace_type t =\n    match t with\n    | TYPE_int | TYPE_char -> Printf.printf \"Not an array\\n\"\n    | _  -> Printf.printf \"array\\n\"\n        \n%}\n\n%token T_eof \n%token T_and\n%token T_char\n%token T_div\n%token T_do\n%token T_else\n%token T_fun\n%token T_if\n%token T_int \n%token T_mod\n%token T_not\n%token T_nothing\n%token T_or\n%token T_ref\n%token T_return\n%token T_then\n%token T_var\n%token T_while\n%token<string> T_id\n%token<int> T_int_const\n%token<char> T_char_const\n%token<string> T_string_literal\n%token T_eq\n%token T_lparen\n%token T_rparen\n%token T_plus\n%token T_minus\n%token T_times\n%token T_less\n%token T_more\n%token T_lbrack\n%token T_rbrack\n%token T_lbrace\n%token T_rbrace\n%token T_hash\n%token T_comma\n%token T_semicolon\n%token T_colon\n%token T_leq\n%token T_geq\n%token T_prod\n\n%left T_or\n%left T_and\n%nonassoc T_not\n%nonassoc T_eq T_hash T_less T_more T_geq T_leq\n%left T_plus T_minus\n%left T_times T_div T_mod\n\n%start program\n%type <unit -> unit> program\n%type <unit -> Identifier.id option> func_def\n%type <unit -> unit> local_def_list\n%type <unit -> Identifier.id option> header\n%type <unit -> param list> semi_fpar_def_list\n%type <unit -> param> fpar_def\n%type <unit -> Identifier.id list> comma_id_list\n%type <unit -> typ> data_type\n%type <unit -> int list> bracket_int_const_list\n%type <unit -> typ> ret_type\n%type <unit -> typ> fpar_type\n%type <unit -> typ> grace_type\n%type <unit -> Identifier.id option> local_def\n%type <unit -> Identifier.id option> func_decl\n%type <unit -> Identifier.id option> var_def\n%type <unit -> variable_value option> stmt\n%type <unit -> variable_value option> block\n%type <unit -> variable_value option> stmt_list\n%type <unit -> variable_value option> func_call\n%type <unit -> variable_value list> comma_expr_list\n%type <unit -> (string * int list)> l_value\n%type <unit -> variable_value> expr\n%type <unit -> bool> cond\n\n\n%%\n\nprogram: func_def T_eof { fun _ -> match $1 () with\n                                   | Some id -> ignore(callFunction id [])\n                                   | _ -> error \"not a function\"\n                        }\n\nfunc_def: header local_def_list block { fun _ -> begin \n                                          match $1 () with\n                                          | Some func_name -> \n                                              $2 ();\n                                              let func_body = $3 in\n                                              let func_entry = lookupEntry func_name LOOKUP_ALL_SCOPES true in\n                                              (match func_entry.entry_info with\n                                              | ENTRY_function func_info -> func_info.function_body <- func_body; Some func_name\n                                              | _ -> Some func_name)\n                                          | None -> error \"not a function\"; None\n                                        end\n                                      }\n\nlocal_def_list: /* nothing */            { fun _ -> () }\n              | local_def local_def_list { fun _ -> begin ignore($1 ()); $2 () end }\n\nheader: T_fun T_id T_lparen fpar_def semi_fpar_def_list T_rparen T_colon ret_type { fun _ -> let id = (id_make $2) in\n                                                                                             let params = $4 () :: $5 () in\n                                                                                             let return_type = $8 () in \n                                                                                             registerHeader id params return_type;\n                                                                                             Some id\n                                                                                  }\n      | T_fun T_id T_lparen T_rparen T_colon ret_type                             { fun _ -> let id = (id_make $2) in\n                                                                                             let params = [] in\n                                                                                             let return_type = $6 () in \n                                                                                             registerHeader id params return_type;\n                                                                                             Some id\n                                                                                  } \n\nsemi_fpar_def_list: /* nothing */                           { fun _ -> [] }\n                  | T_semicolon fpar_def semi_fpar_def_list { fun _ -> $2 () :: $3 () }\n\nfpar_def: T_ref T_id comma_id_list T_colon fpar_type { fun _ -> let params = (id_make $2) :: $3 () in\n                                                                let param_type = $5 () in\n                                                                { id = params; mode = PASS_BY_REFERENCE ; param_type = param_type }\n                                                     }\n        | T_id comma_id_list T_colon fpar_type       { fun _ -> let params = (id_make $1) :: $2 () in\n                                                                let param_type = $4 () in\n                                                                { id = params; mode = PASS_BY_VALUE ; param_type = param_type }\n                                                     }\n\ncomma_id_list: /* nothing */              { fun _ -> [] }\n             | T_comma T_id comma_id_list { fun _ -> (id_make $2) :: $3 () }\n\ndata_type: T_int  { fun _ -> TYPE_int }\n         | T_char { fun _ -> TYPE_char }\n\nbracket_int_const_list: /* nothing */                                        { fun _ -> [] }\n                      | T_lbrack T_int_const T_rbrack bracket_int_const_list { fun _ -> $2 :: $4 () }\n\nret_type: data_type { fun _ -> $1 () }\n        | T_nothing { fun _ -> TYPE_proc }\n\nfpar_type: data_type T_lbrack T_rbrack bracket_int_const_list { fun _ -> let base_type = $1 () in\n                                                                         let dimensions = max_int :: $4 () in\n                                                                         match dimensions with\n                                                                         | [] -> base_type\n                                                                         | _ -> TYPE_array (base_type, dimensions)\n                                                              } \n         | data_type bracket_int_const_list                   { fun _ -> let base_type = $1 () in\n                                                                         let dimensions = $2 () in\n                                                                         match dimensions with\n                                                                         | [] -> base_type\n                                                                         | _ -> TYPE_array (base_type, dimensions)\n                                                              }\n\ngrace_type: data_type bracket_int_const_list { fun _ -> let base_type = $1 () in\n                                                        let dimensions = $2 () in\n                                                        match dimensions with\n                                                        | [] -> base_type\n                                                        | _ -> TYPE_array (base_type, dimensions)\n                                             }\n\nlocal_def: func_def  { $1 }\n         | func_decl { $1 }\n         | var_def   { $1 }\n\nfunc_decl: header T_semicolon { $1 }\n\nvar_def: T_var T_id comma_id_list T_colon grace_type T_semicolon { fun _ -> let vars = (id_make $2) :: $3 () in\n                                                                            let var_type = $5 () in\n                                                                            print_grace_type var_type;\n                                                                            List.iter ( fun var -> ignore(newVariable var var_type true) ) vars; None\n                                                                 }\n\nstmt: T_semicolon                       { fun _ -> None }\n    | l_value T_prod expr T_semicolon   { fun _ -> let (id,l) = $1 () in\n                                                   let value = $3 () in\n                                                   assignToVariable (id_make id) value;\n                                                   None\n                                        }\n    | block                             { $1 }\n    | func_call T_semicolon             { $1 }\n    | T_if cond T_then stmt             { fun _ -> if $2 () then $4 () else None }\n    | T_if cond T_then stmt T_else stmt { fun _ -> if $2 () then $4 () else $6 () }\n    | T_while cond T_do stmt            { fun _ -> while $2 () do ignore($4 ()) done; None }\n    | T_return T_semicolon              { fun _ -> None }\n    | T_return expr T_semicolon         { fun _ -> Some($2 ()) }\n\n\nblock: T_lbrace stmt_list T_rbrace { $2 }\n\nstmt_list: /* nothing */  { fun _ -> None }\n         | stmt stmt_list { fun _ -> let result = $1 () in\n                                     match result with\n                                     | Some _ as returnValue -> returnValue\n                                     | None -> $2 ()\n      }\n\nfunc_call: T_id T_lparen T_rparen                      { fun _ -> let func_name = $1 in\n                                                                  match func_name with \n                                                                  | \"writeInteger\" -> print_string \"WriteInteger\"; None\n                                                                  | \"writeChar\"    -> print_string \"WriteChar\"; None\n                                                                  | \"writeString\"  -> print_string \"WriteString\"; None\n                                                                  | \"readInteger\"  -> print_string \"ReadInteger\"; None\n                                                                  | \"readChar\"     -> print_string \"ReadChar\"; None\n                                                                  | \"readString\"   -> print_string \"ReadString\"; None\n                                                                  | _ -> let func_entry = lookupEntry (id_make func_name) LOOKUP_ALL_SCOPES true in\n                                                                         (match func_entry.entry_info with\n                                                                         | ENTRY_function func_info ->\n                                                                           if List.length func_info.function_paramlist = 0 then\n                                                                             callFunction (id_make func_name) []\n                                                                           else (error \"Incorrect number of arguments for function %a\" pretty_id (id_make func_name); None)\n                                                                         | _ -> (error \"%a is not a function\" pretty_id (id_make func_name); None))\n                                                       }\n         | T_id T_lparen expr comma_expr_list T_rparen { fun _ -> let func_name = $1 in\n                                                                  let args = $3 () :: $4 () in\n                                                                  match func_name with \n                                                                  | \"writeInteger\" -> print_string \"WriteInteger\"; None\n                                                                  | \"writeChar\"    -> print_string \"WriteChar\"; None\n                                                                  | \"writeString\"  -> print_string \"WriteString\"; None\n                                                                  | \"readInteger\"  -> print_string \"ReadInteger\"; None\n                                                                  | \"readChar\"     -> print_string \"ReadChar\"; None\n                                                                  | \"readString\"   -> print_string \"ReadString\"; None\n                                                                  | _ -> let func_entry = lookupEntry (id_make func_name) LOOKUP_ALL_SCOPES true in\n                                                                         (match func_entry.entry_info with\n                                                                         | ENTRY_function func_info ->\n                                                                           if List.length func_info.function_paramlist = List.length args then\n                                                                           callFunction (id_make func_name) args\n                                                                         else\n                                                                           (error \"Incorrect number of arguments for function %a\" pretty_id (id_make func_name); None)\n                                                                         | _ -> (error \"%a is not a function\" pretty_id (id_make func_name); None))\n                                                       }\n\n\ncomma_expr_list: /* nothing */                { fun _ -> [] }\n               | T_comma expr comma_expr_list { fun _ -> $2 () :: $3 () }\n\nl_value: T_id                           { fun _ -> ($1,[]) }\n       | T_string_literal               { fun _ -> ($1,[]) }\n       | l_value T_lbrack expr T_rbrack { fun _ -> let (value, l) = $1 () in\n                                                   match $3 () with \n                                                   | IntValue exp -> (value, exp :: l)\n                                                   | _ -> error \"not an integer\"; (value, [])\n                                        }\n\n\nexpr: T_int_const            { fun _ -> IntValue $1 }\n    | T_char_const           { fun _ -> CharValue $1 }\n    | l_value                { fun _ -> let (value , l) = $1 () in\n                                        MultiArray (createArray l)\n                             }\n    | T_lparen expr T_rparen { $2 }\n    | func_call              { fun _ -> match $1 () with\n                                        | Some value -> value\n                                        | None -> Unit\n                             }\n    | T_plus expr            { fun _ -> match $2 () with \n                                        | IntValue num -> IntValue num\n                                        | _ -> error \"not an integer; +\"; Unit\n                             }\n    | T_minus expr           { fun _ -> match $2 () with \n                                        | IntValue num -> IntValue (- num)\n                                        | _ -> error \"not an integer; -\"; Unit\n                             }    \n    | expr T_plus expr       { fun _ -> match ($1 (), $3 ()) with\n                                        | (IntValue a, IntValue b) -> IntValue (a + b)\n                                        | _ -> error \"not an integer; plus\"; Unit\n                             }\n    | expr T_minus expr      { fun _ -> let val1 = $1 () in\n                                        let val2 = $3 () in\n                                        print_variable_value val1;\n                                        print_variable_value val2;\n                                        match (val1, val2) with\n                                        | (IntValue a, IntValue b) -> IntValue (a - b)\n                                        | (c, d) -> error \"not an integer; minus\"; Unit\n                             }\n    | expr T_times expr      { fun _ -> match ($1 (), $3 ()) with\n                                        | (IntValue a, IntValue b) -> IntValue (a * b)\n                                        | _ -> error \"not an integer; times\"; Unit\n                             }\n    | expr T_div expr        { fun _ -> match ($1 (), $3 ()) with\n                                        | (IntValue a, IntValue b) -> IntValue (a / b)\n                                        | _ -> error \"not an integer; div\"; Unit\n                             }\n    | expr T_mod expr        { fun _ -> match ($1 (), $3 ()) with\n                                        | (IntValue a, IntValue b) -> IntValue (a mod b)\n                                        | _ -> error \"not an integer; mod\"; Unit\n                             }\n \ncond: T_lparen cond T_rparen { $2 }\n    | T_not cond             { fun _ -> not ($2 ()) }\n    | cond T_and cond        { fun _ -> $1 () && $3 () }\n    | cond T_or cond         { fun _ -> $1 () || $3 () }\n    | expr T_eq expr         { fun _ -> $1 () = $3 () }\n    | expr T_hash expr       { fun _ -> $1 () <> $3 () }\n    | expr T_less expr       { fun _ -> $1 () < $3 () }\n    | expr T_more expr       { fun _ -> $1 () > $3 () }\n    | expr T_leq expr        { fun _ -> $1 () <= $3 () }\n    | expr T_geq expr        { fun _ -> $1 () >= $3 () }\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/tsimiho/Desktop/NTUA/ECE/Semester8/%CE%9C%CE%B5%CF%84%CE%B1%CE%B3%CE%BB%CF%89%CF%84%CF%84%CE%B9%CF%83%CF%84%CE%AD%CF%82/compiler/Parser.mly","version":16},"contentChanges":[{"text":"%{\n  open Symbol\n  open Types\n  open Identifier\n  open Error\n  open Narray\n\n  initSymbolTable 1000;\n\n  type param = { \n    id: Identifier.id list; \n    mode: pass_mode; \n    param_type: typ \n  }\n\n  and param_mode = PASS_BY_VALUE | PASS_BY_REFERENCE\n\n  let registerHeader id params return_type = \n    let fun_entry = newFunction id true in\n    (* openScope(); *)\n    List.iter ( fun p -> \n                  List.iter ( fun single_id -> \n                                ignore (newParameter single_id p.param_type p.mode fun_entry true) \n                            ) p.id\n              ) params;\n    match fun_entry.entry_info with\n    | ENTRY_function func_info ->\n        func_info.function_result <- return_type;\n    | _ -> error \"Expected a function entry %a\" pretty_id id;\n    endFunctionHeader fun_entry return_type\n\n  let callFunction id args =\n    let func_entry = lookupEntry id LOOKUP_ALL_SCOPES true in\n    match func_entry.entry_info with\n    | ENTRY_function inf -> if inf.function_isForward then\n                              let rec linkParams func_params func_args = \n                                match func_params, func_args with\n                                | fp::fps, fa::fas -> if fp.\n                                | [], [] -> inf.function_body () \n                                | _, _ -> error \"Function %a is called with the worng number of parameters\" pretty_id id; None\n                            else error \"%a has not been implemented\" pretty_id id; None\n    | _ -> error \"%a is not a function\" pretty_id id; None\n\n\n  let print_variable_value value =\n    match value with\n    | IntValue i -> Printf.printf \"IntValue: %d\\n\" i\n    | CharValue c -> Printf.printf \"CharValue: '%c'\\n\" c\n    | BoolValue b -> Printf.printf \"BoolValue: %b\\n\" b\n    | MultiArray arr -> Printf.printf \"MultiArray\"\n    | Unit -> Printf.printf \"Unit\\n\"\n\n  let print_grace_type t =\n    match t with\n    | TYPE_int | TYPE_char -> Printf.printf \"Not an array\\n\"\n    | _  -> Printf.printf \"array\\n\"\n        \n%}\n\n%token T_eof \n%token T_and\n%token T_char\n%token T_div\n%token T_do\n%token T_else\n%token T_fun\n%token T_if\n%token T_int \n%token T_mod\n%token T_not\n%token T_nothing\n%token T_or\n%token T_ref\n%token T_return\n%token T_then\n%token T_var\n%token T_while\n%token<string> T_id\n%token<int> T_int_const\n%token<char> T_char_const\n%token<string> T_string_literal\n%token T_eq\n%token T_lparen\n%token T_rparen\n%token T_plus\n%token T_minus\n%token T_times\n%token T_less\n%token T_more\n%token T_lbrack\n%token T_rbrack\n%token T_lbrace\n%token T_rbrace\n%token T_hash\n%token T_comma\n%token T_semicolon\n%token T_colon\n%token T_leq\n%token T_geq\n%token T_prod\n\n%left T_or\n%left T_and\n%nonassoc T_not\n%nonassoc T_eq T_hash T_less T_more T_geq T_leq\n%left T_plus T_minus\n%left T_times T_div T_mod\n\n%start program\n%type <unit -> unit> program\n%type <unit -> Identifier.id option> func_def\n%type <unit -> unit> local_def_list\n%type <unit -> Identifier.id option> header\n%type <unit -> param list> semi_fpar_def_list\n%type <unit -> param> fpar_def\n%type <unit -> Identifier.id list> comma_id_list\n%type <unit -> typ> data_type\n%type <unit -> int list> bracket_int_const_list\n%type <unit -> typ> ret_type\n%type <unit -> typ> fpar_type\n%type <unit -> typ> grace_type\n%type <unit -> Identifier.id option> local_def\n%type <unit -> Identifier.id option> func_decl\n%type <unit -> Identifier.id option> var_def\n%type <unit -> variable_value option> stmt\n%type <unit -> variable_value option> block\n%type <unit -> variable_value option> stmt_list\n%type <unit -> variable_value option> func_call\n%type <unit -> variable_value list> comma_expr_list\n%type <unit -> (string * int list)> l_value\n%type <unit -> variable_value> expr\n%type <unit -> bool> cond\n\n\n%%\n\nprogram: func_def T_eof { fun _ -> match $1 () with\n                                   | Some id -> ignore(callFunction id [])\n                                   | _ -> error \"not a function\"\n                        }\n\nfunc_def: header local_def_list block { fun _ -> begin \n                                          match $1 () with\n                                          | Some func_name -> \n                                              $2 ();\n                                              let func_body = $3 in\n                                              let func_entry = lookupEntry func_name LOOKUP_ALL_SCOPES true in\n                                              (match func_entry.entry_info with\n                                              | ENTRY_function func_info -> func_info.function_body <- func_body; Some func_name\n                                              | _ -> Some func_name)\n                                          | None -> error \"not a function\"; None\n                                        end\n                                      }\n\nlocal_def_list: /* nothing */            { fun _ -> () }\n              | local_def local_def_list { fun _ -> begin ignore($1 ()); $2 () end }\n\nheader: T_fun T_id T_lparen fpar_def semi_fpar_def_list T_rparen T_colon ret_type { fun _ -> let id = (id_make $2) in\n                                                                                             let params = $4 () :: $5 () in\n                                                                                             let return_type = $8 () in \n                                                                                             registerHeader id params return_type;\n                                                                                             Some id\n                                                                                  }\n      | T_fun T_id T_lparen T_rparen T_colon ret_type                             { fun _ -> let id = (id_make $2) in\n                                                                                             let params = [] in\n                                                                                             let return_type = $6 () in \n                                                                                             registerHeader id params return_type;\n                                                                                             Some id\n                                                                                  } \n\nsemi_fpar_def_list: /* nothing */                           { fun _ -> [] }\n                  | T_semicolon fpar_def semi_fpar_def_list { fun _ -> $2 () :: $3 () }\n\nfpar_def: T_ref T_id comma_id_list T_colon fpar_type { fun _ -> let params = (id_make $2) :: $3 () in\n                                                                let param_type = $5 () in\n                                                                { id = params; mode = PASS_BY_REFERENCE ; param_type = param_type }\n                                                     }\n        | T_id comma_id_list T_colon fpar_type       { fun _ -> let params = (id_make $1) :: $2 () in\n                                                                let param_type = $4 () in\n                                                                { id = params; mode = PASS_BY_VALUE ; param_type = param_type }\n                                                     }\n\ncomma_id_list: /* nothing */              { fun _ -> [] }\n             | T_comma T_id comma_id_list { fun _ -> (id_make $2) :: $3 () }\n\ndata_type: T_int  { fun _ -> TYPE_int }\n         | T_char { fun _ -> TYPE_char }\n\nbracket_int_const_list: /* nothing */                                        { fun _ -> [] }\n                      | T_lbrack T_int_const T_rbrack bracket_int_const_list { fun _ -> $2 :: $4 () }\n\nret_type: data_type { fun _ -> $1 () }\n        | T_nothing { fun _ -> TYPE_proc }\n\nfpar_type: data_type T_lbrack T_rbrack bracket_int_const_list { fun _ -> let base_type = $1 () in\n                                                                         let dimensions = max_int :: $4 () in\n                                                                         match dimensions with\n                                                                         | [] -> base_type\n                                                                         | _ -> TYPE_array (base_type, dimensions)\n                                                              } \n         | data_type bracket_int_const_list                   { fun _ -> let base_type = $1 () in\n                                                                         let dimensions = $2 () in\n                                                                         match dimensions with\n                                                                         | [] -> base_type\n                                                                         | _ -> TYPE_array (base_type, dimensions)\n                                                              }\n\ngrace_type: data_type bracket_int_const_list { fun _ -> let base_type = $1 () in\n                                                        let dimensions = $2 () in\n                                                        match dimensions with\n                                                        | [] -> base_type\n                                                        | _ -> TYPE_array (base_type, dimensions)\n                                             }\n\nlocal_def: func_def  { $1 }\n         | func_decl { $1 }\n         | var_def   { $1 }\n\nfunc_decl: header T_semicolon { $1 }\n\nvar_def: T_var T_id comma_id_list T_colon grace_type T_semicolon { fun _ -> let vars = (id_make $2) :: $3 () in\n                                                                            let var_type = $5 () in\n                                                                            print_grace_type var_type;\n                                                                            List.iter ( fun var -> ignore(newVariable var var_type true) ) vars; None\n                                                                 }\n\nstmt: T_semicolon                       { fun _ -> None }\n    | l_value T_prod expr T_semicolon   { fun _ -> let (id,l) = $1 () in\n                                                   let value = $3 () in\n                                                   assignToVariable (id_make id) value;\n                                                   None\n                                        }\n    | block                             { $1 }\n    | func_call T_semicolon             { $1 }\n    | T_if cond T_then stmt             { fun _ -> if $2 () then $4 () else None }\n    | T_if cond T_then stmt T_else stmt { fun _ -> if $2 () then $4 () else $6 () }\n    | T_while cond T_do stmt            { fun _ -> while $2 () do ignore($4 ()) done; None }\n    | T_return T_semicolon              { fun _ -> None }\n    | T_return expr T_semicolon         { fun _ -> Some($2 ()) }\n\n\nblock: T_lbrace stmt_list T_rbrace { $2 }\n\nstmt_list: /* nothing */  { fun _ -> None }\n         | stmt stmt_list { fun _ -> let result = $1 () in\n                                     match result with\n                                     | Some _ as returnValue -> returnValue\n                                     | None -> $2 ()\n      }\n\nfunc_call: T_id T_lparen T_rparen                      { fun _ -> let func_name = $1 in\n                                                                  match func_name with \n                                                                  | \"writeInteger\" -> print_string \"WriteInteger\"; None\n                                                                  | \"writeChar\"    -> print_string \"WriteChar\"; None\n                                                                  | \"writeString\"  -> print_string \"WriteString\"; None\n                                                                  | \"readInteger\"  -> print_string \"ReadInteger\"; None\n                                                                  | \"readChar\"     -> print_string \"ReadChar\"; None\n                                                                  | \"readString\"   -> print_string \"ReadString\"; None\n                                                                  | _ -> let func_entry = lookupEntry (id_make func_name) LOOKUP_ALL_SCOPES true in\n                                                                         (match func_entry.entry_info with\n                                                                         | ENTRY_function func_info ->\n                                                                           if List.length func_info.function_paramlist = 0 then\n                                                                             callFunction (id_make func_name) []\n                                                                           else (error \"Incorrect number of arguments for function %a\" pretty_id (id_make func_name); None)\n                                                                         | _ -> (error \"%a is not a function\" pretty_id (id_make func_name); None))\n                                                       }\n         | T_id T_lparen expr comma_expr_list T_rparen { fun _ -> let func_name = $1 in\n                                                                  let args = $3 () :: $4 () in\n                                                                  match func_name with \n                                                                  | \"writeInteger\" -> print_string \"WriteInteger\"; None\n                                                                  | \"writeChar\"    -> print_string \"WriteChar\"; None\n                                                                  | \"writeString\"  -> print_string \"WriteString\"; None\n                                                                  | \"readInteger\"  -> print_string \"ReadInteger\"; None\n                                                                  | \"readChar\"     -> print_string \"ReadChar\"; None\n                                                                  | \"readString\"   -> print_string \"ReadString\"; None\n                                                                  | _ -> let func_entry = lookupEntry (id_make func_name) LOOKUP_ALL_SCOPES true in\n                                                                         (match func_entry.entry_info with\n                                                                         | ENTRY_function func_info ->\n                                                                           if List.length func_info.function_paramlist = List.length args then\n                                                                           callFunction (id_make func_name) args\n                                                                         else\n                                                                           (error \"Incorrect number of arguments for function %a\" pretty_id (id_make func_name); None)\n                                                                         | _ -> (error \"%a is not a function\" pretty_id (id_make func_name); None))\n                                                       }\n\n\ncomma_expr_list: /* nothing */                { fun _ -> [] }\n               | T_comma expr comma_expr_list { fun _ -> $2 () :: $3 () }\n\nl_value: T_id                           { fun _ -> ($1,[]) }\n       | T_string_literal               { fun _ -> ($1,[]) }\n       | l_value T_lbrack expr T_rbrack { fun _ -> let (value, l) = $1 () in\n                                                   match $3 () with \n                                                   | IntValue exp -> (value, exp :: l)\n                                                   | _ -> error \"not an integer\"; (value, [])\n                                        }\n\n\nexpr: T_int_const            { fun _ -> IntValue $1 }\n    | T_char_const           { fun _ -> CharValue $1 }\n    | l_value                { fun _ -> let (value , l) = $1 () in\n                                        MultiArray (createArray l)\n                             }\n    | T_lparen expr T_rparen { $2 }\n    | func_call              { fun _ -> match $1 () with\n                                        | Some value -> value\n                                        | None -> Unit\n                             }\n    | T_plus expr            { fun _ -> match $2 () with \n                                        | IntValue num -> IntValue num\n                                        | _ -> error \"not an integer; +\"; Unit\n                             }\n    | T_minus expr           { fun _ -> match $2 () with \n                                        | IntValue num -> IntValue (- num)\n                                        | _ -> error \"not an integer; -\"; Unit\n                             }    \n    | expr T_plus expr       { fun _ -> match ($1 (), $3 ()) with\n                                        | (IntValue a, IntValue b) -> IntValue (a + b)\n                                        | _ -> error \"not an integer; plus\"; Unit\n                             }\n    | expr T_minus expr      { fun _ -> let val1 = $1 () in\n                                        let val2 = $3 () in\n                                        print_variable_value val1;\n                                        print_variable_value val2;\n                                        match (val1, val2) with\n                                        | (IntValue a, IntValue b) -> IntValue (a - b)\n                                        | (c, d) -> error \"not an integer; minus\"; Unit\n                             }\n    | expr T_times expr      { fun _ -> match ($1 (), $3 ()) with\n                                        | (IntValue a, IntValue b) -> IntValue (a * b)\n                                        | _ -> error \"not an integer; times\"; Unit\n                             }\n    | expr T_div expr        { fun _ -> match ($1 (), $3 ()) with\n                                        | (IntValue a, IntValue b) -> IntValue (a / b)\n                                        | _ -> error \"not an integer; div\"; Unit\n                             }\n    | expr T_mod expr        { fun _ -> match ($1 (), $3 ()) with\n                                        | (IntValue a, IntValue b) -> IntValue (a mod b)\n                                        | _ -> error \"not an integer; mod\"; Unit\n                             }\n \ncond: T_lparen cond T_rparen { $2 }\n    | T_not cond             { fun _ -> not ($2 ()) }\n    | cond T_and cond        { fun _ -> $1 () && $3 () }\n    | cond T_or cond         { fun _ -> $1 () || $3 () }\n    | expr T_eq expr         { fun _ -> $1 () = $3 () }\n    | expr T_hash expr       { fun _ -> $1 () <> $3 () }\n    | expr T_less expr       { fun _ -> $1 () < $3 () }\n    | expr T_more expr       { fun _ -> $1 () > $3 () }\n    | expr T_leq expr        { fun _ -> $1 () <= $3 () }\n    | expr T_geq expr        { fun _ -> $1 () >= $3 () }\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/tsimiho/Desktop/NTUA/ECE/Semester8/%CE%9C%CE%B5%CF%84%CE%B1%CE%B3%CE%BB%CF%89%CF%84%CF%84%CE%B9%CF%83%CF%84%CE%AD%CF%82/compiler/Parser.mly","version":17},"contentChanges":[{"text":"%{\n  open Symbol\n  open Types\n  open Identifier\n  open Error\n  open Narray\n\n  initSymbolTable 1000;\n\n  type param = { \n    id: Identifier.id list; \n    mode: pass_mode; \n    param_type: typ \n  }\n\n  and param_mode = PASS_BY_VALUE | PASS_BY_REFERENCE\n\n  let registerHeader id params return_type = \n    let fun_entry = newFunction id true in\n    (* openScope(); *)\n    List.iter ( fun p -> \n                  List.iter ( fun single_id -> \n                                ignore (newParameter single_id p.param_type p.mode fun_entry true) \n                            ) p.id\n              ) params;\n    match fun_entry.entry_info with\n    | ENTRY_function func_info ->\n        func_info.function_result <- return_type;\n    | _ -> error \"Expected a function entry %a\" pretty_id id;\n    endFunctionHeader fun_entry return_type\n\n  let callFunction id args =\n    let func_entry = lookupEntry id LOOKUP_ALL_SCOPES true in\n    match func_entry.entry_info with\n    | ENTRY_function inf -> if inf.function_isForward then\n                              let rec linkParams func_params func_args = \n                                match func_params, func_args with\n                                | fp::fps, fa::fas -> if fp.\n                                | [], [] -> inf.function_body () \n                                | _, _ -> error \"Function %a is called with the worng number of parameters\" pretty_id id; None\n                            else error \"%a has not been implemented\" pretty_id id; None\n    | _ -> error \"%a is not a function\" pretty_id id; None\n\n\n  let print_variable_value value =\n    match value with\n    | IntValue i -> Printf.printf \"IntValue: %d\\n\" i\n    | CharValue c -> Printf.printf \"CharValue: '%c'\\n\" c\n    | BoolValue b -> Printf.printf \"BoolValue: %b\\n\" b\n    | MultiArray arr -> Printf.printf \"MultiArray\"\n    | Unit -> Printf.printf \"Unit\\n\"\n\n  let print_grace_type t =\n    match t with\n    | TYPE_int | TYPE_char -> Printf.printf \"Not an array\\n\"\n    | _  -> Printf.printf \"array\\n\"\n        \n%}\n\n%token T_eof \n%token T_and\n%token T_char\n%token T_div\n%token T_do\n%token T_else\n%token T_fun\n%token T_if\n%token T_int \n%token T_mod\n%token T_not\n%token T_nothing\n%token T_or\n%token T_ref\n%token T_return\n%token T_then\n%token T_var\n%token T_while\n%token<string> T_id\n%token<int> T_int_const\n%token<char> T_char_const\n%token<string> T_string_literal\n%token T_eq\n%token T_lparen\n%token T_rparen\n%token T_plus\n%token T_minus\n%token T_times\n%token T_less\n%token T_more\n%token T_lbrack\n%token T_rbrack\n%token T_lbrace\n%token T_rbrace\n%token T_hash\n%token T_comma\n%token T_semicolon\n%token T_colon\n%token T_leq\n%token T_geq\n%token T_prod\n\n%left T_or\n%left T_and\n%nonassoc T_not\n%nonassoc T_eq T_hash T_less T_more T_geq T_leq\n%left T_plus T_minus\n%left T_times T_div T_mod\n\n%start program\n%type <unit -> unit> program\n%type <unit -> Identifier.id option> func_def\n%type <unit -> unit> local_def_list\n%type <unit -> Identifier.id option> header\n%type <unit -> param list> semi_fpar_def_list\n%type <unit -> param> fpar_def\n%type <unit -> Identifier.id list> comma_id_list\n%type <unit -> typ> data_type\n%type <unit -> int list> bracket_int_const_list\n%type <unit -> typ> ret_type\n%type <unit -> typ> fpar_type\n%type <unit -> typ> grace_type\n%type <unit -> Identifier.id option> local_def\n%type <unit -> Identifier.id option> func_decl\n%type <unit -> Identifier.id option> var_def\n%type <unit -> variable_value option> stmt\n%type <unit -> variable_value option> block\n%type <unit -> variable_value option> stmt_list\n%type <unit -> variable_value option> func_call\n%type <unit -> variable_value list> comma_expr_list\n%type <unit -> (string * int list)> l_value\n%type <unit -> variable_value> expr\n%type <unit -> bool> cond\n\n\n%%\n\nprogram: func_def T_eof { fun _ -> match $1 () with\n                                   | Some id -> ignore(callFunction id [])\n                                   | _ -> error \"not a function\"\n                        }\n\nfunc_def: header local_def_list block { fun _ -> begin \n                                          match $1 () with\n                                          | Some func_name -> \n                                              $2 ();\n                                              let func_body = $3 in\n                                              let func_entry = lookupEntry func_name LOOKUP_ALL_SCOPES true in\n                                              (match func_entry.entry_info with\n                                              | ENTRY_function func_info -> func_info.function_body <- func_body; Some func_name\n                                              | _ -> Some func_name)\n                                          | None -> error \"not a function\"; None\n                                        end\n                                      }\n\nlocal_def_list: /* nothing */            { fun _ -> () }\n              | local_def local_def_list { fun _ -> begin ignore($1 ()); $2 () end }\n\nheader: T_fun T_id T_lparen fpar_def semi_fpar_def_list T_rparen T_colon ret_type { fun _ -> let id = (id_make $2) in\n                                                                                             let params = $4 () :: $5 () in\n                                                                                             let return_type = $8 () in \n                                                                                             registerHeader id params return_type;\n                                                                                             Some id\n                                                                                  }\n      | T_fun T_id T_lparen T_rparen T_colon ret_type                             { fun _ -> let id = (id_make $2) in\n                                                                                             let params = [] in\n                                                                                             let return_type = $6 () in \n                                                                                             registerHeader id params return_type;\n                                                                                             Some id\n                                                                                  } \n\nsemi_fpar_def_list: /* nothing */                           { fun _ -> [] }\n                  | T_semicolon fpar_def semi_fpar_def_list { fun _ -> $2 () :: $3 () }\n\nfpar_def: T_ref T_id comma_id_list T_colon fpar_type { fun _ -> let params = (id_make $2) :: $3 () in\n                                                                let param_type = $5 () in\n                                                                { id = params; mode = PASS_BY_REFERENCE ; param_type = param_type }\n                                                     }\n        | T_id comma_id_list T_colon fpar_type       { fun _ -> let params = (id_make $1) :: $2 () in\n                                                                let param_type = $4 () in\n                                                                { id = params; mode = PASS_BY_VALUE ; param_type = param_type }\n                                                     }\n\ncomma_id_list: /* nothing */              { fun _ -> [] }\n             | T_comma T_id comma_id_list { fun _ -> (id_make $2) :: $3 () }\n\ndata_type: T_int  { fun _ -> TYPE_int }\n         | T_char { fun _ -> TYPE_char }\n\nbracket_int_const_list: /* nothing */                                        { fun _ -> [] }\n                      | T_lbrack T_int_const T_rbrack bracket_int_const_list { fun _ -> $2 :: $4 () }\n\nret_type: data_type { fun _ -> $1 () }\n        | T_nothing { fun _ -> TYPE_proc }\n\nfpar_type: data_type T_lbrack T_rbrack bracket_int_const_list { fun _ -> let base_type = $1 () in\n                                                                         let dimensions = max_int :: $4 () in\n                                                                         match dimensions with\n                                                                         | [] -> base_type\n                                                                         | _ -> TYPE_array (base_type, dimensions)\n                                                              } \n         | data_type bracket_int_const_list                   { fun _ -> let base_type = $1 () in\n                                                                         let dimensions = $2 () in\n                                                                         match dimensions with\n                                                                         | [] -> base_type\n                                                                         | _ -> TYPE_array (base_type, dimensions)\n                                                              }\n\ngrace_type: data_type bracket_int_const_list { fun _ -> let base_type = $1 () in\n                                                        let dimensions = $2 () in\n                                                        match dimensions with\n                                                        | [] -> base_type\n                                                        | _ -> TYPE_array (base_type, dimensions)\n                                             }\n\nlocal_def: func_def  { $1 }\n         | func_decl { $1 }\n         | var_def   { $1 }\n\nfunc_decl: header T_semicolon { $1 }\n\nvar_def: T_var T_id comma_id_list T_colon grace_type T_semicolon { fun _ -> let vars = (id_make $2) :: $3 () in\n                                                                            let var_type = $5 () in\n                                                                            print_grace_type var_type;\n                                                                            List.iter ( fun var -> ignore(newVariable var var_type true) ) vars; None\n                                                                 }\n\nstmt: T_semicolon                       { fun _ -> None }\n    | l_value T_prod expr T_semicolon   { fun _ -> let (id,l) = $1 () in\n                                                   let value = $3 () in\n                                                   assignToVariable (id_make id) value;\n                                                   None\n                                        }\n    | block                             { $1 }\n    | func_call T_semicolon             { $1 }\n    | T_if cond T_then stmt             { fun _ -> if $2 () then $4 () else None }\n    | T_if cond T_then stmt T_else stmt { fun _ -> if $2 () then $4 () else $6 () }\n    | T_while cond T_do stmt            { fun _ -> while $2 () do ignore($4 ()) done; None }\n    | T_return T_semicolon              { fun _ -> None }\n    | T_return expr T_semicolon         { fun _ -> Some($2 ()) }\n\n\nblock: T_lbrace stmt_list T_rbrace { $2 }\n\nstmt_list: /* nothing */  { fun _ -> None }\n         | stmt stmt_list { fun _ -> let result = $1 () in\n                                     match result with\n                                     | Some _ as returnValue -> returnValue\n                                     | None -> $2 ()\n      }\n\nfunc_call: T_id T_lparen T_rparen                      { fun _ -> let func_name = $1 in\n                                                                  match func_name with \n                                                                  | \"writeInteger\" -> print_string \"WriteInteger\"; None\n                                                                  | \"writeChar\"    -> print_string \"WriteChar\"; None\n                                                                  | \"writeString\"  -> print_string \"WriteString\"; None\n                                                                  | \"readInteger\"  -> print_string \"ReadInteger\"; None\n                                                                  | \"readChar\"     -> print_string \"ReadChar\"; None\n                                                                  | \"readString\"   -> print_string \"ReadString\"; None\n                                                                  | _ -> let func_entry = lookupEntry (id_make func_name) LOOKUP_ALL_SCOPES true in\n                                                                         (match func_entry.entry_info with\n                                                                         | ENTRY_function func_info ->\n                                                                           if List.length func_info.function_paramlist = 0 then\n                                                                             callFunction (id_make func_name) []\n                                                                           else (error \"Incorrect number of arguments for function %a\" pretty_id (id_make func_name); None)\n                                                                         | _ -> (error \"%a is not a function\" pretty_id (id_make func_name); None))\n                                                       }\n         | T_id T_lparen expr comma_expr_list T_rparen { fun _ -> let func_name = $1 in\n                                                                  let args = $3 () :: $4 () in\n                                                                  match func_name with \n                                                                  | \"writeInteger\" -> print_string \"WriteInteger\"; None\n                                                                  | \"writeChar\"    -> print_string \"WriteChar\"; None\n                                                                  | \"writeString\"  -> print_string \"WriteString\"; None\n                                                                  | \"readInteger\"  -> print_string \"ReadInteger\"; None\n                                                                  | \"readChar\"     -> print_string \"ReadChar\"; None\n                                                                  | \"readString\"   -> print_string \"ReadString\"; None\n                                                                  | _ -> let func_entry = lookupEntry (id_make func_name) LOOKUP_ALL_SCOPES true in\n                                                                         (match func_entry.entry_info with\n                                                                         | ENTRY_function func_info ->\n                                                                           if List.length func_info.function_paramlist = List.length args then\n                                                                           callFunction (id_make func_name) args\n                                                                         else\n                                                                           (error \"Incorrect number of arguments for function %a\" pretty_id (id_make func_name); None)\n                                                                         | _ -> (error \"%a is not a function\" pretty_id (id_make func_name); None))\n                                                       }\n\n\ncomma_expr_list: /* nothing */                { fun _ -> [] }\n               | T_comma expr comma_expr_list { fun _ -> $2 () :: $3 () }\n\nl_value: T_id                           { fun _ -> ($1,[]) }\n       | T_string_literal               { fun _ -> ($1,[]) }\n       | l_value T_lbrack expr T_rbrack { fun _ -> let (value, l) = $1 () in\n                                                   match $3 () with \n                                                   | IntValue exp -> (value, exp :: l)\n                                                   | _ -> error \"not an integer\"; (value, [])\n                                        }\n\n\nexpr: T_int_const            { fun _ -> IntValue $1 }\n    | T_char_const           { fun _ -> CharValue $1 }\n    | l_value                { fun _ -> let (value , l) = $1 () in\n                                        MultiArray (createArray l)\n                             }\n    | T_lparen expr T_rparen { $2 }\n    | func_call              { fun _ -> match $1 () with\n                                        | Some value -> value\n                                        | None -> Unit\n                             }\n    | T_plus expr            { fun _ -> match $2 () with \n                                        | IntValue num -> IntValue num\n                                        | _ -> error \"not an integer; +\"; Unit\n                             }\n    | T_minus expr           { fun _ -> match $2 () with \n                                        | IntValue num -> IntValue (- num)\n                                        | _ -> error \"not an integer; -\"; Unit\n                             }    \n    | expr T_plus expr       { fun _ -> match ($1 (), $3 ()) with\n                                        | (IntValue a, IntValue b) -> IntValue (a + b)\n                                        | _ -> error \"not an integer; plus\"; Unit\n                             }\n    | expr T_minus expr      { fun _ -> let val1 = $1 () in\n                                        let val2 = $3 () in\n                                        print_variable_value val1;\n                                        print_variable_value val2;\n                                        match (val1, val2) with\n                                        | (IntValue a, IntValue b) -> IntValue (a - b)\n                                        | (c, d) -> error \"not an integer; minus\"; Unit\n                             }\n    | expr T_times expr      { fun _ -> match ($1 (), $3 ()) with\n                                        | (IntValue a, IntValue b) -> IntValue (a * b)\n                                        | _ -> error \"not an integer; times\"; Unit\n                             }\n    | expr T_div expr        { fun _ -> match ($1 (), $3 ()) with\n                                        | (IntValue a, IntValue b) -> IntValue (a / b)\n                                        | _ -> error \"not an integer; div\"; Unit\n                             }\n    | expr T_mod expr        { fun _ -> match ($1 (), $3 ()) with\n                                        | (IntValue a, IntValue b) -> IntValue (a mod b)\n                                        | _ -> error \"not an integer; mod\"; Unit\n                             }\n \ncond: T_lparen cond T_rparen { $2 }\n    | T_not cond             { fun _ -> not ($2 ()) }\n    | cond T_and cond        { fun _ -> $1 () && $3 () }\n    | cond T_or cond         { fun _ -> $1 () || $3 () }\n    | expr T_eq expr         { fun _ -> $1 () = $3 () }\n    | expr T_hash expr       { fun _ -> $1 () <> $3 () }\n    | expr T_less expr       { fun _ -> $1 () < $3 () }\n    | expr T_more expr       { fun _ -> $1 () > $3 () }\n    | expr T_leq expr        { fun _ -> $1 () <= $3 () }\n    | expr T_geq expr        { fun _ -> $1 () >= $3 () }\n"}]}}
Read message 
{"jsonrpc":"2.0","id":50,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/tsimiho/Desktop/NTUA/ECE/Semester8/%CE%9C%CE%B5%CF%84%CE%B1%CE%B3%CE%BB%CF%89%CF%84%CF%84%CE%B9%CF%83%CF%84%CE%AD%CF%82/compiler/Parser.mly"},"position":{"line":0,"character":0}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.018835067749ms
Sending response {"id": 50, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":51,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/tsimiho/Desktop/NTUA/ECE/Semester8/%CE%9C%CE%B5%CF%84%CE%B1%CE%B3%CE%BB%CF%89%CF%84%CF%84%CE%B9%CF%83%CF%84%CE%AD%CF%82/compiler/Symbol.ml"},"position":{"line":0,"character":0}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.014066696167ms
Sending response {"id": 51, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/tsimiho/Desktop/NTUA/ECE/Semester8/%CE%9C%CE%B5%CF%84%CE%B1%CE%B3%CE%BB%CF%89%CF%84%CF%84%CE%B9%CF%83%CF%84%CE%AD%CF%82/compiler/Symbol.ml","version":9},"contentChanges":[{"text":"open Identifier\nopen Error\nopen Types\nopen Narray\n\nmodule H = Hashtbl.Make (\n  struct\n    type t = id\n    let equal = (==)\n    let hash = Hashtbl.hash\n  end\n)\n\ntype pass_mode = PASS_BY_VALUE | PASS_BY_REFERENCE\n\ntype param_status =\n  | PARDEF_COMPLETE\n  | PARDEF_DEFINE\n  | PARDEF_CHECK\n\ntype scope = {\n  sco_parent          : scope option;\n  sco_nesting         : int;\n  mutable sco_entries : entry list;\n  mutable sco_negofs  : int\n}\n\nand variable_value =\n  | IntValue of int\n  | CharValue of char\n  | BoolValue of bool\n  | MultiArray of int multi_array\n  | Unit\n\nand variable_info = {\n  variable_type   : Types.typ;\n  variable_offset : int;\n  (* initialized     : bool; *)\n  mutable value   : variable_value\n}\n\nand function_info = {\n  mutable function_isForward : bool;\n  mutable function_paramlist : entry list;\n  mutable function_redeflist : entry list;\n  mutable function_result    : Types.typ;\n  mutable function_pstatus   : param_status;\n  mutable function_initquad  : int;\n  mutable function_body      : unit -> variable_value option\n}\n\nand parameter_info = {\n  parameter_type           : Types.typ;\n  mutable parameter_offset : int;\n  parameter_mode           : pass_mode\n}\n\nand temporary_info = {\n  temporary_type   : Types.typ;\n  temporary_offset : int\n}\n\nand entry_info = ENTRY_none\n               | ENTRY_variable of variable_info\n               | ENTRY_function of function_info\n               | ENTRY_parameter of parameter_info\n               | ENTRY_temporary of temporary_info\n\nand entry = {\n  entry_id    : Identifier.id;\n  entry_scope : scope\n  entry_info  : entry_info\n}\n\ntype lookup_type = LOOKUP_CURRENT_SCOPE | LOOKUP_ALL_SCOPES\n\nlet start_positive_offset = 8\nlet start_negative_offset = 0\n\nlet the_outer_scope = {\n  sco_parent = None;\n  sco_nesting = 0;\n  sco_entries = [] ;\n  sco_negofs = start_negative_offset\n}\n\nlet no_entry id = {\n  entry_id = id;\n  entry_scope = the_outer_scope;\n  entry_info = ENTRY_none\n}\n\nlet currentScope = ref the_outer_scope\nlet quadNext = ref 1\nlet tempNumber = ref 1\n\nlet tab = ref (H.create 0)\n\nlet initSymbolTable size =\n   tab := H.create size;\n   currentScope := the_outer_scope\n\nlet openScope () =\n  let sco = {\n    sco_parent = Some !currentScope;\n    sco_nesting = !currentScope.sco_nesting + 1;\n    sco_entries = [];\n    sco_negofs = start_negative_offset\n  } in\n  currentScope := sco\n\nlet closeScope () =\n  let sco = !currentScope in\n  let manyentry e = H.remove !tab e.entry_id in\n  List.iter manyentry sco.sco_entries;\n  match sco.sco_parent with\n  | Some scp ->\n      currentScope := scp\n  | None ->\n      internal \"cannot close the outer scope!\"\n\nexception Failure_NewEntry of entry\n\nlet newEntry id inf err =\n  try\n    if err then begin\n      try\n        let e = H.find !tab id in\n        if e.entry_scope.sco_nesting = !currentScope.sco_nesting then\n           raise (Failure_NewEntry e)\n      with Not_found ->\n        ()\n    end;\n    let e = {\n      entry_id = id;\n      entry_scope = !currentScope;\n      entry_info = inf\n    } in\n    H.add !tab id e;\n    !currentScope.sco_entries <- e :: !currentScope.sco_entries;\n    e\n  with Failure_NewEntry e ->\n    error \"duplicate identifier %a\" pretty_id id;\n    e\n\nlet lookupEntry id how err =\n  let scc = !currentScope in\n  let lookup () =\n    match how with\n    | LOOKUP_CURRENT_SCOPE ->\n        let e = H.find !tab id in\n        if e.entry_scope.sco_nesting = scc.sco_nesting then\n          e\n        else\n          raise Not_found\n    | LOOKUP_ALL_SCOPES ->\n        H.find !tab id in\n  if err then\n    try\n      lookup ()\n    with Not_found ->\n      error \"unknown identifier %a (first occurrence)\"\n        pretty_id id;\n      H.add !tab id (no_entry id);\n      raise Exit\n  else\n    lookup ()\n\nlet newVariable id typ err =\n  !currentScope.sco_negofs <- !currentScope.sco_negofs - sizeOfType typ;\n  let size = extractDimensionSizes typ in\n  let inf = {\n    variable_type = typ;\n    variable_offset = !currentScope.sco_negofs;\n    value = match typ with\n            | TYPE_int -> IntValue 0\n            | TYPE_char -> CharValue '0'\n            | _ -> let arr = createArray size in MultiArray arr\n  } in\n  newEntry id (ENTRY_variable inf) err\n\nlet newFunction id err =\n  try\n    let e = lookupEntry id LOOKUP_CURRENT_SCOPE false in\n    match e.entry_info with\n    | ENTRY_function inf when inf.function_isForward ->\n        inf.function_isForward <- false;\n        inf.function_pstatus <- PARDEF_CHECK;\n        inf.function_redeflist <- inf.function_paramlist;\n        e\n    | _ ->\n        if err then\n          error \"duplicate identifier: %a\" pretty_id id;\n          raise Exit\n  with Not_found ->\n    let inf = {\n      function_isForward = false;\n      function_paramlist = [];\n      function_redeflist = [];\n      function_result = TYPE_none;\n      function_pstatus = PARDEF_DEFINE;\n      function_initquad = 0;\n      function_body = fun _ -> None\n    } in\n    newEntry id (ENTRY_function inf) false\n\nlet newParameter id typ mode f err =\n  match f.entry_info with\n  | ENTRY_function inf -> begin\n      match inf.function_pstatus with\n      | PARDEF_DEFINE ->\n          let inf_p = {\n            parameter_type = typ;\n            parameter_offset = 0;\n            parameter_mode = mode\n          } in\n          let e = newEntry id (ENTRY_parameter inf_p) err in\n          inf.function_paramlist <- e :: inf.function_paramlist;\n          e\n      | PARDEF_CHECK -> begin\n          match inf.function_redeflist with\n          | p :: ps -> begin\n              inf.function_redeflist <- ps;\n              match p.entry_info with\n              | ENTRY_parameter inf ->\n                  if not (equalType inf.parameter_type typ) then\n                    error \"Parameter type mismatch in redeclaration \\\n                           of function %a\" pretty_id f.entry_id\n                  else if inf.parameter_mode != mode then\n                    error \"Parameter passing mode mismatch in redeclaration \\\n                           of function %a\" pretty_id f.entry_id\n                  else if p.entry_id != id then\n                    error \"Parameter name mismatch in redeclaration \\\n                           of function %a\" pretty_id f.entry_id\n                  else\n                    H.add !tab id p;\n                  p\n              | _ ->\n                  internal \"I found a parameter that is not a parameter!\";\n                  raise Exit\n            end\n          | [] ->\n              error \"More parameters than expected in redeclaration \\\n                     of function %a\" pretty_id f.entry_id;\n              raise Exit\n        end\n      | PARDEF_COMPLETE ->\n          internal \"Cannot add a parameter to an already defined function\";\n          raise Exit\n    end\n  | _ ->\n      internal \"Cannot add a parameter to a non-function\";\n      raise Exit\n\nlet newTemporary typ =\n  let id = id_make (\"$\" ^ string_of_int !tempNumber) in\n  !currentScope.sco_negofs <- !currentScope.sco_negofs - sizeOfType typ;\n  let inf = {\n    temporary_type = typ;\n    temporary_offset = !currentScope.sco_negofs\n  } in\n  incr tempNumber;\n  newEntry id (ENTRY_temporary inf) false\n\nlet forwardFunction e =\n  match e.entry_info with\n  | ENTRY_function inf ->\n      inf.function_isForward <- true\n  | _ ->\n      internal \"Cannot make a non-function forward\"\n\nlet endFunctionHeader e typ =\n  match e.entry_info with\n  | ENTRY_function inf ->\n      begin\n        match inf.function_pstatus with\n        | PARDEF_COMPLETE ->\n            internal \"Cannot end parameters in an already defined function\"\n        | PARDEF_DEFINE ->\n            inf.function_result <- typ;\n            let offset = ref start_positive_offset in\n            let fix_offset e =\n              match e.entry_info with\n              | ENTRY_parameter inf ->\n                  inf.parameter_offset <- !offset;\n                  let size =\n                    match inf.parameter_mode with\n                    | PASS_BY_VALUE     -> sizeOfType inf.parameter_type\n                    | PASS_BY_REFERENCE -> 2 in\n                  offset := !offset + size\n              | _ ->\n                  internal \"Cannot fix offset to a non parameter\" in\n            List.iter fix_offset inf.function_paramlist;\n            inf.function_paramlist <- List.rev inf.function_paramlist\n        | PARDEF_CHECK ->\n            if inf.function_redeflist <> [] then\n              error \"Fewer parameters than expected in redeclaration \\\n                     of function %a\" pretty_id e.entry_id;\n            if not (equalType inf.function_result typ) then\n              error \"Result type mismatch in redeclaration of function %a\"\n                    pretty_id e.entry_id;\n      end;\n      inf.function_pstatus <- PARDEF_COMPLETE\n  | _ ->\n      internal \"Cannot end parameters in a non-function\"\n\nlet assignToVariable (id: Identifier.id) (expr_val: variable_value) = \n  try\n    let variable_entry = lookupEntry id LOOKUP_CURRENT_SCOPE true in\n    match variable_entry.entry_info with \n    | ENTRY_variable v -> v.value <- expr_val\n    | _ -> error \"not a variable\"\n  with Not_found -> error \"Variable %a not found\" pretty_id id\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/tsimiho/Desktop/NTUA/ECE/Semester8/%CE%9C%CE%B5%CF%84%CE%B1%CE%B3%CE%BB%CF%89%CF%84%CF%84%CE%B9%CF%83%CF%84%CE%AD%CF%82/compiler/Symbol.ml","version":10},"contentChanges":[{"text":"open Identifier\nopen Error\nopen Types\nopen Narray\n\nmodule H = Hashtbl.Make (\n  struct\n    type t = id\n    let equal = (==)\n    let hash = Hashtbl.hash\n  end\n)\n\ntype pass_mode = PASS_BY_VALUE | PASS_BY_REFERENCE\n\ntype param_status =\n  | PARDEF_COMPLETE\n  | PARDEF_DEFINE\n  | PARDEF_CHECK\n\ntype scope = {\n  sco_parent          : scope option;\n  sco_nesting         : int;\n  mutable sco_entries : entry list;\n  mutable sco_negofs  : int\n}\n\nand variable_value =\n  | IntValue of int\n  | CharValue of char\n  | BoolValue of bool\n  | MultiArray of int multi_array\n  | Unit\n\nand variable_info = {\n  variable_type   : Types.typ;\n  variable_offset : int;\n  (* initialized     : bool; *)\n  mutable value   : variable_value\n}\n\nand function_info = {\n  mutable function_isForward : bool;\n  mutable function_paramlist : entry list;\n  mutable function_redeflist : entry list;\n  mutable function_result    : Types.typ;\n  mutable function_pstatus   : param_status;\n  mutable function_initquad  : int;\n  mutable function_body      : unit -> variable_value option\n}\n\nand parameter_info = {\n  parameter_type           : Types.typ;\n  mutable parameter_offset : int;\n  parameter_mode           : pass_mode\n}\n\nand temporary_info = {\n  temporary_type   : Types.typ;\n  temporary_offset : int\n}\n\nand entry_info = ENTRY_none\n               | ENTRY_variable of variable_info\n               | ENTRY_function of function_info\n               | ENTRY_parameter of parameter_info\n               | ENTRY_temporary of temporary_info\n\nand entry = {\n  entry_id    : Identifier.id;\n  entry_scope : scope\n  entry_info  : entry_info\n}\n\ntype lookup_type = LOOKUP_CURRENT_SCOPE | LOOKUP_ALL_SCOPES\n\nlet start_positive_offset = 8\nlet start_negative_offset = 0\n\nlet the_outer_scope = {\n  sco_parent = None;\n  sco_nesting = 0;\n  sco_entries = [] ;\n  sco_negofs = start_negative_offset\n}\n\nlet no_entry id = {\n  entry_id = id;\n  entry_scope = the_outer_scope;\n  entry_info = ENTRY_none\n}\n\nlet currentScope = ref the_outer_scope\nlet quadNext = ref 1\nlet tempNumber = ref 1\n\nlet tab = ref (H.create 0)\n\nlet initSymbolTable size =\n   tab := H.create size;\n   currentScope := the_outer_scope\n\nlet openScope () =\n  let sco = {\n    sco_parent = Some !currentScope;\n    sco_nesting = !currentScope.sco_nesting + 1;\n    sco_entries = [];\n    sco_negofs = start_negative_offset\n  } in\n  currentScope := sco\n\nlet closeScope () =\n  let sco = !currentScope in\n  let manyentry e = H.remove !tab e.entry_id in\n  List.iter manyentry sco.sco_entries;\n  match sco.sco_parent with\n  | Some scp ->\n      currentScope := scp\n  | None ->\n      internal \"cannot close the outer scope!\"\n\nexception Failure_NewEntry of entry\n\nlet newEntry id inf err =\n  try\n    if err then begin\n      try\n        let e = H.find !tab id in\n        if e.entry_scope.sco_nesting = !currentScope.sco_nesting then\n           raise (Failure_NewEntry e)\n      with Not_found ->\n        ()\n    end;\n    let e = {\n      entry_id = id;\n      entry_scope = !currentScope;\n      entry_info = inf\n    } in\n    H.add !tab id e;\n    !currentScope.sco_entries <- e :: !currentScope.sco_entries;\n    e\n  with Failure_NewEntry e ->\n    error \"duplicate identifier %a\" pretty_id id;\n    e\n\nlet lookupEntry id how err =\n  let scc = !currentScope in\n  let lookup () =\n    match how with\n    | LOOKUP_CURRENT_SCOPE ->\n        let e = H.find !tab id in\n        if e.entry_scope.sco_nesting = scc.sco_nesting then\n          e\n        else\n          raise Not_found\n    | LOOKUP_ALL_SCOPES ->\n        H.find !tab id in\n  if err then\n    try\n      lookup ()\n    with Not_found ->\n      error \"unknown identifier %a (first occurrence)\"\n        pretty_id id;\n      H.add !tab id (no_entry id);\n      raise Exit\n  else\n    lookup ()\n\nlet newVariable id typ err =\n  !currentScope.sco_negofs <- !currentScope.sco_negofs - sizeOfType typ;\n  let size = extractDimensionSizes typ in\n  let inf = {\n    variable_type = typ;\n    variable_offset = !currentScope.sco_negofs;\n    value = match typ with\n            | TYPE_int -> IntValue 0\n            | TYPE_char -> CharValue '0'\n            | _ -> let arr = createArray size in MultiArray arr\n  } in\n  newEntry id (ENTRY_variable inf) err\n\nlet newFunction id err =\n  try\n    let e = lookupEntry id LOOKUP_CURRENT_SCOPE false in\n    match e.entry_info with\n    | ENTRY_function inf when inf.function_isForward ->\n        inf.function_isForward <- false;\n        inf.function_pstatus <- PARDEF_CHECK;\n        inf.function_redeflist <- inf.function_paramlist;\n        e\n    | _ ->\n        if err then\n          error \"duplicate identifier: %a\" pretty_id id;\n          raise Exit\n  with Not_found ->\n    let inf = {\n      function_isForward = false;\n      function_paramlist = [];\n      function_redeflist = [];\n      function_result = TYPE_none;\n      function_pstatus = PARDEF_DEFINE;\n      function_initquad = 0;\n      function_body = fun _ -> None\n    } in\n    newEntry id (ENTRY_function inf) false\n\nlet newParameter id typ mode f err =\n  match f.entry_info with\n  | ENTRY_function inf -> begin\n      match inf.function_pstatus with\n      | PARDEF_DEFINE ->\n          let inf_p = {\n            parameter_type = typ;\n            parameter_offset = 0;\n            parameter_mode = mode\n          } in\n          let e = newEntry id (ENTRY_parameter inf_p) err in\n          inf.function_paramlist <- e :: inf.function_paramlist;\n          e\n      | PARDEF_CHECK -> begin\n          match inf.function_redeflist with\n          | p :: ps -> begin\n              inf.function_redeflist <- ps;\n              match p.entry_info with\n              | ENTRY_parameter inf ->\n                  if not (equalType inf.parameter_type typ) then\n                    error \"Parameter type mismatch in redeclaration \\\n                           of function %a\" pretty_id f.entry_id\n                  else if inf.parameter_mode != mode then\n                    error \"Parameter passing mode mismatch in redeclaration \\\n                           of function %a\" pretty_id f.entry_id\n                  else if p.entry_id != id then\n                    error \"Parameter name mismatch in redeclaration \\\n                           of function %a\" pretty_id f.entry_id\n                  else\n                    H.add !tab id p;\n                  p\n              | _ ->\n                  internal \"I found a parameter that is not a parameter!\";\n                  raise Exit\n            end\n          | [] ->\n              error \"More parameters than expected in redeclaration \\\n                     of function %a\" pretty_id f.entry_id;\n              raise Exit\n        end\n      | PARDEF_COMPLETE ->\n          internal \"Cannot add a parameter to an already defined function\";\n          raise Exit\n    end\n  | _ ->\n      internal \"Cannot add a parameter to a non-function\";\n      raise Exit\n\nlet newTemporary typ =\n  let id = id_make (\"$\" ^ string_of_int !tempNumber) in\n  !currentScope.sco_negofs <- !currentScope.sco_negofs - sizeOfType typ;\n  let inf = {\n    temporary_type = typ;\n    temporary_offset = !currentScope.sco_negofs\n  } in\n  incr tempNumber;\n  newEntry id (ENTRY_temporary inf) false\n\nlet forwardFunction e =\n  match e.entry_info with\n  | ENTRY_function inf ->\n      inf.function_isForward <- true\n  | _ ->\n      internal \"Cannot make a non-function forward\"\n\nlet endFunctionHeader e typ =\n  match e.entry_info with\n  | ENTRY_function inf ->\n      begin\n        match inf.function_pstatus with\n        | PARDEF_COMPLETE ->\n            internal \"Cannot end parameters in an already defined function\"\n        | PARDEF_DEFINE ->\n            inf.function_result <- typ;\n            let offset = ref start_positive_offset in\n            let fix_offset e =\n              match e.entry_info with\n              | ENTRY_parameter inf ->\n                  inf.parameter_offset <- !offset;\n                  let size =\n                    match inf.parameter_mode with\n                    | PASS_BY_VALUE     -> sizeOfType inf.parameter_type\n                    | PASS_BY_REFERENCE -> 2 in\n                  offset := !offset + size\n              | _ ->\n                  internal \"Cannot fix offset to a non parameter\" in\n            List.iter fix_offset inf.function_paramlist;\n            inf.function_paramlist <- List.rev inf.function_paramlist\n        | PARDEF_CHECK ->\n            if inf.function_redeflist <> [] then\n              error \"Fewer parameters than expected in redeclaration \\\n                     of function %a\" pretty_id e.entry_id;\n            if not (equalType inf.function_result typ) then\n              error \"Result type mismatch in redeclaration of function %a\"\n                    pretty_id e.entry_id;\n      end;\n      inf.function_pstatus <- PARDEF_COMPLETE\n  | _ ->\n      internal \"Cannot end parameters in a non-function\"\n\nlet assignToVariable (id: Identifier.id) (expr_val: variable_value) = \n  try\n    let variable_entry = lookupEntry id LOOKUP_CURRENT_SCOPE true in\n    match variable_entry.entry_info with \n    | ENTRY_variable v -> v.value <- expr_val\n    | _ -> error \"not a variable\"\n  with Not_found -> error \"Variable %a not found\" pretty_id id\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/tsimiho/Desktop/NTUA/ECE/Semester8/%CE%9C%CE%B5%CF%84%CE%B1%CE%B3%CE%BB%CF%89%CF%84%CF%84%CE%B9%CF%83%CF%84%CE%AD%CF%82/compiler/Symbol.ml","version":11},"contentChanges":[{"text":"open Identifier\nopen Error\nopen Types\nopen Narray\n\nmodule H = Hashtbl.Make (\n  struct\n    type t = id\n    let equal = (==)\n    let hash = Hashtbl.hash\n  end\n)\n\ntype pass_mode = PASS_BY_VALUE | PASS_BY_REFERENCE\n\ntype param_status =\n  | PARDEF_COMPLETE\n  | PARDEF_DEFINE\n  | PARDEF_CHECK\n\ntype scope = {\n  sco_parent          : scope option;\n  sco_nesting         : int;\n  mutable sco_entries : entry list;\n  mutable sco_negofs  : int\n}\n\nand variable_value =\n  | IntValue of int\n  | CharValue of char\n  | BoolValue of bool\n  | MultiArray of int multi_array\n  | Unit\n\nand variable_info = {\n  variable_type   : Types.typ;\n  variable_offset : int;\n  (* initialized     : bool; *)\n  mutable value   : variable_value\n}\n\nand function_info = {\n  mutable function_isForward : bool;\n  mutable function_paramlist : entry list;\n  mutable function_redeflist : entry list;\n  mutable function_result    : Types.typ;\n  mutable function_pstatus   : param_status;\n  mutable function_initquad  : int;\n  mutable function_body      : unit -> variable_value option\n}\n\nand parameter_info = {\n  parameter_type           : Types.typ;\n  mutable parameter_offset : int;\n  parameter_mode           : pass_mode\n}\n\nand temporary_info = {\n  temporary_type   : Types.typ;\n  temporary_offset : int\n}\n\nand entry_info = ENTRY_none\n               | ENTRY_variable of variable_info\n               | ENTRY_function of function_info\n               | ENTRY_parameter of parameter_info\n               | ENTRY_temporary of temporary_info\n\nand entry = {\n  entry_id    : Identifier.id;\n  entry_scope : scope\n  entry_info  : entry_info\n}\n\ntype lookup_type = LOOKUP_CURRENT_SCOPE | LOOKUP_ALL_SCOPES\n\nlet start_positive_offset = 8\nlet start_negative_offset = 0\n\nlet the_outer_scope = {\n  sco_parent = None;\n  sco_nesting = 0;\n  sco_entries = [] ;\n  sco_negofs = start_negative_offset\n}\n\nlet no_entry id = {\n  entry_id = id;\n  entry_scope = the_outer_scope;\n  entry_info = ENTRY_none\n}\n\nlet currentScope = ref the_outer_scope\nlet quadNext = ref 1\nlet tempNumber = ref 1\n\nlet tab = ref (H.create 0)\n\nlet initSymbolTable size =\n   tab := H.create size;\n   currentScope := the_outer_scope\n\nlet openScope () =\n  let sco = {\n    sco_parent = Some !currentScope;\n    sco_nesting = !currentScope.sco_nesting + 1;\n    sco_entries = [];\n    sco_negofs = start_negative_offset\n  } in\n  currentScope := sco\n\nlet closeScope () =\n  let sco = !currentScope in\n  let manyentry e = H.remove !tab e.entry_id in\n  List.iter manyentry sco.sco_entries;\n  match sco.sco_parent with\n  | Some scp ->\n      currentScope := scp\n  | None ->\n      internal \"cannot close the outer scope!\"\n\nexception Failure_NewEntry of entry\n\nlet newEntry id inf err =\n  try\n    if err then begin\n      try\n        let e = H.find !tab id in\n        if e.entry_scope.sco_nesting = !currentScope.sco_nesting then\n           raise (Failure_NewEntry e)\n      with Not_found ->\n        ()\n    end;\n    let e = {\n      entry_id = id;\n      entry_scope = !currentScope;\n      entry_info = inf\n    } in\n    H.add !tab id e;\n    !currentScope.sco_entries <- e :: !currentScope.sco_entries;\n    e\n  with Failure_NewEntry e ->\n    error \"duplicate identifier %a\" pretty_id id;\n    e\n\nlet lookupEntry id how err =\n  let scc = !currentScope in\n  let lookup () =\n    match how with\n    | LOOKUP_CURRENT_SCOPE ->\n        let e = H.find !tab id in\n        if e.entry_scope.sco_nesting = scc.sco_nesting then\n          e\n        else\n          raise Not_found\n    | LOOKUP_ALL_SCOPES ->\n        H.find !tab id in\n  if err then\n    try\n      lookup ()\n    with Not_found ->\n      error \"unknown identifier %a (first occurrence)\"\n        pretty_id id;\n      H.add !tab id (no_entry id);\n      raise Exit\n  else\n    lookup ()\n\nlet newVariable id typ err =\n  !currentScope.sco_negofs <- !currentScope.sco_negofs - sizeOfType typ;\n  let size = extractDimensionSizes typ in\n  let inf = {\n    variable_type = typ;\n    variable_offset = !currentScope.sco_negofs;\n    value = match typ with\n            | TYPE_int -> IntValue 0\n            | TYPE_char -> CharValue '0'\n            | _ -> let arr = createArray size in MultiArray arr\n  } in\n  newEntry id (ENTRY_variable inf) err\n\nlet newFunction id err =\n  try\n    let e = lookupEntry id LOOKUP_CURRENT_SCOPE false in\n    match e.entry_info with\n    | ENTRY_function inf when inf.function_isForward ->\n        inf.function_isForward <- false;\n        inf.function_pstatus <- PARDEF_CHECK;\n        inf.function_redeflist <- inf.function_paramlist;\n        e\n    | _ ->\n        if err then\n          error \"duplicate identifier: %a\" pretty_id id;\n          raise Exit\n  with Not_found ->\n    let inf = {\n      function_isForward = false;\n      function_paramlist = [];\n      function_redeflist = [];\n      function_result = TYPE_none;\n      function_pstatus = PARDEF_DEFINE;\n      function_initquad = 0;\n      function_body = fun _ -> None\n    } in\n    newEntry id (ENTRY_function inf) false\n\nlet newParameter id typ mode f err =\n  match f.entry_info with\n  | ENTRY_function inf -> begin\n      match inf.function_pstatus with\n      | PARDEF_DEFINE ->\n          let inf_p = {\n            parameter_type = typ;\n            parameter_offset = 0;\n            parameter_mode = mode\n          } in\n          let e = newEntry id (ENTRY_parameter inf_p) err in\n          inf.function_paramlist <- e :: inf.function_paramlist;\n          e\n      | PARDEF_CHECK -> begin\n          match inf.function_redeflist with\n          | p :: ps -> begin\n              inf.function_redeflist <- ps;\n              match p.entry_info with\n              | ENTRY_parameter inf ->\n                  if not (equalType inf.parameter_type typ) then\n                    error \"Parameter type mismatch in redeclaration \\\n                           of function %a\" pretty_id f.entry_id\n                  else if inf.parameter_mode != mode then\n                    error \"Parameter passing mode mismatch in redeclaration \\\n                           of function %a\" pretty_id f.entry_id\n                  else if p.entry_id != id then\n                    error \"Parameter name mismatch in redeclaration \\\n                           of function %a\" pretty_id f.entry_id\n                  else\n                    H.add !tab id p;\n                  p\n              | _ ->\n                  internal \"I found a parameter that is not a parameter!\";\n                  raise Exit\n            end\n          | [] ->\n              error \"More parameters than expected in redeclaration \\\n                     of function %a\" pretty_id f.entry_id;\n              raise Exit\n        end\n      | PARDEF_COMPLETE ->\n          internal \"Cannot add a parameter to an already defined function\";\n          raise Exit\n    end\n  | _ ->\n      internal \"Cannot add a parameter to a non-function\";\n      raise Exit\n\nlet newTemporary typ =\n  let id = id_make (\"$\" ^ string_of_int !tempNumber) in\n  !currentScope.sco_negofs <- !currentScope.sco_negofs - sizeOfType typ;\n  let inf = {\n    temporary_type = typ;\n    temporary_offset = !currentScope.sco_negofs\n  } in\n  incr tempNumber;\n  newEntry id (ENTRY_temporary inf) false\n\nlet forwardFunction e =\n  match e.entry_info with\n  | ENTRY_function inf ->\n      inf.function_isForward <- true\n  | _ ->\n      internal \"Cannot make a non-function forward\"\n\nlet endFunctionHeader e typ =\n  match e.entry_info with\n  | ENTRY_function inf ->\n      begin\n        match inf.function_pstatus with\n        | PARDEF_COMPLETE ->\n            internal \"Cannot end parameters in an already defined function\"\n        | PARDEF_DEFINE ->\n            inf.function_result <- typ;\n            let offset = ref start_positive_offset in\n            let fix_offset e =\n              match e.entry_info with\n              | ENTRY_parameter inf ->\n                  inf.parameter_offset <- !offset;\n                  let size =\n                    match inf.parameter_mode with\n                    | PASS_BY_VALUE     -> sizeOfType inf.parameter_type\n                    | PASS_BY_REFERENCE -> 2 in\n                  offset := !offset + size\n              | _ ->\n                  internal \"Cannot fix offset to a non parameter\" in\n            List.iter fix_offset inf.function_paramlist;\n            inf.function_paramlist <- List.rev inf.function_paramlist\n        | PARDEF_CHECK ->\n            if inf.function_redeflist <> [] then\n              error \"Fewer parameters than expected in redeclaration \\\n                     of function %a\" pretty_id e.entry_id;\n            if not (equalType inf.function_result typ) then\n              error \"Result type mismatch in redeclaration of function %a\"\n                    pretty_id e.entry_id;\n      end;\n      inf.function_pstatus <- PARDEF_COMPLETE\n  | _ ->\n      internal \"Cannot end parameters in a non-function\"\n\nlet assignToVariable (id: Identifier.id) (expr_val: variable_value) = \n  try\n    let variable_entry = lookupEntry id LOOKUP_CURRENT_SCOPE true in\n    match variable_entry.entry_info with \n    | ENTRY_variable v -> v.value <- expr_val\n    | _ -> error \"not a variable\"\n  with Not_found -> error \"Variable %a not found\" pretty_id id\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/tsimiho/Desktop/NTUA/ECE/Semester8/%CE%9C%CE%B5%CF%84%CE%B1%CE%B3%CE%BB%CF%89%CF%84%CF%84%CE%B9%CF%83%CF%84%CE%AD%CF%82/compiler/Symbol.ml","version":12},"contentChanges":[{"text":"open Identifier\nopen Error\nopen Types\nopen Narray\n\nmodule H = Hashtbl.Make (\n  struct\n    type t = id\n    let equal = (==)\n    let hash = Hashtbl.hash\n  end\n)\n\ntype pass_mode = PASS_BY_VALUE | PASS_BY_REFERENCE\n\ntype param_status =\n  | PARDEF_COMPLETE\n  | PARDEF_DEFINE\n  | PARDEF_CHECK\n\ntype scope = {\n  sco_parent          : scope option;\n  sco_nesting         : int;\n  mutable sco_entries : entry list;\n  mutable sco_negofs  : int\n}\n\nand variable_value =\n  | IntValue of int\n  | CharValue of char\n  | BoolValue of bool\n  | MultiArray of int multi_array\n  | Unit\n\nand variable_info = {\n  variable_type   : Types.typ;\n  variable_offset : int;\n  (* initialized     : bool; *)\n  mutable value   : variable_value\n}\n\nand function_info = {\n  mutable function_isForward : bool;\n  mutable function_paramlist : entry list;\n  mutable function_redeflist : entry list;\n  mutable function_result    : Types.typ;\n  mutable function_pstatus   : param_status;\n  mutable function_initquad  : int;\n  mutable function_body      : unit -> variable_value option\n}\n\nand parameter_info = {\n  parameter_type           : Types.typ;\n  mutable parameter_offset : int;\n  parameter_mode           : pass_mode\n}\n\nand temporary_info = {\n  temporary_type   : Types.typ;\n  temporary_offset : int\n}\n\nand entry_info = ENTRY_none\n               | ENTRY_variable of variable_info\n               | ENTRY_function of function_info\n               | ENTRY_parameter of parameter_info\n               | ENTRY_temporary of temporary_info\n\nand entry = {\n  entry_id    : Identifier.id;\n  entry_scope : scope\n  entry_info  : entry_info\n}\n\ntype lookup_type = LOOKUP_CURRENT_SCOPE | LOOKUP_ALL_SCOPES\n\nlet start_positive_offset = 8\nlet start_negative_offset = 0\n\nlet the_outer_scope = {\n  sco_parent = None;\n  sco_nesting = 0;\n  sco_entries = [] ;\n  sco_negofs = start_negative_offset\n}\n\nlet no_entry id = {\n  entry_id = id;\n  entry_scope = the_outer_scope;\n  entry_info = ENTRY_none\n}\n\nlet currentScope = ref the_outer_scope\nlet quadNext = ref 1\nlet tempNumber = ref 1\n\nlet tab = ref (H.create 0)\n\nlet initSymbolTable size =\n   tab := H.create size;\n   currentScope := the_outer_scope\n\nlet openScope () =\n  let sco = {\n    sco_parent = Some !currentScope;\n    sco_nesting = !currentScope.sco_nesting + 1;\n    sco_entries = [];\n    sco_negofs = start_negative_offset\n  } in\n  currentScope := sco\n\nlet closeScope () =\n  let sco = !currentScope in\n  let manyentry e = H.remove !tab e.entry_id in\n  List.iter manyentry sco.sco_entries;\n  match sco.sco_parent with\n  | Some scp ->\n      currentScope := scp\n  | None ->\n      internal \"cannot close the outer scope!\"\n\nexception Failure_NewEntry of entry\n\nlet newEntry id inf err =\n  try\n    if err then begin\n      try\n        let e = H.find !tab id in\n        if e.entry_scope.sco_nesting = !currentScope.sco_nesting then\n           raise (Failure_NewEntry e)\n      with Not_found ->\n        ()\n    end;\n    let e = {\n      entry_id = id;\n      entry_scope = !currentScope;\n      entry_info = inf\n    } in\n    H.add !tab id e;\n    !currentScope.sco_entries <- e :: !currentScope.sco_entries;\n    e\n  with Failure_NewEntry e ->\n    error \"duplicate identifier %a\" pretty_id id;\n    e\n\nlet lookupEntry id how err =\n  let scc = !currentScope in\n  let lookup () =\n    match how with\n    | LOOKUP_CURRENT_SCOPE ->\n        let e = H.find !tab id in\n        if e.entry_scope.sco_nesting = scc.sco_nesting then\n          e\n        else\n          raise Not_found\n    | LOOKUP_ALL_SCOPES ->\n        H.find !tab id in\n  if err then\n    try\n      lookup ()\n    with Not_found ->\n      error \"unknown identifier %a (first occurrence)\"\n        pretty_id id;\n      H.add !tab id (no_entry id);\n      raise Exit\n  else\n    lookup ()\n\nlet newVariable id typ err =\n  !currentScope.sco_negofs <- !currentScope.sco_negofs - sizeOfType typ;\n  let size = extractDimensionSizes typ in\n  let inf = {\n    variable_type = typ;\n    variable_offset = !currentScope.sco_negofs;\n    value = match typ with\n            | TYPE_int -> IntValue 0\n            | TYPE_char -> CharValue '0'\n            | _ -> let arr = createArray size in MultiArray arr\n  } in\n  newEntry id (ENTRY_variable inf) err\n\nlet newFunction id err =\n  try\n    let e = lookupEntry id LOOKUP_CURRENT_SCOPE false in\n    match e.entry_info with\n    | ENTRY_function inf when inf.function_isForward ->\n        inf.function_isForward <- false;\n        inf.function_pstatus <- PARDEF_CHECK;\n        inf.function_redeflist <- inf.function_paramlist;\n        e\n    | _ ->\n        if err then\n          error \"duplicate identifier: %a\" pretty_id id;\n          raise Exit\n  with Not_found ->\n    let inf = {\n      function_isForward = false;\n      function_paramlist = [];\n      function_redeflist = [];\n      function_result = TYPE_none;\n      function_pstatus = PARDEF_DEFINE;\n      function_initquad = 0;\n      function_body = fun _ -> None\n    } in\n    newEntry id (ENTRY_function inf) false\n\nlet newParameter id typ mode f err =\n  match f.entry_info with\n  | ENTRY_function inf -> begin\n      match inf.function_pstatus with\n      | PARDEF_DEFINE ->\n          let inf_p = {\n            parameter_type = typ;\n            parameter_offset = 0;\n            parameter_mode = mode\n          } in\n          let e = newEntry id (ENTRY_parameter inf_p) err in\n          inf.function_paramlist <- e :: inf.function_paramlist;\n          e\n      | PARDEF_CHECK -> begin\n          match inf.function_redeflist with\n          | p :: ps -> begin\n              inf.function_redeflist <- ps;\n              match p.entry_info with\n              | ENTRY_parameter inf ->\n                  if not (equalType inf.parameter_type typ) then\n                    error \"Parameter type mismatch in redeclaration \\\n                           of function %a\" pretty_id f.entry_id\n                  else if inf.parameter_mode != mode then\n                    error \"Parameter passing mode mismatch in redeclaration \\\n                           of function %a\" pretty_id f.entry_id\n                  else if p.entry_id != id then\n                    error \"Parameter name mismatch in redeclaration \\\n                           of function %a\" pretty_id f.entry_id\n                  else\n                    H.add !tab id p;\n                  p\n              | _ ->\n                  internal \"I found a parameter that is not a parameter!\";\n                  raise Exit\n            end\n          | [] ->\n              error \"More parameters than expected in redeclaration \\\n                     of function %a\" pretty_id f.entry_id;\n              raise Exit\n        end\n      | PARDEF_COMPLETE ->\n          internal \"Cannot add a parameter to an already defined function\";\n          raise Exit\n    end\n  | _ ->\n      internal \"Cannot add a parameter to a non-function\";\n      raise Exit\n\nlet newTemporary typ =\n  let id = id_make (\"$\" ^ string_of_int !tempNumber) in\n  !currentScope.sco_negofs <- !currentScope.sco_negofs - sizeOfType typ;\n  let inf = {\n    temporary_type = typ;\n    temporary_offset = !currentScope.sco_negofs\n  } in\n  incr tempNumber;\n  newEntry id (ENTRY_temporary inf) false\n\nlet forwardFunction e =\n  match e.entry_info with\n  | ENTRY_function inf ->\n      inf.function_isForward <- true\n  | _ ->\n      internal \"Cannot make a non-function forward\"\n\nlet endFunctionHeader e typ =\n  match e.entry_info with\n  | ENTRY_function inf ->\n      begin\n        match inf.function_pstatus with\n        | PARDEF_COMPLETE ->\n            internal \"Cannot end parameters in an already defined function\"\n        | PARDEF_DEFINE ->\n            inf.function_result <- typ;\n            let offset = ref start_positive_offset in\n            let fix_offset e =\n              match e.entry_info with\n              | ENTRY_parameter inf ->\n                  inf.parameter_offset <- !offset;\n                  let size =\n                    match inf.parameter_mode with\n                    | PASS_BY_VALUE     -> sizeOfType inf.parameter_type\n                    | PASS_BY_REFERENCE -> 2 in\n                  offset := !offset + size\n              | _ ->\n                  internal \"Cannot fix offset to a non parameter\" in\n            List.iter fix_offset inf.function_paramlist;\n            inf.function_paramlist <- List.rev inf.function_paramlist\n        | PARDEF_CHECK ->\n            if inf.function_redeflist <> [] then\n              error \"Fewer parameters than expected in redeclaration \\\n                     of function %a\" pretty_id e.entry_id;\n            if not (equalType inf.function_result typ) then\n              error \"Result type mismatch in redeclaration of function %a\"\n                    pretty_id e.entry_id;\n      end;\n      inf.function_pstatus <- PARDEF_COMPLETE\n  | _ ->\n      internal \"Cannot end parameters in a non-function\"\n\nlet assignToVariable (id: Identifier.id) (expr_val: variable_value) = \n  try\n    let variable_entry = lookupEntry id LOOKUP_CURRENT_SCOPE true in\n    match variable_entry.entry_info with \n    | ENTRY_variable v -> v.value <- expr_val\n    | _ -> error \"not a variable\"\n  with Not_found -> error \"Variable %a not found\" pretty_id id\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/tsimiho/Desktop/NTUA/ECE/Semester8/%CE%9C%CE%B5%CF%84%CE%B1%CE%B3%CE%BB%CF%89%CF%84%CF%84%CE%B9%CF%83%CF%84%CE%AD%CF%82/compiler/Symbol.ml","version":13},"contentChanges":[{"text":"open Identifier\nopen Error\nopen Types\nopen Narray\n\nmodule H = Hashtbl.Make (\n  struct\n    type t = id\n    let equal = (==)\n    let hash = Hashtbl.hash\n  end\n)\n\ntype pass_mode = PASS_BY_VALUE | PASS_BY_REFERENCE\n\ntype param_status =\n  | PARDEF_COMPLETE\n  | PARDEF_DEFINE\n  | PARDEF_CHECK\n\ntype scope = {\n  sco_parent          : scope option;\n  sco_nesting         : int;\n  mutable sco_entries : entry list;\n  mutable sco_negofs  : int\n}\n\nand variable_value =\n  | IntValue of int\n  | CharValue of char\n  | BoolValue of bool\n  | MultiArray of int multi_array\n  | Unit\n\nand variable_info = {\n  variable_type   : Types.typ;\n  variable_offset : int;\n  (* initialized     : bool; *)\n  mutable value   : variable_value\n}\n\nand function_info = {\n  mutable function_isForward : bool;\n  mutable function_paramlist : entry list;\n  mutable function_redeflist : entry list;\n  mutable function_result    : Types.typ;\n  mutable function_pstatus   : param_status;\n  mutable function_initquad  : int;\n  mutable function_body      : unit -> variable_value option\n}\n\nand parameter_info = {\n  parameter_type           : Types.typ;\n  mutable parameter_offset : int;\n  parameter_mode           : pass_mode\n}\n\nand temporary_info = {\n  temporary_type   : Types.typ;\n  temporary_offset : int\n}\n\nand entry_info = ENTRY_none\n               | ENTRY_variable of variable_info\n               | ENTRY_function of function_info\n               | ENTRY_parameter of parameter_info\n               | ENTRY_temporary of temporary_info\n\nand entry = {\n  entry_id    : Identifier.id;\n  entry_scope : scope\n  entry_info  : entry_info\n}\n\ntype lookup_type = LOOKUP_CURRENT_SCOPE | LOOKUP_ALL_SCOPES\n\nlet start_positive_offset = 8\nlet start_negative_offset = 0\n\nlet the_outer_scope = {\n  sco_parent = None;\n  sco_nesting = 0;\n  sco_entries = [] ;\n  sco_negofs = start_negative_offset\n}\n\nlet no_entry id = {\n  entry_id = id;\n  entry_scope = the_outer_scope;\n  entry_info = ENTRY_none\n}\n\nlet currentScope = ref the_outer_scope\nlet quadNext = ref 1\nlet tempNumber = ref 1\n\nlet tab = ref (H.create 0)\n\nlet initSymbolTable size =\n   tab := H.create size;\n   currentScope := the_outer_scope\n\nlet openScope () =\n  let sco = {\n    sco_parent = Some !currentScope;\n    sco_nesting = !currentScope.sco_nesting + 1;\n    sco_entries = [];\n    sco_negofs = start_negative_offset\n  } in\n  currentScope := sco\n\nlet closeScope () =\n  let sco = !currentScope in\n  let manyentry e = H.remove !tab e.entry_id in\n  List.iter manyentry sco.sco_entries;\n  match sco.sco_parent with\n  | Some scp ->\n      currentScope := scp\n  | None ->\n      internal \"cannot close the outer scope!\"\n\nexception Failure_NewEntry of entry\n\nlet newEntry id inf err =\n  try\n    if err then begin\n      try\n        let e = H.find !tab id in\n        if e.entry_scope.sco_nesting = !currentScope.sco_nesting then\n           raise (Failure_NewEntry e)\n      with Not_found ->\n        ()\n    end;\n    let e = {\n      entry_id = id;\n      entry_scope = !currentScope;\n      entry_info = inf\n    } in\n    H.add !tab id e;\n    !currentScope.sco_entries <- e :: !currentScope.sco_entries;\n    e\n  with Failure_NewEntry e ->\n    error \"duplicate identifier %a\" pretty_id id;\n    e\n\nlet lookupEntry id how err =\n  let scc = !currentScope in\n  let lookup () =\n    match how with\n    | LOOKUP_CURRENT_SCOPE ->\n        let e = H.find !tab id in\n        if e.entry_scope.sco_nesting = scc.sco_nesting then\n          e\n        else\n          raise Not_found\n    | LOOKUP_ALL_SCOPES ->\n        H.find !tab id in\n  if err then\n    try\n      lookup ()\n    with Not_found ->\n      error \"unknown identifier %a (first occurrence)\"\n        pretty_id id;\n      H.add !tab id (no_entry id);\n      raise Exit\n  else\n    lookup ()\n\nlet newVariable id typ err =\n  !currentScope.sco_negofs <- !currentScope.sco_negofs - sizeOfType typ;\n  let size = extractDimensionSizes typ in\n  let inf = {\n    variable_type = typ;\n    variable_offset = !currentScope.sco_negofs;\n    value = match typ with\n            | TYPE_int -> IntValue 0\n            | TYPE_char -> CharValue '0'\n            | _ -> let arr = createArray size in MultiArray arr\n  } in\n  newEntry id (ENTRY_variable inf) err\n\nlet newFunction id err =\n  try\n    let e = lookupEntry id LOOKUP_CURRENT_SCOPE false in\n    match e.entry_info with\n    | ENTRY_function inf when inf.function_isForward ->\n        inf.function_isForward <- false;\n        inf.function_pstatus <- PARDEF_CHECK;\n        inf.function_redeflist <- inf.function_paramlist;\n        e\n    | _ ->\n        if err then\n          error \"duplicate identifier: %a\" pretty_id id;\n          raise Exit\n  with Not_found ->\n    let inf = {\n      function_isForward = false;\n      function_paramlist = [];\n      function_redeflist = [];\n      function_result = TYPE_none;\n      function_pstatus = PARDEF_DEFINE;\n      function_initquad = 0;\n      function_body = fun _ -> None\n    } in\n    newEntry id (ENTRY_function inf) false\n\nlet newParameter id typ mode f err =\n  match f.entry_info with\n  | ENTRY_function inf -> begin\n      match inf.function_pstatus with\n      | PARDEF_DEFINE ->\n          let inf_p = {\n            parameter_type = typ;\n            parameter_offset = 0;\n            parameter_mode = mode\n          } in\n          let e = newEntry id (ENTRY_parameter inf_p) err in\n          inf.function_paramlist <- e :: inf.function_paramlist;\n          e\n      | PARDEF_CHECK -> begin\n          match inf.function_redeflist with\n          | p :: ps -> begin\n              inf.function_redeflist <- ps;\n              match p.entry_info with\n              | ENTRY_parameter inf ->\n                  if not (equalType inf.parameter_type typ) then\n                    error \"Parameter type mismatch in redeclaration \\\n                           of function %a\" pretty_id f.entry_id\n                  else if inf.parameter_mode != mode then\n                    error \"Parameter passing mode mismatch in redeclaration \\\n                           of function %a\" pretty_id f.entry_id\n                  else if p.entry_id != id then\n                    error \"Parameter name mismatch in redeclaration \\\n                           of function %a\" pretty_id f.entry_id\n                  else\n                    H.add !tab id p;\n                  p\n              | _ ->\n                  internal \"I found a parameter that is not a parameter!\";\n                  raise Exit\n            end\n          | [] ->\n              error \"More parameters than expected in redeclaration \\\n                     of function %a\" pretty_id f.entry_id;\n              raise Exit\n        end\n      | PARDEF_COMPLETE ->\n          internal \"Cannot add a parameter to an already defined function\";\n          raise Exit\n    end\n  | _ ->\n      internal \"Cannot add a parameter to a non-function\";\n      raise Exit\n\nlet newTemporary typ =\n  let id = id_make (\"$\" ^ string_of_int !tempNumber) in\n  !currentScope.sco_negofs <- !currentScope.sco_negofs - sizeOfType typ;\n  let inf = {\n    temporary_type = typ;\n    temporary_offset = !currentScope.sco_negofs\n  } in\n  incr tempNumber;\n  newEntry id (ENTRY_temporary inf) false\n\nlet forwardFunction e =\n  match e.entry_info with\n  | ENTRY_function inf ->\n      inf.function_isForward <- true\n  | _ ->\n      internal \"Cannot make a non-function forward\"\n\nlet endFunctionHeader e typ =\n  match e.entry_info with\n  | ENTRY_function inf ->\n      begin\n        match inf.function_pstatus with\n        | PARDEF_COMPLETE ->\n            internal \"Cannot end parameters in an already defined function\"\n        | PARDEF_DEFINE ->\n            inf.function_result <- typ;\n            let offset = ref start_positive_offset in\n            let fix_offset e =\n              match e.entry_info with\n              | ENTRY_parameter inf ->\n                  inf.parameter_offset <- !offset;\n                  let size =\n                    match inf.parameter_mode with\n                    | PASS_BY_VALUE     -> sizeOfType inf.parameter_type\n                    | PASS_BY_REFERENCE -> 2 in\n                  offset := !offset + size\n              | _ ->\n                  internal \"Cannot fix offset to a non parameter\" in\n            List.iter fix_offset inf.function_paramlist;\n            inf.function_paramlist <- List.rev inf.function_paramlist\n        | PARDEF_CHECK ->\n            if inf.function_redeflist <> [] then\n              error \"Fewer parameters than expected in redeclaration \\\n                     of function %a\" pretty_id e.entry_id;\n            if not (equalType inf.function_result typ) then\n              error \"Result type mismatch in redeclaration of function %a\"\n                    pretty_id e.entry_id;\n      end;\n      inf.function_pstatus <- PARDEF_COMPLETE\n  | _ ->\n      internal \"Cannot end parameters in a non-function\"\n\nlet assignToVariable (id: Identifier.id) (expr_val: variable_value) = \n  try\n    let variable_entry = lookupEntry id LOOKUP_CURRENT_SCOPE true in\n    match variable_entry.entry_info with \n    | ENTRY_variable v -> v.value <- expr_val\n    | _ -> error \"not a variable\"\n  with Not_found -> error \"Variable %a not found\" pretty_id id\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/tsimiho/Desktop/NTUA/ECE/Semester8/%CE%9C%CE%B5%CF%84%CE%B1%CE%B3%CE%BB%CF%89%CF%84%CF%84%CE%B9%CF%83%CF%84%CE%AD%CF%82/compiler/Symbol.ml","version":14},"contentChanges":[{"text":"open Identifier\nopen Error\nopen Types\nopen Narray\n\nmodule H = Hashtbl.Make (\n  struct\n    type t = id\n    let equal = (==)\n    let hash = Hashtbl.hash\n  end\n)\n\ntype pass_mode = PASS_BY_VALUE | PASS_BY_REFERENCE\n\ntype param_status =\n  | PARDEF_COMPLETE\n  | PARDEF_DEFINE\n  | PARDEF_CHECK\n\ntype scope = {\n  sco_parent          : scope option;\n  sco_nesting         : int;\n  mutable sco_entries : entry list;\n  mutable sco_negofs  : int\n}\n\nand variable_value =\n  | IntValue of int\n  | CharValue of char\n  | BoolValue of bool\n  | MultiArray of int multi_array\n  | Unit\n\nand variable_info = {\n  variable_type   : Types.typ;\n  variable_offset : int;\n  (* initialized     : bool; *)\n  mutable value   : variable_value\n}\n\nand function_info = {\n  mutable function_isForward : bool;\n  mutable function_paramlist : entry list;\n  mutable function_redeflist : entry list;\n  mutable function_result    : Types.typ;\n  mutable function_pstatus   : param_status;\n  mutable function_initquad  : int;\n  mutable function_body      : unit -> variable_value option\n}\n\nand parameter_info = {\n  parameter_type           : Types.typ;\n  mutable parameter_offset : int;\n  parameter_mode           : pass_mode\n}\n\nand temporary_info = {\n  temporary_type   : Types.typ;\n  temporary_offset : int\n}\n\nand entry_info = ENTRY_none\n               | ENTRY_variable of variable_info\n               | ENTRY_function of function_info\n               | ENTRY_parameter of parameter_info\n               | ENTRY_temporary of temporary_info\n\nand entry = {\n  entry_id    : Identifier.id;\n  entry_scope : scope\n  entry_info  : entry_info\n}\n\ntype lookup_type = LOOKUP_CURRENT_SCOPE | LOOKUP_ALL_SCOPES\n\nlet start_positive_offset = 8\nlet start_negative_offset = 0\n\nlet the_outer_scope = {\n  sco_parent = None;\n  sco_nesting = 0;\n  sco_entries = [] ;\n  sco_negofs = start_negative_offset\n}\n\nlet no_entry id = {\n  entry_id = id;\n  entry_scope = the_outer_scope;\n  entry_info = ENTRY_none\n}\n\nlet currentScope = ref the_outer_scope\nlet quadNext = ref 1\nlet tempNumber = ref 1\n\nlet tab = ref (H.create 0)\n\nlet initSymbolTable size =\n   tab := H.create size;\n   currentScope := the_outer_scope\n\nlet openScope () =\n  let sco = {\n    sco_parent = Some !currentScope;\n    sco_nesting = !currentScope.sco_nesting + 1;\n    sco_entries = [];\n    sco_negofs = start_negative_offset\n  } in\n  currentScope := sco\n\nlet closeScope () =\n  let sco = !currentScope in\n  let manyentry e = H.remove !tab e.entry_id in\n  List.iter manyentry sco.sco_entries;\n  match sco.sco_parent with\n  | Some scp ->\n      currentScope := scp\n  | None ->\n      internal \"cannot close the outer scope!\"\n\nexception Failure_NewEntry of entry\n\nlet newEntry id inf err =\n  try\n    if err then begin\n      try\n        let e = H.find !tab id in\n        if e.entry_scope.sco_nesting = !currentScope.sco_nesting then\n           raise (Failure_NewEntry e)\n      with Not_found ->\n        ()\n    end;\n    let e = {\n      entry_id = id;\n      entry_scope = !currentScope;\n      entry_info = inf\n    } in\n    H.add !tab id e;\n    !currentScope.sco_entries <- e :: !currentScope.sco_entries;\n    e\n  with Failure_NewEntry e ->\n    error \"duplicate identifier %a\" pretty_id id;\n    e\n\nlet lookupEntry id how err =\n  let scc = !currentScope in\n  let lookup () =\n    match how with\n    | LOOKUP_CURRENT_SCOPE ->\n        let e = H.find !tab id in\n        if e.entry_scope.sco_nesting = scc.sco_nesting then\n          e\n        else\n          raise Not_found\n    | LOOKUP_ALL_SCOPES ->\n        H.find !tab id in\n  if err then\n    try\n      lookup ()\n    with Not_found ->\n      error \"unknown identifier %a (first occurrence)\"\n        pretty_id id;\n      H.add !tab id (no_entry id);\n      raise Exit\n  else\n    lookup ()\n\nlet newVariable id typ err =\n  !currentScope.sco_negofs <- !currentScope.sco_negofs - sizeOfType typ;\n  let size = extractDimensionSizes typ in\n  let inf = {\n    variable_type = typ;\n    variable_offset = !currentScope.sco_negofs;\n    value = match typ with\n            | TYPE_int -> IntValue 0\n            | TYPE_char -> CharValue '0'\n            | _ -> let arr = createArray size in MultiArray arr\n  } in\n  newEntry id (ENTRY_variable inf) err\n\nlet newFunction id err =\n  try\n    let e = lookupEntry id LOOKUP_CURRENT_SCOPE false in\n    match e.entry_info with\n    | ENTRY_function inf when inf.function_isForward ->\n        inf.function_isForward <- false;\n        inf.function_pstatus <- PARDEF_CHECK;\n        inf.function_redeflist <- inf.function_paramlist;\n        e\n    | _ ->\n        if err then\n          error \"duplicate identifier: %a\" pretty_id id;\n          raise Exit\n  with Not_found ->\n    let inf = {\n      function_isForward = false;\n      function_paramlist = [];\n      function_redeflist = [];\n      function_result = TYPE_none;\n      function_pstatus = PARDEF_DEFINE;\n      function_initquad = 0;\n      function_body = fun _ -> None\n    } in\n    newEntry id (ENTRY_function inf) false\n\nlet newParameter id typ mode f err =\n  match f.entry_info with\n  | ENTRY_function inf -> begin\n      match inf.function_pstatus with\n      | PARDEF_DEFINE ->\n          let inf_p = {\n            parameter_type = typ;\n            parameter_offset = 0;\n            parameter_mode = mode\n          } in\n          let e = newEntry id (ENTRY_parameter inf_p) err in\n          inf.function_paramlist <- e :: inf.function_paramlist;\n          e\n      | PARDEF_CHECK -> begin\n          match inf.function_redeflist with\n          | p :: ps -> begin\n              inf.function_redeflist <- ps;\n              match p.entry_info with\n              | ENTRY_parameter inf ->\n                  if not (equalType inf.parameter_type typ) then\n                    error \"Parameter type mismatch in redeclaration \\\n                           of function %a\" pretty_id f.entry_id\n                  else if inf.parameter_mode != mode then\n                    error \"Parameter passing mode mismatch in redeclaration \\\n                           of function %a\" pretty_id f.entry_id\n                  else if p.entry_id != id then\n                    error \"Parameter name mismatch in redeclaration \\\n                           of function %a\" pretty_id f.entry_id\n                  else\n                    H.add !tab id p;\n                  p\n              | _ ->\n                  internal \"I found a parameter that is not a parameter!\";\n                  raise Exit\n            end\n          | [] ->\n              error \"More parameters than expected in redeclaration \\\n                     of function %a\" pretty_id f.entry_id;\n              raise Exit\n        end\n      | PARDEF_COMPLETE ->\n          internal \"Cannot add a parameter to an already defined function\";\n          raise Exit\n    end\n  | _ ->\n      internal \"Cannot add a parameter to a non-function\";\n      raise Exit\n\nlet newTemporary typ =\n  let id = id_make (\"$\" ^ string_of_int !tempNumber) in\n  !currentScope.sco_negofs <- !currentScope.sco_negofs - sizeOfType typ;\n  let inf = {\n    temporary_type = typ;\n    temporary_offset = !currentScope.sco_negofs\n  } in\n  incr tempNumber;\n  newEntry id (ENTRY_temporary inf) false\n\nlet forwardFunction e =\n  match e.entry_info with\n  | ENTRY_function inf ->\n      inf.function_isForward <- true\n  | _ ->\n      internal \"Cannot make a non-function forward\"\n\nlet endFunctionHeader e typ =\n  match e.entry_info with\n  | ENTRY_function inf ->\n      begin\n        match inf.function_pstatus with\n        | PARDEF_COMPLETE ->\n            internal \"Cannot end parameters in an already defined function\"\n        | PARDEF_DEFINE ->\n            inf.function_result <- typ;\n            let offset = ref start_positive_offset in\n            let fix_offset e =\n              match e.entry_info with\n              | ENTRY_parameter inf ->\n                  inf.parameter_offset <- !offset;\n                  let size =\n                    match inf.parameter_mode with\n                    | PASS_BY_VALUE     -> sizeOfType inf.parameter_type\n                    | PASS_BY_REFERENCE -> 2 in\n                  offset := !offset + size\n              | _ ->\n                  internal \"Cannot fix offset to a non parameter\" in\n            List.iter fix_offset inf.function_paramlist;\n            inf.function_paramlist <- List.rev inf.function_paramlist\n        | PARDEF_CHECK ->\n            if inf.function_redeflist <> [] then\n              error \"Fewer parameters than expected in redeclaration \\\n                     of function %a\" pretty_id e.entry_id;\n            if not (equalType inf.function_result typ) then\n              error \"Result type mismatch in redeclaration of function %a\"\n                    pretty_id e.entry_id;\n      end;\n      inf.function_pstatus <- PARDEF_COMPLETE\n  | _ ->\n      internal \"Cannot end parameters in a non-function\"\n\nlet assignToVariable (id: Identifier.id) (expr_val: variable_value) = \n  try\n    let variable_entry = lookupEntry id LOOKUP_CURRENT_SCOPE true in\n    match variable_entry.entry_info with \n    | ENTRY_variable v -> v.value <- expr_val\n    | _ -> error \"not a variable\"\n  with Not_found -> error \"Variable %a not found\" pretty_id id\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/tsimiho/Desktop/NTUA/ECE/Semester8/%CE%9C%CE%B5%CF%84%CE%B1%CE%B3%CE%BB%CF%89%CF%84%CF%84%CE%B9%CF%83%CF%84%CE%AD%CF%82/compiler/Symbol.ml","version":15},"contentChanges":[{"text":"open Identifier\nopen Error\nopen Types\nopen Narray\n\nmodule H = Hashtbl.Make (\n  struct\n    type t = id\n    let equal = (==)\n    let hash = Hashtbl.hash\n  end\n)\n\ntype pass_mode = PASS_BY_VALUE | PASS_BY_REFERENCE\n\ntype param_status =\n  | PARDEF_COMPLETE\n  | PARDEF_DEFINE\n  | PARDEF_CHECK\n\ntype scope = {\n  sco_parent          : scope option;\n  sco_nesting         : int;\n  mutable sco_entries : entry list;\n  mutable sco_negofs  : int\n}\n\nand variable_value =\n  | IntValue of int\n  | CharValue of char\n  | BoolValue of bool\n  | MultiArray of int multi_array\n  | Unit\n\nand variable_info = {\n  variable_type   : Types.typ;\n  variable_offset : int;\n  (* initialized     : bool; *)\n  mutable value   : variable_value\n}\n\nand function_info = {\n  mutable function_isForward : bool;\n  mutable function_paramlist : entry list;\n  mutable function_redeflist : entry list;\n  mutable function_result    : Types.typ;\n  mutable function_pstatus   : param_status;\n  mutable function_initquad  : int;\n  mutable function_body      : unit -> variable_value option\n}\n\nand parameter_info = {\n  parameter_type           : Types.typ;\n  mutable parameter_offset : int;\n  parameter_mode           : pass_mode\n}\n\nand temporary_info = {\n  temporary_type   : Types.typ;\n  temporary_offset : int\n}\n\nand entry_info = ENTRY_none\n               | ENTRY_variable of variable_info\n               | ENTRY_function of function_info\n               | ENTRY_parameter of parameter_info\n               | ENTRY_temporary of temporary_info\n\nand entry = {\n  entry_id    : Identifier.id;\n  entry_scope : scope\n  entry_info  : entry_info\n}\n\ntype lookup_type = LOOKUP_CURRENT_SCOPE | LOOKUP_ALL_SCOPES\n\nlet start_positive_offset = 8\nlet start_negative_offset = 0\n\nlet the_outer_scope = {\n  sco_parent = None;\n  sco_nesting = 0;\n  sco_entries = [] ;\n  sco_negofs = start_negative_offset\n}\n\nlet no_entry id = {\n  entry_id = id;\n  entry_scope = the_outer_scope;\n  entry_info = ENTRY_none\n}\n\nlet currentScope = ref the_outer_scope\nlet quadNext = ref 1\nlet tempNumber = ref 1\n\nlet tab = ref (H.create 0)\n\nlet initSymbolTable size =\n   tab := H.create size;\n   currentScope := the_outer_scope\n\nlet openScope () =\n  let sco = {\n    sco_parent = Some !currentScope;\n    sco_nesting = !currentScope.sco_nesting + 1;\n    sco_entries = [];\n    sco_negofs = start_negative_offset\n  } in\n  currentScope := sco\n\nlet closeScope () =\n  let sco = !currentScope in\n  let manyentry e = H.remove !tab e.entry_id in\n  List.iter manyentry sco.sco_entries;\n  match sco.sco_parent with\n  | Some scp ->\n      currentScope := scp\n  | None ->\n      internal \"cannot close the outer scope!\"\n\nexception Failure_NewEntry of entry\n\nlet newEntry id inf err =\n  try\n    if err then begin\n      try\n        let e = H.find !tab id in\n        if e.entry_scope.sco_nesting = !currentScope.sco_nesting then\n           raise (Failure_NewEntry e)\n      with Not_found ->\n        ()\n    end;\n    let e = {\n      entry_id = id;\n      entry_scope = !currentScope;\n      entry_info = inf\n    } in\n    H.add !tab id e;\n    !currentScope.sco_entries <- e :: !currentScope.sco_entries;\n    e\n  with Failure_NewEntry e ->\n    error \"duplicate identifier %a\" pretty_id id;\n    e\n\nlet lookupEntry id how err =\n  let scc = !currentScope in\n  let lookup () =\n    match how with\n    | LOOKUP_CURRENT_SCOPE ->\n        let e = H.find !tab id in\n        if e.entry_scope.sco_nesting = scc.sco_nesting then\n          e\n        else\n          raise Not_found\n    | LOOKUP_ALL_SCOPES ->\n        H.find !tab id in\n  if err then\n    try\n      lookup ()\n    with Not_found ->\n      error \"unknown identifier %a (first occurrence)\"\n        pretty_id id;\n      H.add !tab id (no_entry id);\n      raise Exit\n  else\n    lookup ()\n\nlet newVariable id typ err =\n  !currentScope.sco_negofs <- !currentScope.sco_negofs - sizeOfType typ;\n  let size = extractDimensionSizes typ in\n  let inf = {\n    variable_type = typ;\n    variable_offset = !currentScope.sco_negofs;\n    value = match typ with\n            | TYPE_int -> IntValue 0\n            | TYPE_char -> CharValue '0'\n            | _ -> let arr = createArray size in MultiArray arr\n  } in\n  newEntry id (ENTRY_variable inf) err\n\nlet newFunction id err =\n  try\n    let e = lookupEntry id LOOKUP_CURRENT_SCOPE false in\n    match e.entry_info with\n    | ENTRY_function inf when inf.function_isForward ->\n        inf.function_isForward <- false;\n        inf.function_pstatus <- PARDEF_CHECK;\n        inf.function_redeflist <- inf.function_paramlist;\n        e\n    | _ ->\n        if err then\n          error \"duplicate identifier: %a\" pretty_id id;\n          raise Exit\n  with Not_found ->\n    let inf = {\n      function_isForward = false;\n      function_paramlist = [];\n      function_redeflist = [];\n      function_result = TYPE_none;\n      function_pstatus = PARDEF_DEFINE;\n      function_initquad = 0;\n      function_body = fun _ -> None\n    } in\n    newEntry id (ENTRY_function inf) false\n\nlet newParameter id typ mode f err =\n  match f.entry_info with\n  | ENTRY_function inf -> begin\n      match inf.function_pstatus with\n      | PARDEF_DEFINE ->\n          let inf_p = {\n            parameter_type = typ;\n            parameter_offset = 0;\n            parameter_mode = mode\n          } in\n          let e = newEntry id (ENTRY_parameter inf_p) err in\n          inf.function_paramlist <- e :: inf.function_paramlist;\n          e\n      | PARDEF_CHECK -> begin\n          match inf.function_redeflist with\n          | p :: ps -> begin\n              inf.function_redeflist <- ps;\n              match p.entry_info with\n              | ENTRY_parameter inf ->\n                  if not (equalType inf.parameter_type typ) then\n                    error \"Parameter type mismatch in redeclaration \\\n                           of function %a\" pretty_id f.entry_id\n                  else if inf.parameter_mode != mode then\n                    error \"Parameter passing mode mismatch in redeclaration \\\n                           of function %a\" pretty_id f.entry_id\n                  else if p.entry_id != id then\n                    error \"Parameter name mismatch in redeclaration \\\n                           of function %a\" pretty_id f.entry_id\n                  else\n                    H.add !tab id p;\n                  p\n              | _ ->\n                  internal \"I found a parameter that is not a parameter!\";\n                  raise Exit\n            end\n          | [] ->\n              error \"More parameters than expected in redeclaration \\\n                     of function %a\" pretty_id f.entry_id;\n              raise Exit\n        end\n      | PARDEF_COMPLETE ->\n          internal \"Cannot add a parameter to an already defined function\";\n          raise Exit\n    end\n  | _ ->\n      internal \"Cannot add a parameter to a non-function\";\n      raise Exit\n\nlet newTemporary typ =\n  let id = id_make (\"$\" ^ string_of_int !tempNumber) in\n  !currentScope.sco_negofs <- !currentScope.sco_negofs - sizeOfType typ;\n  let inf = {\n    temporary_type = typ;\n    temporary_offset = !currentScope.sco_negofs\n  } in\n  incr tempNumber;\n  newEntry id (ENTRY_temporary inf) false\n\nlet forwardFunction e =\n  match e.entry_info with\n  | ENTRY_function inf ->\n      inf.function_isForward <- true\n  | _ ->\n      internal \"Cannot make a non-function forward\"\n\nlet endFunctionHeader e typ =\n  match e.entry_info with\n  | ENTRY_function inf ->\n      begin\n        match inf.function_pstatus with\n        | PARDEF_COMPLETE ->\n            internal \"Cannot end parameters in an already defined function\"\n        | PARDEF_DEFINE ->\n            inf.function_result <- typ;\n            let offset = ref start_positive_offset in\n            let fix_offset e =\n              match e.entry_info with\n              | ENTRY_parameter inf ->\n                  inf.parameter_offset <- !offset;\n                  let size =\n                    match inf.parameter_mode with\n                    | PASS_BY_VALUE     -> sizeOfType inf.parameter_type\n                    | PASS_BY_REFERENCE -> 2 in\n                  offset := !offset + size\n              | _ ->\n                  internal \"Cannot fix offset to a non parameter\" in\n            List.iter fix_offset inf.function_paramlist;\n            inf.function_paramlist <- List.rev inf.function_paramlist\n        | PARDEF_CHECK ->\n            if inf.function_redeflist <> [] then\n              error \"Fewer parameters than expected in redeclaration \\\n                     of function %a\" pretty_id e.entry_id;\n            if not (equalType inf.function_result typ) then\n              error \"Result type mismatch in redeclaration of function %a\"\n                    pretty_id e.entry_id;\n      end;\n      inf.function_pstatus <- PARDEF_COMPLETE\n  | _ ->\n      internal \"Cannot end parameters in a non-function\"\n\nlet assignToVariable (id: Identifier.id) (expr_val: variable_value) = \n  try\n    let variable_entry = lookupEntry id LOOKUP_CURRENT_SCOPE true in\n    match variable_entry.entry_info with \n    | ENTRY_variable v -> v.value <- expr_val\n    | _ -> error \"not a variable\"\n  with Not_found -> error \"Variable %a not found\" pretty_id id\n"}]}}
Read message 
{"jsonrpc":"2.0","id":52,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/tsimiho/Desktop/NTUA/ECE/Semester8/%CE%9C%CE%B5%CF%84%CE%B1%CE%B3%CE%BB%CF%89%CF%84%CF%84%CE%B9%CF%83%CF%84%CE%AD%CF%82/compiler/Symbol.ml"},"position":{"line":0,"character":0}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0269412994385ms
Sending response {"id": 52, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":53,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/tsimiho/Desktop/NTUA/ECE/Semester8/%CE%9C%CE%B5%CF%84%CE%B1%CE%B3%CE%BB%CF%89%CF%84%CF%84%CE%B9%CF%83%CF%84%CE%AD%CF%82/compiler/Irgen.ml"},"position":{"line":71,"character":0}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0290870666504ms
Sending response {"id": 53, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":54,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/tsimiho/Desktop/NTUA/ECE/Semester8/%CE%9C%CE%B5%CF%84%CE%B1%CE%B3%CE%BB%CF%89%CF%84%CF%84%CE%B9%CF%83%CF%84%CE%AD%CF%82/compiler/Parser.mly"},"position":{"line":0,"character":0}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0331401824951ms
Sending response {"id": 54, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":55,"method":"textDocument/definition","params":{"textDocument":{"uri":"file:///Users/tsimiho/Desktop/NTUA/ECE/Semester8/%CE%9C%CE%B5%CF%84%CE%B1%CE%B3%CE%BB%CF%89%CF%84%CF%84%CE%B9%CF%83%CF%84%CE%AD%CF%82/compiler/Parser.mly"},"position":{"line":271,"character":83}}}
[server] Got a method textDocument/definition
[server] processing took 0.0159740447998ms
Sending response {"id": 55, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":56,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/tsimiho/Desktop/NTUA/ECE/Semester8/%CE%9C%CE%B5%CF%84%CE%B1%CE%B3%CE%BB%CF%89%CF%84%CF%84%CE%B9%CF%83%CF%84%CE%AD%CF%82/compiler/Symbol.ml"},"position":{"line":0,"character":0}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0309944152832ms
Sending response {"id": 56, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":57,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/tsimiho/Desktop/NTUA/ECE/Semester8/%CE%9C%CE%B5%CF%84%CE%B1%CE%B3%CE%BB%CF%89%CF%84%CF%84%CE%B9%CF%83%CF%84%CE%AD%CF%82/compiler/Irgen.ml"},"position":{"line":71,"character":0}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0309944152832ms
Sending response {"id": 57, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":58,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/tsimiho/Desktop/NTUA/ECE/Semester8/%CE%9C%CE%B5%CF%84%CE%B1%CE%B3%CE%BB%CF%89%CF%84%CF%84%CE%B9%CF%83%CF%84%CE%AD%CF%82/compiler/Parser.mly"},"position":{"line":0,"character":0}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0290870666504ms
Sending response {"id": 58, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":59,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/tsimiho/Desktop/NTUA/ECE/Semester8/%CE%9C%CE%B5%CF%84%CE%B1%CE%B3%CE%BB%CF%89%CF%84%CF%84%CE%B9%CF%83%CF%84%CE%AD%CF%82/compiler/Irgen.ml"},"position":{"line":71,"character":0}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0460147857666ms
Sending response {"id": 59, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":60,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/tsimiho/Desktop/NTUA/ECE/Semester8/%CE%9C%CE%B5%CF%84%CE%B1%CE%B3%CE%BB%CF%89%CF%84%CF%84%CE%B9%CF%83%CF%84%CE%AD%CF%82/compiler/Irgen.ml"},"range":{"start":{"line":40,"character":4},"end":{"line":40,"character":22}},"context":{"diagnostics":[{"range":{"start":{"line":40,"character":4},"end":{"line":40,"character":22}},"severity":1,"source":"OCaml Merlin","message":"Unbound module Llvm"}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.105857849121ms
Sending response {"id": 60, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":61,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/tsimiho/Desktop/NTUA/ECE/Semester8/%CE%9C%CE%B5%CF%84%CE%B1%CE%B3%CE%BB%CF%89%CF%84%CF%84%CE%B9%CF%83%CF%84%CE%AD%CF%82/compiler/Irgen.ml"},"position":{"line":40,"character":10}}}
[server] Got a method textDocument/hover
[server] processing took 0.0159740447998ms
Sending response {"id": 61, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":62,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/tsimiho/Desktop/NTUA/ECE/Semester8/%CE%9C%CE%B5%CF%84%CE%B1%CE%B3%CE%BB%CF%89%CF%84%CF%84%CE%B9%CF%83%CF%84%CE%AD%CF%82/compiler/Irgen.ml"},"position":{"line":71,"character":0}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0419616699219ms
Sending response {"id": 62, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":63,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/tsimiho/Desktop/NTUA/ECE/Semester8/%CE%9C%CE%B5%CF%84%CE%B1%CE%B3%CE%BB%CF%89%CF%84%CF%84%CE%B9%CF%83%CF%84%CE%AD%CF%82/compiler/Irgen.ml"},"range":{"start":{"line":44,"character":18},"end":{"line":44,"character":36}},"context":{"diagnostics":[{"range":{"start":{"line":44,"character":18},"end":{"line":44,"character":36}},"severity":1,"source":"OCaml Merlin","message":"Unbound module Llvm"}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0231266021729ms
Sending response {"id": 63, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":64,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/tsimiho/Desktop/NTUA/ECE/Semester8/%CE%9C%CE%B5%CF%84%CE%B1%CE%B3%CE%BB%CF%89%CF%84%CF%84%CE%B9%CF%83%CF%84%CE%AD%CF%82/compiler/Irgen.ml"},"position":{"line":44,"character":28}}}
[server] Got a method textDocument/hover
[server] processing took 0.0147819519043ms
Sending response {"id": 64, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":65,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/tsimiho/Desktop/NTUA/ECE/Semester8/%CE%9C%CE%B5%CF%84%CE%B1%CE%B3%CE%BB%CF%89%CF%84%CF%84%CE%B9%CF%83%CF%84%CE%AD%CF%82/compiler/Parser.mly"},"position":{"line":0,"character":0}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0200271606445ms
Sending response {"id": 65, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":66,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/tsimiho/Desktop/NTUA/ECE/Semester8/%CE%9C%CE%B5%CF%84%CE%B1%CE%B3%CE%BB%CF%89%CF%84%CF%84%CE%B9%CF%83%CF%84%CE%AD%CF%82/compiler/Parser.mly"},"position":{"line":17,"character":36}}}
[server] Got a method textDocument/hover
[server] processing took 0.0379085540771ms
Sending response {"id": 66, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":67,"method":"textDocument/definition","params":{"textDocument":{"uri":"file:///Users/tsimiho/Desktop/NTUA/ECE/Semester8/%CE%9C%CE%B5%CF%84%CE%B1%CE%B3%CE%BB%CF%89%CF%84%CF%84%CE%B9%CF%83%CF%84%CE%AD%CF%82/compiler/Parser.mly"},"position":{"line":17,"character":36}}}
[server] Got a method textDocument/definition
[server] processing took 0.0400543212891ms
Sending response {"id": 67, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":68,"method":"shutdown","params":null}
Sending response {"id": 68, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"exit"}
